{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keuvi</title>
    
    <!-- Sentry Error Tracking -->
    <script
        src="https://js.sentry-cdn.com/{{ SENTRY_JS_KEY }}.min.js"
        crossorigin="anonymous"
    ></script>
    <script>
        // Only initialize if key is provided
        if (typeof Sentry !== 'undefined' && '{{ SENTRY_JS_KEY }}') {
            Sentry.onLoad(function() {
                Sentry.init({
                    environment: '{{ DEBUG }}' === 'True' ? 'development' : 'production',
                    tracesSampleRate: '{{ DEBUG }}' === 'True' ? 1.0 : 0.1,
                });
            });
        }
    </script>
    
    <!-- PostHog Analytics -->
    <script>
        !function(t,e){var o,n,p,r;e.__SV||(window.posthog && window.posthog.__loaded)||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.crossOrigin="anonymous",p.async=!0,p.src=s.api_host.replace(".i.posthog.com","-assets.i.posthog.com")+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="init rs ls yi ns us ts ss capture Hi calculateEventProperties vs register register_once register_for_session unregister unregister_for_session gs getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSurveysLoaded onSessionId getSurveys getActiveMatchingSurveys renderSurvey displaySurvey cancelPendingSurvey canRenderSurvey canRenderSurveyAsync identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException startExceptionAutocapture stopExceptionAutocapture loadToolbar get_property getSessionProperty fs ds createPersonProfile ps Qr opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing get_explicit_consent_status is_capturing clear_opt_in_out_capturing hs debug O cs getPageViewId captureTraceFeedback captureTraceMetric Kr".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
        posthog.init('phc_o2ntmXb5bAlisuz5IiY0niqBwuBUkT2Csrs8ROp2LqV', {
            api_host: 'https://us.i.posthog.com',
            defaults: '2025-11-30',
            person_profiles: 'identified_only',
        });
    </script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }
        
        html {
            display: flex;
            flex-direction: column;
        }
        
        body {
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        
        *, *::before, *::after {
            box-sizing: border-box;
        }
        
        * {
            margin: 0;
            padding: 0;
        }
        
        /* CSS Variables for theming */
        :root {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e0e0e0;
            --text-primary: #000000;
            --text-secondary: #666666;
            --border-color: #e0e0e0;
            --accent-color: #3498DB;
            --accent-hover: #2980B9;
            --shadow: rgba(0,0,0,0.08);
        }
        
        body.dark-mode {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3d3d3d;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --border-color: #404040;
            --accent-color: #5dade2;
            --accent-hover: #3498DB;
            --shadow: rgba(0,0,0,0.3);
        }
        
        /* Override inline black text colors in dark mode */
        body.dark-mode [style*="color: #000"],
        body.dark-mode [style*="color:#000"],
        body.dark-mode [style*="color: #333"],
        body.dark-mode [style*="color:#333"],
        body.dark-mode [style*="color: #222"],
        body.dark-mode [style*="color:#222"],
        body.dark-mode [style*="color: black"],
        body.dark-mode [style*="color:black"] {
            color: var(--text-primary) !important;
        }
        
        /* Override inline dark gray text in dark mode */
        body.dark-mode [style*="color: #666"],
        body.dark-mode [style*="color:#666"],
        body.dark-mode [style*="color: #555"],
        body.dark-mode [style*="color:#555"] {
            color: var(--text-secondary) !important;
        }
        
        /* Override white/light backgrounds in dark mode */
        body.dark-mode [style*="background: white"],
        body.dark-mode [style*="background:white"],
        body.dark-mode [style*="background: #fff"],
        body.dark-mode [style*="background:#fff"],
        body.dark-mode [style*="background: #ffffff"],
        body.dark-mode [style*="background:#ffffff"],
        body.dark-mode [style*="background: #f9f9f9"],
        body.dark-mode [style*="background:#f9f9f9"],
        body.dark-mode [style*="background: #f0f8ff"],
        body.dark-mode [style*="background:#f0f8ff"],
        body.dark-mode [style*="background: #f0fff0"],
        body.dark-mode [style*="background:#f0fff0"],
        body.dark-mode [style*="background: #fff0f0"],
        body.dark-mode [style*="background:#fff0f0"],
        body.dark-mode [style*="background: #fff9e6"],
        body.dark-mode [style*="background:#fff9e6"],
        body.dark-mode [style*="background: #fffacd"],
        body.dark-mode [style*="background:#fffacd"],
        body.dark-mode [style*="background: #fff3cd"],
        body.dark-mode [style*="background:#fff3cd"],
        body.dark-mode [style*="background: #e3f2fd"],
        body.dark-mode [style*="background:#e3f2fd"],
        body.dark-mode [style*="background: #f0f0f0"],
        body.dark-mode [style*="background:#f0f0f0"],
        body.dark-mode [style*="background: #f5f5f5"],
        body.dark-mode [style*="background:#f5f5f5"] {
            background: var(--bg-secondary) !important;
        }
        
        /* Override white backgrounds in explanation content specifically */
        body.dark-mode .explanation [style*="background"],
        body.dark-mode [id^="explanation_"] [style*="background"],
        body.dark-mode [id*="explanation"] [style*="background"] {
            background: var(--bg-tertiary) !important;
        }
        
        /* Override borders in dark mode for explanation boxes */
        body.dark-mode .explanation [style*="border"],
        body.dark-mode [id^="explanation_"] [style*="border"] {
            border-color: var(--border-color) !important;
        }
        
        /* Override light blue backgrounds with darker version */
        body.dark-mode [style*="background: #f0f8ff"],
        body.dark-mode [style*="background:#f0f8ff"],
        body.dark-mode [style*="background: #e3f2fd"],
        body.dark-mode [style*="background:#e3f2fd"] {
            background: rgba(52, 152, 219, 0.15) !important;
        }
        
        /* Override light green backgrounds */
        body.dark-mode [style*="background: #f0fff0"],
        body.dark-mode [style*="background:#f0fff0"],
        body.dark-mode [style*="background: #d4edda"],
        body.dark-mode [style*="background:#d4edda"] {
            background: rgba(40, 167, 69, 0.15) !important;
        }
        
        /* Override light red backgrounds */
        body.dark-mode [style*="background: #fff0f0"],
        body.dark-mode [style*="background:#fff0f0"],
        body.dark-mode [style*="background: #f8d7da"],
        body.dark-mode [style*="background:#f8d7da"] {
            background: rgba(220, 53, 69, 0.15) !important;
        }
        
        /* Override light yellow backgrounds */
        body.dark-mode [style*="background: #fff9e6"],
        body.dark-mode [style*="background:#fff9e6"],
        body.dark-mode [style*="background: #fffacd"],
        body.dark-mode [style*="background:#fffacd"],
        body.dark-mode [style*="background: #fff3cd"],
        body.dark-mode [style*="background:#fff3cd"] {
            background: rgba(255, 193, 7, 0.15) !important;
        }
        
        body {
            font-family: 'DIN Round Pro', 'Nunito', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            padding: 0;
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Import Nunito as Duolingo-like fallback font */
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;500;600;700;800&display=swap');
        
        .container {
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            padding: 0 24px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        header {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 16px 24px;
            margin: 16px 0;
            border: 2px solid #E5E5E5;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        body.dark-mode header {
            border-color: var(--border-color);
        }

        .logo {
            text-decoration: none;
            color: #083242;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            transition: transform 0.2s ease, color 0.3s ease;
        }

        .logo span {
            font-size: 28px;
            font-weight: 800;
            letter-spacing: -0.5px;
        }
        
        /* Dark Mode Toggle Button */
        .dark-mode-toggle {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            width: 50px;
            height: 28px;
            cursor: pointer;
            padding: 2px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
        }
        
        .dark-mode-toggle:hover {
            border-color: var(--accent-color);
        }
        
        .dark-mode-toggle-slider {
            width: 24px;
            height: 24px;
            background: var(--bg-secondary);
            border-radius: 50%;
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px var(--shadow);
        }
        
        body.dark-mode .dark-mode-toggle-slider {
            transform: translateX(22px);
        }
        
        .dark-mode-toggle-icon {
            font-size: 14px;
            transition: opacity 0.3s ease;
        }
        
        .dark-mode-toggle-icon.sun {
            opacity: 1;
        }
        
        .dark-mode-toggle-icon.moon {
            opacity: 0;
            position: absolute;
        }
        
        body.dark-mode .dark-mode-toggle-icon.sun {
            opacity: 0;
        }
        
        body.dark-mode .dark-mode-toggle-icon.moon {
            opacity: 1;
        }
        
        .logo:hover {
            transform: scale(1.02);
        }
        
        .logo img {
            height: 48px;
            width: auto;
            display: block;
        }

        .auth-section {
            display: flex;
            gap: 10px;
            align-items: center;
            position: absolute;
            right: 30px;
        }
        
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 700;
            transition: all 0.15s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: #58CC02;
            color: #fff;
            box-shadow: 0 4px 0 #46a302;
        }

        .btn-primary:hover {
            background: #61df00;
            transform: translateY(-1px);
            box-shadow: 0 5px 0 #46a302;
        }

        .btn-primary:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #46a302;
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: #1CB0F6;
            border: 2px solid #E5E5E5;
            box-shadow: 0 4px 0 #d1d1d1;
        }

        body.dark-mode .btn-secondary {
            border-color: var(--border-color);
            box-shadow: 0 4px 0 var(--border-color);
        }

        .btn-secondary:hover {
            background: rgba(28, 176, 246, 0.1);
            transform: translateY(-1px);
            box-shadow: 0 5px 0 #d1d1d1;
        }

        body.dark-mode .btn-secondary:hover {
            box-shadow: 0 5px 0 var(--border-color);
        }

        .btn-secondary:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #d1d1d1;
        }

        .btn-success {
            background: #58CC02;
            color: #fff;
            box-shadow: 0 4px 0 #46a302;
        }

        .btn-success:hover {
            background: #61df00;
            transform: translateY(-1px);
            box-shadow: 0 5px 0 #46a302;
        }

        .btn-success:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #46a302;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }
        
        .content-column {
            min-width: 0;
            width: 100%;
        }
        
        .passages-section {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 24px;
            border: 2px solid #E5E5E5;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        body.dark-mode .passages-section {
            border-color: var(--border-color);
        }

        .passages-section h2 {
            color: var(--text-primary);
            font-size: 24px;
            font-weight: 800;
            margin-bottom: 20px;
            padding-bottom: 0;
            border-bottom: none;
        }

        .category-picker {
            display: flex;
            gap: 8px;
            background: transparent;
            border-radius: 0;
            padding: 0;
            border: none;
            margin-bottom: 24px;
            overflow: visible;
        }

        .category-picker button {
            flex: 1;
            padding: 14px 20px;
            border: 2px solid #E5E5E5;
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.15s ease;
            border-radius: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 0 #d1d1d1;
        }

        body.dark-mode .category-picker button {
            border-color: var(--border-color);
            box-shadow: 0 4px 0 var(--border-color);
        }

        .category-picker button.active {
            background: #1CB0F6;
            color: white;
            border-color: #1CB0F6;
            box-shadow: 0 4px 0 #1899d6;
        }

        .category-picker button:hover:not(.active) {
            background: rgba(28, 176, 246, 0.1);
            border-color: #1CB0F6;
            transform: translateY(-1px);
            box-shadow: 0 5px 0 #d1d1d1;
        }

        .category-picker button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #d1d1d1;
        }

        .category-picker button.active:active {
            box-shadow: 0 2px 0 #1899d6;
        }
        
        .category-content {
            display: none;
        }
        
        .category-content.active {
            display: block;
        }
        
        .sidebar {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 20px;
            border: 2px solid #E5E5E5;
            height: fit-content;
            position: sticky;
            top: 20px;
            align-self: flex-start;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        body.dark-mode .sidebar {
            border-color: var(--border-color);
        }

        .passage-card {
            border: 2px solid #E5E5E5;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.15s ease;
            background: var(--bg-secondary);
            box-shadow: 0 2px 0 #d1d1d1;
        }

        body.dark-mode .passage-card {
            border-color: var(--border-color);
            box-shadow: 0 2px 0 var(--border-color);
        }

        .passage-card:hover {
            border-color: #58CC02;
            transform: translateY(-2px);
            box-shadow: 0 4px 0 rgba(88, 204, 2, 0.3);
        }

        .passage-card:active {
            transform: translateY(1px);
            box-shadow: 0 1px 0 #d1d1d1;
        }

        .passage-card h3 {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 6px;
        }

        .passage-card p {
            color: var(--text-secondary);
            font-size: 14px;
            margin: 0;
        }

        .passage-card.premium {
            border-left: 4px solid #CE82FF;
        }

        /* ====== DUOLINGO-STYLE SKILL GRID ====== */

        /* Skills container with flowing path layout */
        .skills-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 24px;
            padding: 20px 10px;
            max-width: 600px;
            margin: 0 auto;
        }

        /* Individual skill node */
        .skill-node {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: transform 0.2s ease;
            width: 100px;
        }

        .skill-node:hover {
            transform: scale(1.08);
        }

        .skill-node:active {
            transform: scale(0.98);
        }

        /* Locked skill styling */
        .skill-node.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .skill-node.locked:hover {
            transform: none;
        }

        /* Circular skill icon container */
        .skill-icon {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: box-shadow 0.2s ease, transform 0.2s ease;
            overflow: visible;
        }

        .skill-node:hover .skill-icon {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }

        /* Icon image or letter placeholder */
        .skill-icon img {
            width: 50px;
            height: 50px;
            object-fit: contain;
            border-radius: 8px;
        }

        .skill-icon-letter {
            font-size: 32px;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Progress ring SVG container */
        .progress-ring-container {
            position: absolute;
            inset: -6px;
            pointer-events: none;
        }

        .progress-ring {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        .progress-ring-bg {
            fill: none;
            stroke: var(--bg-tertiary);
            stroke-width: 4;
        }

        .progress-ring-fill {
            fill: none;
            stroke-width: 4;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.3s ease;
        }

        /* Completion crown badge */
        .skill-crown {
            position: absolute;
            top: -12px;
            right: -8px;
            font-size: 20px;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
            animation: crown-bounce 2s ease-in-out infinite;
        }

        @keyframes crown-bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
        }

        /* Premium lock badge */
        .skill-lock {
            position: absolute;
            bottom: -4px;
            right: -4px;
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            border: 2px solid var(--bg-secondary);
        }

        /* Skill title */
        .skill-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
            text-align: center;
            line-height: 1.2;
            max-width: 90px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        /* Category header in grid view */
        .skills-category-header {
            width: 100%;
            text-align: center;
            margin: 30px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--accent-color);
        }

        .skills-category-header h3 {
            color: var(--accent-color);
            font-size: 22px;
            font-weight: 600;
            margin: 0;
        }

        /* First header doesn't need top margin */
        .skills-grid .skills-category-header:first-child {
            margin-top: 0;
        }

        /* ====== GAMIFICATION SIDEBAR ELEMENTS ====== */

        .gamification-stats {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid var(--border-color);
        }

        .stat-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
        }

        .stat-row:not(:last-child) {
            border-bottom: 1px solid var(--border-color);
        }

        .stat-icon {
            font-size: 24px;
            width: 36px;
            text-align: center;
        }

        .stat-info {
            flex: 1;
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .streak-flames {
            display: flex;
            gap: 2px;
            margin-top: 4px;
        }

        .streak-flame {
            font-size: 14px;
            opacity: 0.3;
        }

        .streak-flame.active {
            opacity: 1;
            animation: flame-flicker 0.8s ease-in-out infinite alternate;
        }

        @keyframes flame-flicker {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }

        /* View mode toggle */
        .view-mode-toggle {
            display: flex;
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 4px;
            margin-bottom: 20px;
        }

        .view-mode-toggle button {
            flex: 1;
            padding: 8px 12px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .view-mode-toggle button.active {
            background: var(--bg-secondary);
            color: var(--text-primary);
            box-shadow: 0 2px 4px var(--shadow);
        }

        .view-mode-toggle button:hover:not(.active) {
            background: var(--bg-secondary);
            opacity: 0.7;
        }

        /* Category default colors */
        .skill-color-reading { background: linear-gradient(135deg, #58CC02 0%, #46A302 100%); }
        .skill-color-writing { background: linear-gradient(135deg, #CE82FF 0%, #A855F7 100%); }
        .skill-color-math { background: linear-gradient(135deg, #00BFFF 0%, #0095CC 100%); }

        /* Skill colors based on API icon_color */
        .skill-bg-green { background: linear-gradient(135deg, #58CC02 0%, #46A302 100%); }
        .skill-bg-purple { background: linear-gradient(135deg, #CE82FF 0%, #A855F7 100%); }
        .skill-bg-blue { background: linear-gradient(135deg, #00BFFF 0%, #0095CC 100%); }
        .skill-bg-orange { background: linear-gradient(135deg, #FF9500 0%, #E68600 100%); }
        .skill-bg-red { background: linear-gradient(135deg, #FF4B4B 0%, #E63939 100%); }
        .skill-bg-yellow { background: linear-gradient(135deg, #FFCC00 0%, #E6B800 100%); }
        .skill-bg-teal { background: linear-gradient(135deg, #20B2AA 0%, #178F89 100%); }
        .skill-bg-pink { background: linear-gradient(135deg, #FF69B4 0%, #E65FA3 100%); }

        /* Responsive skill grid */
        @media (max-width: 768px) {
            .skills-grid {
                gap: 16px;
                padding: 16px 8px;
            }

            .skill-node {
                width: 85px;
            }

            .skill-icon {
                width: 70px;
                height: 70px;
            }

            .skill-icon img {
                width: 42px;
                height: 42px;
            }

            .skill-icon-letter {
                font-size: 28px;
            }

            .skill-title {
                font-size: 11px;
                max-width: 80px;
            }

            .progress-ring-container {
                inset: -5px;
            }

            .progress-ring-bg,
            .progress-ring-fill {
                stroke-width: 3;
            }
        }

        @media (max-width: 480px) {
            .skills-grid {
                gap: 12px;
            }

            .skill-node {
                width: 75px;
            }

            .skill-icon {
                width: 60px;
                height: 60px;
            }

            .skill-icon img {
                width: 36px;
                height: 36px;
            }

            .skill-icon-letter {
                font-size: 24px;
            }

            .skill-title {
                font-size: 10px;
                max-width: 70px;
            }
        }

        /* ====== END DUOLINGO-STYLE SKILL GRID ====== */

        .premium-badge {
            display: inline-block;
            background: #FFD700;
            color: #000;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .premium-lock {
            display: inline-block;
            margin-left: 8px;
            color: #FFD700;
            font-size: 18px;
            font-weight: bold;
            vertical-align: middle;
        }
        
        .premium-preview-overlay {
            position: relative;
            max-height: 400px;
            overflow: hidden;
        }
        
        .premium-preview-overlay::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.8) 50%, rgba(255, 255, 255, 1) 100%);
            pointer-events: none;
        }
        
        .premium-upgrade-prompt {
            background: #083242;
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            margin: 30px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .premium-upgrade-prompt h3 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 24px;
        }
        
        .premium-upgrade-prompt p {
            margin-bottom: 20px;
            font-size: 16px;
            opacity: 0.95;
        }
        
        .premium-upgrade-prompt .btn {
            background: white;
            color: #083242;
            font-weight: bold;
            padding: 12px 30px;
            font-size: 16px;
        }
        
        .premium-upgrade-prompt .btn:hover {
            background: #f0f0f0;
        }
        
        .passage-detail-section {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding-top: clamp(16px, 4vw, 30px);
            padding-bottom: clamp(16px, 4vw, 30px);
            padding-left: 0;
            padding-right: 0;
            box-shadow: 0 2px 8px var(--shadow);
            border: 1px solid var(--border-color);
            transition: background-color 0.3s ease, border-color 0.3s ease;
            width: 100%;
        }
        
        /* Desktop-specific padding for passage detail section */
        @media (min-width: 769px) {
            .passage-detail-section {
                padding-left: clamp(16px, 4vw, 30px);
                padding-right: clamp(16px, 4vw, 30px);
            }
        }
        
        /* Reading container wrapper - simplified, no font-size logic */
        .passage-reading-container {
            width: 100%;
            padding-inline: 0;
        }
        
        .passage-content {
            background: var(--bg-primary);
            border-radius: 8px;
            padding-top: 14px;
            padding-bottom: 14px;
            padding-left: 8px;
            padding-right: 14px;
            margin-bottom: 1.5em;
            line-height: 1.45;
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            white-space: normal;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            word-break: normal;
            overflow-wrap: break-word;
            hyphens: auto;
            width: 100%;
            box-sizing: border-box;
        }
        
        .passage-content p {
            margin: 0 0 0.8em 0;
        }
        
        .passage-content-sat {
            background: var(--bg-primary);
            border-radius: 8px;
            padding-top: 14px;
            padding-bottom: 14px;
            padding-left: 8px;
            padding-right: 14px;
            margin-bottom: 1.5em;
            border: 1px solid var(--border-color);
            font-family: "Minion Pro", "Minion", "Times New Roman", "Times", serif;
            line-height: 1.45;
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            word-break: normal;
            overflow-wrap: break-word;
            hyphens: auto;
            width: 100%;
            box-sizing: border-box;
        }
        
        .passage-content-sat p {
            margin: 0 0 0.8em 0;
        }
        
        .passage-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            column-gap: 40px;
        }
        
        .passage-column {
            width: 100%;
        }
        
        .passage-line {
            font-family: "Minion Pro", "Minion", "Times New Roman", "Times", serif;
            line-height: 1.45;
            white-space: normal;
            margin: 0;
            padding: 0;
            word-break: normal;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        
        .passage-line-numbered {
            display: flex;
            align-items: flex-start;
            margin: 0 0 0.5em 0;
            padding: 0;
            gap: clamp(3px, 0.8vw, 6px);
        }
        
        .line-number {
            color: var(--text-secondary);
            font-size: clamp(10px, 1.2vw, 12px);
            font-weight: bold;
            min-width: clamp(20px, 3vw, 28px);
            text-align: right;
            padding-top: 2px;
            padding-left: 0;
            margin-left: 0;
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
            flex-shrink: 0;
        }
        
        .line-text {
            flex: 1;
            font-family: "Minion Pro", "Minion", "Times New Roman", "Times", serif;
            line-height: 1.45;
            white-space: normal;
            color: var(--text-primary);
            word-break: normal;
            overflow-wrap: break-word;
            hyphens: auto;
            min-width: 0;
        }
        
        .questions-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        /* Ensure questions flow in reading order (left-to-right, top-to-bottom) */
        .questions-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }
        
        @media (max-width: 1024px) {
            .passage-columns,
            .questions-columns,
            .questions-grid {
                grid-template-columns: 1fr;
                gap: 0;
            }
        }
        
        @media (max-width: 768px) {
            .passage-columns,
            .questions-columns,
            .questions-grid {
                gap: 0;
            }
        }
        
        .question-card {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            background: var(--bg-secondary);
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .question-card h4 {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
        }
        
        .question-card p {
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
            color: var(--text-primary);
        }
        
        .option {
            display: flex;
            align-items: flex-start;
            padding: 12px;
            margin-bottom: 10px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
        }
        
        .option:hover {
            border-color: var(--accent-color);
            background: var(--bg-primary);
        }
        
        .option.selected {
            border-color: var(--accent-color);
            background: var(--bg-primary);
        }
        
        .option.correct {
            border-color: #27ae60;
            background: #d4edda;
        }
        
        .option.incorrect {
            border-color: #e74c3c;
            background: #f8d7da;
        }
        
        .option input[type="radio"] {
            margin-right: 12px;
            margin-top: 2px;
            cursor: pointer;
        }
        
        .option-label {
            flex: 1;
            color: #000;
            font-size: 15px;
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
        }
        
        .explanation {
            margin-top: 15px;
            padding: 15px;
            background: #f0f8ff;
            border-left: 4px solid #3498DB;
            border-radius: 4px;
            color: #000;
            font-size: 14px;
            line-height: 1.6;
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        body.dark-mode .explanation {
            background: rgba(52, 152, 219, 0.15);
            color: var(--text-primary);
        }
        
        .results-summary {
            background: #f9f9f9;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #e0e0e0;
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
        }
        
        .results-summary h3 {
            color: #000;
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 15px;
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
        }
        
        .score {
            font-size: 32px;
            font-weight: 700;
            color: #3498DB;
            margin: 10px 0;
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        body.dark-mode .modal {
            background: rgba(0,0,0,0.7);
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .modal-content h2 {
            color: var(--accent-color);
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--accent-color);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 14px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        
        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        
        .error {
            color: #dc3545;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .user-info {
            padding: 16px;
            background: var(--bg-primary);
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .user-info strong {
            color: #000;
            font-weight: 600;
        }
        
        .subscription-info {
            padding: 16px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }
        
        .subscription-info strong {
            color: #000;
            font-weight: 600;
        }
        
        .word-of-day {
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
            box-shadow: 0 2px 8px var(--shadow);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .word-of-day h3 {
            color: var(--accent-color);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--accent-color);
        }
        
        .word-of-day .word {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-color);
            margin-bottom: 12px;
        }
        
        .word-of-day .definition {
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 12px;
        }
        
        .word-of-day .synonyms {
            margin-bottom: 12px;
        }
        
        .word-of-day .synonyms-label {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 13px;
            margin-bottom: 6px;
        }
        
        .word-of-day .synonym-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .word-of-day .synonym-tag {
            background: rgba(52, 152, 219, 0.1);
            color: var(--accent-color);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }
        
        .word-of-day .example {
            margin-top: 12px;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: 6px;
            border-left: 3px solid var(--accent-color);
            transition: background-color 0.3s ease;
        }
        
        .word-of-day .example-label {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 13px;
            margin-bottom: 6px;
        }
        
        .word-of-day .example-sentence {
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.6;
            font-style: italic;
        }
        
        .word-of-day .loading {
            text-align: center;
            color: var(--text-secondary);
            padding: 20px;
        }
        
        .hidden {
            display: none;
        }
        
        /* Landing Page Styles */
        .landing-page {
            display: block;
            animation: fadeIn 0.5s ease-out;
            padding: 0 24px;
            max-width: 1200px;
            margin: 0 auto;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .landing-page ~ header,
        .landing-page header {
            display: none;
        }

        body:has(.landing-page:not([style*="display: none"])) header {
            display: none;
        }

        /* Duolingo-style sticky landing navigation */
        .landing-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 0;
            margin-bottom: 24px;
            border-bottom: 2px solid #E5E5E5;
        }

        body.dark-mode .landing-nav {
            border-bottom-color: var(--border-color);
        }

        .landing-nav-logo {
            display: flex;
            align-items: center;
            gap: 12px;
            text-decoration: none;
        }

        .landing-nav-logo img {
            height: 48px;
            width: auto;
        }

        .landing-nav-logo span {
            font-size: 28px;
            font-weight: 800;
            color: #083242;
            letter-spacing: -0.5px;
        }

        .landing-nav-buttons {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .landing-dark-toggle {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            background: transparent;
            border: 2px solid #E5E5E5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s ease;
        }

        .landing-dark-toggle:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        body.dark-mode .landing-dark-toggle {
            border-color: var(--border-color);
        }

        body.dark-mode .landing-dark-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .landing-dark-toggle .sun-icon {
            display: block;
        }

        .landing-dark-toggle .moon-icon {
            display: none;
        }

        body.dark-mode .landing-dark-toggle .sun-icon {
            display: none;
        }

        body.dark-mode .landing-dark-toggle .moon-icon {
            display: block;
        }

        .btn-nav {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 700;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.15s ease;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            border: none;
        }

        .btn-nav-ghost {
            background: transparent;
            color: #1CB0F6;
        }

        .btn-nav-ghost:hover {
            background: rgba(28, 176, 246, 0.1);
        }

        .btn-nav-primary {
            background: #58CC02;
            color: white;
            box-shadow: 0 4px 0 #46a302;
        }

        .btn-nav-primary:hover {
            background: #61df00;
            transform: translateY(-1px);
            box-shadow: 0 5px 0 #46a302;
        }

        .btn-nav-primary:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #46a302;
        }

        /* Brand Colors - Duolingo-inspired vibrant palette */
        :root {
            --navy: #1B2A4A;
            --gold: #FFC800;
            --blue: #1CB0F6;
            --keuvi-green: #58CC02;
            --keuvi-green-dark: #46a302;
            --keuvi-blue: #1CB0F6;
            --keuvi-blue-dark: #1899d6;
            --keuvi-orange: #FF9600;
            --keuvi-purple: #CE82FF;
            --keuvi-pink: #FF86D0;
            --keuvi-red: #FF4B4B;
        }

        /* Hero Section - Duolingo-style clean centered layout */
        .landing-hero {
            background: #FFFFFF;
            border-radius: 20px;
            padding: 40px 48px 40px;
            text-align: center;
            max-width: 100%;
            margin: 0 0 32px 0;
            border: 2px solid #E5E5E5;
            position: relative;
            overflow: hidden;
        }

        body.dark-mode .landing-hero {
            background: var(--bg-secondary);
            border-color: var(--border-color);
        }

        /* Subtle pattern overlay */
        .landing-hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23000000' fill-opacity='0.02'%3E%3Ccircle cx='30' cy='30' r='4'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            pointer-events: none;
        }

        body.dark-mode .landing-hero::before {
            background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.03'%3E%3Ccircle cx='30' cy='30' r='4'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        }

        /* Floating decorative shapes - more subtle */
        .hero-shapes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .hero-shape {
            position: absolute;
            border-radius: 50%;
            opacity: 0.08;
            animation: floatSlow 8s ease-in-out infinite;
        }

        .hero-shape-1 {
            width: 200px;
            height: 200px;
            background: #58CC02;
            top: -50px;
            left: -50px;
        }

        .hero-shape-2 {
            width: 150px;
            height: 150px;
            background: #1CB0F6;
            top: 60%;
            right: -40px;
            animation-delay: 2s;
        }

        .hero-shape-3 {
            width: 100px;
            height: 100px;
            background: #FFC800;
            bottom: -30px;
            left: 20%;
            animation-delay: 4s;
        }

        .hero-shape-4 {
            width: 80px;
            height: 80px;
            background: #CE82FF;
            top: 20%;
            right: 15%;
            animation-delay: 1s;
        }

        @keyframes floatSlow {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-15px) scale(1.02); }
        }

        .hero-content {
            position: relative;
            z-index: 1;
            max-width: 720px;
            margin: 0 auto;
        }

        .hero-main {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 32px;
            margin-bottom: 0;
        }

        .hero-logo {
            flex-shrink: 0;
            margin-top: -16px;
        }

        .hero-logo img {
            height: 380px;
            width: auto;
            display: block;
            margin: 0 auto;
            object-fit: contain;
            object-position: center;
            animation: gentleBounce 4s ease-in-out infinite;
            filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.15));
        }

        body.dark-mode .hero-logo img {
            filter: drop-shadow(0 8px 20px rgba(255, 255, 255, 0.2));
        }

        @keyframes gentleBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-12px); }
        }

        .hero-text {
            text-align: center;
        }

        .hero-title {
            font-size: 42px;
            font-weight: 800;
            color: #3C3C3C;
            margin-bottom: 16px;
            line-height: 1.15;
        }

        body.dark-mode .hero-title {
            color: var(--text-primary);
        }

        .hero-title-highlight {
            display: block;
            color: #58CC02;
            font-size: 48px;
            margin-top: 4px;
        }

        .hero-tagline {
            font-size: 20px;
            color: #6B7280;
            margin-bottom: 32px;
            font-weight: 500;
            line-height: 1.5;
        }

        body.dark-mode .hero-tagline {
            color: var(--text-secondary);
        }

        .hero-features {
            margin-bottom: 8px;
        }

        .hero-features-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 24px;
            margin-bottom: 0;
        }

        .hero-feature-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 15px;
            color: #4B5563;
            font-weight: 600;
        }

        body.dark-mode .hero-feature-item {
            color: var(--text-secondary);
        }

        .hero-feature-icon {
            width: 24px;
            height: 24px;
            background: #58CC02;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            flex-shrink: 0;
            color: white;
        }

        /* CTA Button Row - Duolingo style */
        .hero-cta-row {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            margin-top: 40px;
        }

        .btn-large {
            padding: 16px 80px;
            font-size: 15px;
            font-weight: 700;
            border-radius: 16px;
            background: #58CC02;
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: 0 5px 0 #46a302;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 280px;
        }

        .btn-large:hover {
            background: #61df00;
            transform: translateY(-2px);
            box-shadow: 0 7px 0 #46a302;
        }

        .btn-large:active {
            transform: translateY(3px);
            box-shadow: 0 2px 0 #46a302;
        }

        .btn-secondary-large {
            padding: 14px 48px;
            font-size: 15px;
            font-weight: 700;
            border-radius: 16px;
            background: #1CB0F6;
            color: white;
            border: none;
            box-shadow: 0 5px 0 #1899d6;
            cursor: pointer;
            transition: all 0.15s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 280px;
        }

        .btn-secondary-large:hover {
            background: #3dc0fc;
            transform: translateY(-2px);
            box-shadow: 0 7px 0 #1899d6;
        }

        .btn-secondary-large:active {
            transform: translateY(3px);
            box-shadow: 0 2px 0 #1899d6;
        }

        /* Social Proof Strip - Duolingo style stats */
        .social-proof {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 48px;
            margin-top: 48px;
            padding-top: 32px;
            border-top: 1px solid #E5E5E5;
            flex-wrap: wrap;
        }

        body.dark-mode .social-proof {
            border-top-color: var(--border-color);
        }

        .social-proof-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            color: #6B7280;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        body.dark-mode .social-proof-item {
            color: var(--text-secondary);
        }

        .social-proof-icon {
            font-size: 28px;
            margin-bottom: 4px;
        }

        .social-proof-number {
            font-size: 24px;
            font-weight: 800;
            color: #3C3C3C;
            display: block;
        }

        body.dark-mode .social-proof-number {
            color: var(--text-primary);
        }

        /* Feature Highlight Cards - Duolingo style */
        .feature-highlights {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 48px;
        }

        .feature-highlight-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 28px 24px 24px;
            text-align: center;
            border: 2px solid #E5E5E5;
            transition: all 0.2s ease;
            cursor: pointer;
            box-shadow: 0 2px 0 #E5E5E5;
        }

        body.dark-mode .feature-highlight-card {
            border-color: var(--border-color);
            box-shadow: 0 2px 0 var(--border-color);
        }

        .feature-highlight-card:hover {
            transform: translateY(-4px);
            border-color: #58CC02;
            box-shadow: 0 6px 0 rgba(88, 204, 2, 0.3);
        }

        .feature-highlight-card:active {
            transform: translateY(0);
            box-shadow: 0 2px 0 #E5E5E5;
        }

        .feature-highlight-icon {
            width: 72px;
            height: 72px;
            margin: 0 auto 16px;
            background: #58CC02;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            box-shadow: 0 4px 0 #46a302;
        }

        .feature-highlight-card:nth-child(2) .feature-highlight-icon {
            background: #1CB0F6;
            box-shadow: 0 4px 0 #1899d6;
        }

        .feature-highlight-card:nth-child(3) .feature-highlight-icon {
            background: #FF9600;
            box-shadow: 0 4px 0 #e68600;
        }

        .feature-highlight-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .feature-highlight-desc {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.5;
        }
        
        /* Product Preview Section */
        .preview-section {
            margin-bottom: 80px;
        }
        
        .preview-section h3 {
            text-align: center;
            font-size: 36px;
            font-weight: 700;
            color: var(--navy);
            margin-bottom: 50px;
        }
        
        .preview-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-bottom: 60px;
        }
        
        .preview-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 4px 16px var(--shadow);
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .preview-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 8px 24px var(--shadow);
        }
        
        .preview-card-icon {
            font-size: 56px;
            margin-bottom: 20px;
        }
        
        .preview-card h4 {
            color: var(--text-primary);
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 12px;
        }
        
        .preview-card p {
            color: var(--text-secondary);
            font-size: 15px;
            line-height: 1.6;
        }
        
        /* Premium Promo Section - Duolingo Super style */
        .premium-promo-section {
            background: #083242;
            border-radius: 16px;
            padding: 48px 32px;
            margin-bottom: 48px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .premium-promo-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23ffffff' fill-opacity='0.05'%3E%3Cpath d='M20 20l5 5-5 5-5-5z'/%3E%3C/g%3E%3C/svg%3E");
            pointer-events: none;
        }

        .premium-promo-content {
            position: relative;
            z-index: 1;
        }

        .premium-promo-badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 16px;
        }

        .premium-promo-title {
            font-size: 28px;
            font-weight: 800;
            color: white;
            margin-bottom: 12px;
        }

        .premium-promo-desc {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.5;
            max-width: 400px;
            margin: 0 auto 24px;
        }

        .premium-promo-price {
            margin-bottom: 24px;
        }

        .premium-price-amount {
            font-size: 48px;
            font-weight: 800;
            color: white;
        }

        .premium-price-period {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 600;
        }

        .btn-premium {
            padding: 14px 48px;
            font-size: 15px;
            font-weight: 700;
            border-radius: 16px;
            background: white;
            color: #083242;
            border: none;
            box-shadow: 0 5px 0 rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.15s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-premium:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 0 rgba(0, 0, 0, 0.2);
        }

        .btn-premium:active {
            transform: translateY(3px);
            box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
        }

        @media (max-width: 768px) {
            .premium-promo-section {
                padding: 36px 24px;
                margin-bottom: 32px;
            }

            .premium-promo-title {
                font-size: 22px;
            }

            .premium-promo-desc {
                font-size: 14px;
            }

            .premium-price-amount {
                font-size: 36px;
            }
        }
        
        /* Feature Cards - Enhanced */
        .landing-features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-bottom: 80px;
        }
        
        .feature-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: 0 4px 16px var(--shadow);
            border: 1px solid var(--border-color);
            text-align: center;
            transition: all 0.3s ease;
        }
        
        body.dark-mode .feature-card {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.05) 0%, var(--bg-secondary) 100%);
        }
        
        .feature-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 8px 24px var(--shadow);
        }
        
        .feature-card h3 {
            color: var(--text-primary);
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 16px;
        }
        
        .feature-card p {
            color: var(--text-secondary);
            font-size: 16px;
            line-height: 1.7;
        }
        
        .feature-icon {
            font-size: 64px;
            margin-bottom: 24px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }
        
        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            /* Landing page mobile padding */
            .landing-page {
                padding: 0 16px;
            }

            /* Landing nav mobile */
            .landing-nav {
                padding: 12px 0;
                margin-bottom: 16px;
            }

            .landing-nav-logo img {
                height: 36px;
            }

            .landing-nav-logo span {
                font-size: 22px;
            }

            .btn-nav {
                padding: 10px 14px;
                font-size: 12px;
            }

            /* Hero section mobile */
            .landing-hero {
                padding: 32px 24px 32px;
                border-radius: 16px;
                margin-bottom: 24px;
            }

            .hero-main {
                gap: 20px;
            }

            .hero-logo img {
                height: 280px;
            }

            .hero-title {
                font-size: 28px;
            }

            .hero-title-highlight {
                font-size: 32px;
            }

            .hero-tagline {
                font-size: 16px;
                margin-bottom: 24px;
            }

            .hero-features-list {
                flex-direction: column;
                gap: 12px;
            }

            .hero-feature-item {
                font-size: 13px;
            }

            .hero-cta-row {
                margin-top: 32px;
                gap: 12px;
            }

            .btn-large,
            .btn-secondary-large {
                width: 100%;
                min-width: unset;
                padding: 14px 32px;
                font-size: 14px;
            }

            .social-proof {
                gap: 24px;
                margin-top: 32px;
                padding-top: 24px;
            }

            .social-proof-item {
                font-size: 11px;
            }

            .social-proof-number {
                font-size: 20px;
            }

            .social-proof-icon {
                font-size: 24px;
            }

            .hero-shape {
                display: none;
            }

            /* Feature highlights mobile */
            .feature-highlights {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .feature-highlight-card {
                padding: 20px 16px;
            }

            .feature-highlight-icon {
                width: 56px;
                height: 56px;
                font-size: 28px;
                margin-bottom: 12px;
            }

            .feature-highlight-title {
                font-size: 16px;
            }

            .feature-highlight-desc {
                font-size: 13px;
            }

            /* Body and container adjustments */
            body {
                padding: 16px;
            }

            .container {
                max-width: 100%;
            }
            
            /* Header adjustments */
            header {
                padding: 20px 16px;
                flex-wrap: wrap;
                justify-content: space-between;
                margin-bottom: 16px;
            }
            
            .logo {
                gap: 8px;
            }
            
            .logo img {
                height: 40px;
            }
            
            .logo span {
                font-size: 24px;
            }
            
            header .auth-section {
                position: static;
                right: auto;
                margin-top: 12px;
                width: 100%;
                justify-content: center;
                order: 2;
            }
            
            header {
                flex-direction: column;
            }
            
            header .logo {
                order: 1;
            }
            
            /* Dark mode toggle on mobile */
            .dark-mode-toggle {
                position: static;
                transform: none;
                margin-bottom: 12px;
                order: 0;
            }
            
            /* Main content - stack vertically on mobile */
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .sidebar {
                position: static;
                max-height: none;
                order: 2;
                padding: 20px;
            }
            
            .content-column {
                order: 1;
            }
            
            /* Category picker - make buttons more touch-friendly */
            .category-picker {
                padding: 4px;
                margin-bottom: 24px;
            }
            
            .category-picker button {
                padding: 14px 12px;
                font-size: 14px;
            }
            
            /* View toggle buttons */
            .view-toggle {
                flex-wrap: wrap;
                gap: 10px;
                margin-bottom: 20px;
            }
            
            .view-toggle button {
                flex: 1;
                min-width: 120px;
                padding: 12px 16px;
                font-size: 14px;
            }
            
            /* Passage sections */
            .passages-section {
                padding: 24px 20px;
                margin-bottom: 24px;
            }
            
            .passages-section h2 {
                font-size: 26px;
                margin-bottom: 20px;
            }
            
            /* Ensure subheaders (h3) are smaller than main headers (h2) on mobile */
            .passages-section h3,
            #readingLessonsListSection h3,
            #writingLessonsListSection h3,
            #mathLessonsListSection h3 {
                font-size: 20px !important;
            }
            
            /* Passage cards */
            .passage-card {
                padding: 20px;
                margin-bottom: 16px;
            }
            
            .passage-card h3 {
                font-size: 18px;
            }
            
            .passage-card p {
                font-size: 14px;
            }
            
            /* Question cards */
            .question-card {
                padding: 20px;
                margin-bottom: 20px;
            }
            
            .question-card h4 {
                font-size: 16px;
                margin-bottom: 16px;
            }
            
            .option {
                padding: 16px;
                margin-bottom: 12px;
                font-size: 14px;
            }
            
            /* Passage detail section */
            .passage-detail-section {
                padding: 16px;
                max-width: 100%;
                box-sizing: border-box;
            }
            
            /* Back button container - ensure it has proper spacing */
            .passage-detail-section > div:first-child {
                flex-wrap: wrap;
                gap: 12px;
                margin-bottom: 24px;
                padding-left: 0;
                padding-right: 0;
                margin-left: 0;
                margin-right: 0;
            }
            
            .passage-detail-section button {
                padding: 12px 16px;
                font-size: 14px;
            }
            
            /* Passage content container - ensure proper padding */
            #passageContent {
                padding-left: 0;
                padding-right: 0;
            }
            
            /* Passage content header/title - ensure it respects container padding */
            .passage-detail-section h2,
            .passage-detail-section h1,
            #passageContent h2,
            #passageContent h1 {
                padding-left: 0;
                padding-right: 0;
                margin-left: 0;
                margin-right: 0;
            }
            
            /* Questions container */
            #questionsContainer {
                padding-left: 0;
                padding-right: 0;
            }
            
            /* Submit section */
            #submitSection {
                padding-left: 0;
                padding-right: 0;
            }
            
            /* Remove horizontal padding on mobile for maximum content width */
            .passage-reading-container {
                padding-inline: 0 !important;
            }
            
            .passage-detail-section {
                padding-left: 0 !important;
                padding-right: 0 !important;
            }
            
            .passage-content h2 {
                font-size: 20px;
            }
            
            /* Lesson content container - add horizontal padding */
            .lesson-content {
                padding-left: 12px;
                padding-right: 12px;
            }
            
            /* Add more padding to example boxes and highlighted text containers on mobile */
            /* Override padding for boxes with background colors */
            .lesson-content div[style*="background: #f0f8ff"],
            .lesson-content div[style*="background:#f0f8ff"],
            .lesson-content div[style*="background: rgba(52, 152, 219, 0.15)"],
            .lesson-content div[style*="background: #f0fff0"],
            .lesson-content div[style*="background:#f0fff0"],
            .lesson-content div[style*="background: #fff0f0"],
            .lesson-content div[style*="background:#fff0f0"],
            .lesson-content div[style*="background: #fff9e6"],
            .lesson-content div[style*="background:#fff9e6"],
            .lesson-content div[style*="background: #e3f2fd"],
            .lesson-content div[style*="background:#e3f2fd"] {
                padding-left: 20px !important;
                padding-right: 20px !important;
            }
            
            /* Explanation boxes - ensure good padding */
            .explanation {
                padding-left: 20px !important;
                padding-right: 20px !important;
            }
            
            /* Boxes with left border (example boxes) - increase padding */
            .lesson-content div[style*="border-left: 4px solid"],
            .lesson-content div[style*="border-left: 3px solid"] {
                padding-left: 20px !important;
                padding-right: 20px !important;
            }
            
            /* All divs with padding in lesson content - ensure minimum horizontal padding */
            .lesson-content div[style*="padding: 10px"],
            .lesson-content div[style*="padding: 12px"],
            .lesson-content div[style*="padding: 15px"] {
                padding-left: 20px !important;
                padding-right: 20px !important;
            }
            
            /* Paragraphs and text blocks in lesson content */
            .lesson-content p {
                padding-left: 4px;
                padding-right: 4px;
            }
            
            /* Line numbers and text */
            .line-number {
                font-size: 10px;
                min-width: 20px;
                margin-right: 6px;
            }
            
            .line-text {
                font-size: 14px;
            }
            
            /* Buttons - make more touch-friendly */
            .btn {
                padding: 12px 20px;
                font-size: 15px;
                min-height: 44px; /* iOS touch target minimum */
            }
            
            .btn-primary,
            .btn-secondary,
            .btn-success {
                min-height: 44px;
            }
            
            /* Submit section */
            #submitSection {
                margin-top: 20px;
            }
            
            #submitSection button {
                width: 100%;
                padding: 14px;
                font-size: 16px;
            }
            
            /* Word of day */
            .word-of-day {
                padding: 20px;
            }
            
            .word-of-day h3 {
                font-size: 18px;
                margin-bottom: 16px;
            }
            
            /* Question explanation */
            #questionExplanation {
                padding: 20px !important;
                margin-bottom: 24px !important;
            }
            
            #questionExplanation h3 {
                margin-bottom: 16px !important;
            }
            
            /* Landing page adjustments - smaller screens */
            .landing-page {
                padding: 0 12px;
            }

            .landing-nav {
                padding: 10px 0;
            }

            .landing-nav-logo img {
                height: 32px;
            }

            .landing-nav-logo span {
                font-size: 18px;
            }

            .btn-nav {
                padding: 8px 12px;
                font-size: 11px;
            }

            .landing-hero {
                padding: 24px 16px 24px;
                border-radius: 12px;
            }

            .hero-logo img {
                height: 220px;
            }

            .hero-title {
                font-size: 24px;
            }

            .hero-title-highlight {
                font-size: 26px;
            }

            .hero-tagline {
                font-size: 14px;
            }

            .hero-feature-item {
                font-size: 12px;
            }

            .btn-large,
            .btn-secondary-large {
                padding: 12px 24px;
                font-size: 13px;
            }

            .social-proof {
                gap: 16px;
            }

            .social-proof-number {
                font-size: 18px;
            }

            .social-proof-icon {
                font-size: 20px;
            }

            .social-proof-item {
                font-size: 10px;
            }

            .preview-cards {
                grid-template-columns: 1fr;
            }

            .landing-features {
                grid-template-columns: 1fr;
            }

            .preview-section h3 {
                font-size: 24px;
            }
            
            /* Side-by-side content - stack on mobile */
            .side-by-side-content,
            div[style*="flex-direction: row"] {
                flex-direction: column !important;
                gap: 15px !important;
            }
            
            .side-by-side-content > div,
            div[style*="flex-direction: row"] > div {
                width: 100% !important;
                flex: 1 1 100% !important;
                min-width: 0 !important;
                max-width: 100% !important;
            }
            
            /* Override inline min-width that might cause horizontal scroll */
            div[style*="min-width: 250px"] {
                min-width: 0 !important;
            }
            
            /* User info section */
            #userInfo {
                padding: 20px;
            }
            
            #userInfo h3 {
                font-size: 18px;
                margin-bottom: 16px;
            }
            
            /* Results section */
            #resultsSection {
                padding: 20px;
            }
            
            /* Ensure images don't overflow */
            img {
                max-width: 100%;
                height: auto;
            }
            
            /* Fix any inline styles that might cause issues */
            .passage-content img,
            .question-card img {
                max-width: 100%;
                height: auto;
            }
            
            /* Modal adjustments */
            .modal-content {
                padding: 20px 16px;
                width: 95%;
                max-height: 95vh;
            }
            
            .modal-content h2 {
                font-size: 20px;
                margin-bottom: 16px;
            }
            
            .form-group {
                margin-bottom: 12px;
            }
            
            .form-group input,
            .form-group textarea {
                font-size: 16px; /* Prevents zoom on iOS */
                padding: 12px;
            }
        }
        
        /* Extra small devices */
        @media (max-width: 480px) {
            body {
                padding: 12px;
            }
            
            header {
                padding: 16px 12px;
            }
            
            .passages-section {
                padding: 20px 16px;
            }
            
            .passage-card {
                padding: 16px;
            }
            
            .question-card {
                padding: 16px;
            }
            
            .passage-detail-section {
                padding: 12px !important;
            }
            
            /* clamp() handles all responsive sizing automatically - no overrides needed */
            
            .logo span {
                font-size: 20px;
            }
            
            .logo img {
                height: 32px;
            }
            
            .category-picker button {
                padding: 12px 8px;
                font-size: 12px;
            }
            
            .passages-section {
                padding: 16px 12px;
            }
            
            .passages-section h2 {
                font-size: 20px;
            }
            
            .hero-title {
                font-size: 32px;
            }
            
            .hero-tagline {
                font-size: 16px;
            }
        }
        
        /* clamp() handles all device sizes automatically - no device-specific hacks needed */
        
        .passages-view {
            display: none;
        }
        
        .view-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .view-toggle button {
            padding: 8px 16px;
            font-size: 14px;
        }
        
        .view-toggle button.active {
            background: #3498DB;
            color: white;
        }

        /* Penguin Coach Speech Bubble Styles */
        .penguin-coach-container {
            position: fixed;
            bottom: 24px;
            right: 24px;
            z-index: 1000;
            max-width: 360px;
            width: calc(100% - 48px);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }

        .penguin-coach-container.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .penguin-coach-bubble {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-color);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(52, 152, 219, 0.2);
            position: relative;
        }

        .penguin-coach-header {
            display: flex;
            align-items: flex-start;
            gap: 16px;
            margin-bottom: 16px;
        }

        .penguin-coach-avatar {
            width: 56px;
            height: 56px;
            flex-shrink: 0;
        }

        .penguin-coach-avatar img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .penguin-coach-message {
            flex: 1;
        }

        .penguin-coach-message-primary {
            color: var(--text-primary);
            font-size: 16px;
            font-weight: 600;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .penguin-coach-message-secondary {
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.4;
        }

        .penguin-coach-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .penguin-coach-action-btn {
            flex: 1;
            padding: 12px 20px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s ease;
        }

        .penguin-coach-action-btn:hover {
            background: var(--accent-hover);
            transform: scale(1.02);
        }

        .penguin-coach-action-btn:active {
            transform: scale(0.98);
        }

        .penguin-coach-dismiss-btn {
            width: 32px;
            height: 32px;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 50%;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease, color 0.2s ease;
            flex-shrink: 0;
        }

        .penguin-coach-dismiss-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Mobile adjustments for penguin coach */
        @media (max-width: 480px) {
            .penguin-coach-container {
                bottom: 16px;
                right: 16px;
                left: 16px;
                max-width: none;
                width: auto;
            }

            .penguin-coach-bubble {
                padding: 16px;
            }

            .penguin-coach-avatar {
                width: 48px;
                height: 48px;
            }

            .penguin-coach-message-primary {
                font-size: 15px;
            }

            .penguin-coach-message-secondary {
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <button class="dark-mode-toggle" onclick="toggleDarkMode()" aria-label="Toggle dark mode" title="Toggle dark mode">
                <div class="dark-mode-toggle-slider">
                    <span class="dark-mode-toggle-icon sun"></span>
                    <span class="dark-mode-toggle-icon moon"></span>
                </div>
            </button>
            <a href="#" class="logo" onclick="showLanding(); return false;">
                <span>Keuvi</span>
            </a>
            <div class="auth-section" id="authSection">
                <button class="btn btn-primary" onclick="showLoginModal()">Login</button>
                <button class="btn btn-secondary" onclick="showRegisterModal()">Register</button>
            </div>
        </header>
        
        <!-- Landing Page -->
        <div class="landing-page" id="landingPage">
            <!-- Duolingo-style Navigation -->
            <nav class="landing-nav">
                <a href="#" class="landing-nav-logo" onclick="showLanding(); return false;">
                    <span>Keuvi</span>
                </a>
                <div class="landing-nav-buttons">
                    <button class="landing-dark-toggle" onclick="toggleDarkMode()" aria-label="Toggle dark mode">
                        <span class="sun-icon">&#9728;</span>
                        <span class="moon-icon">&#9790;</span>
                    </button>
                    <button id="landingLoginBtn" class="btn-nav btn-nav-ghost" onclick="showLoginModal()">Log In</button>
                    <button id="landingCtaBtn" class="btn-nav btn-nav-primary" onclick="showPassages()">Get Started</button>
                </div>
            </nav>

            <div class="landing-hero">
                <!-- Floating decorative shapes -->
                <div class="hero-shapes">
                    <div class="hero-shape hero-shape-1"></div>
                    <div class="hero-shape hero-shape-2"></div>
                    <div class="hero-shape hero-shape-3"></div>
                    <div class="hero-shape hero-shape-4"></div>
                </div>

                <div class="hero-content">
                    <div class="hero-main">
                        <div class="hero-logo">
                            <img src="{% static 'web/images/keuvi_penguin_cropped.png' %}" alt="Keuvi Penguin - Your SAT Study Buddy">
                        </div>
                        <div class="hero-text">
                            <h1 class="hero-title">An SAT Tutor in Your Pocket</h1>
                            <div class="hero-features">
                                <div class="hero-features-list">
                                    <div class="hero-feature-item">
                                        <span class="hero-feature-icon">&#10003;</span>
                                        <span>Free to start</span>
                                    </div>
                                    <div class="hero-feature-item">
                                        <span class="hero-feature-icon">&#10003;</span>
                                        <span>Fun & Engaging</span>
                                    </div>
                                    <div class="hero-feature-item">
                                        <span class="hero-feature-icon">&#10003;</span>
                                        <span>All written by real people</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="hero-cta-row">
                        <button class="btn-large" onclick="showPassages()">Get Started</button>
                        <button class="btn-secondary-large" onclick="showLoginModal()">I Already Have An Account</button>
                    </div>

                    <div class="social-proof">
                        <div class="social-proof-item">
                            <span class="social-proof-icon">&#128218;</span>
                            <span class="social-proof-number">100+</span>
                            <span>lessons</span>
                        </div>
                        <div class="social-proof-item">
                            <span class="social-proof-icon">&#9989;</span>
                            <span class="social-proof-number">500+</span>
                            <span>questions</span>
                        </div>
                        <div class="social-proof-item">
                            <span class="social-proof-icon">&#128293;</span>
                            <span class="social-proof-number">Weekly</span>
                            <span>updates</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Feature Highlights Section -->
            <div class="feature-highlights">
                <div class="feature-highlight-card" onclick="switchCategory('reading'); showPassages();">
                    <div class="feature-highlight-icon">&#128214;</div>
                    <h3 class="feature-highlight-title">Reading</h3>
                    <p class="feature-highlight-desc">Master comprehension with engaging passages and strategies</p>
                </div>
                <div class="feature-highlight-card" onclick="switchCategory('writing'); showPassages();">
                    <div class="feature-highlight-icon">&#9998;</div>
                    <h3 class="feature-highlight-title">Writing</h3>
                    <p class="feature-highlight-desc">Perfect your grammar and expression skills</p>
                </div>
                <div class="feature-highlight-card" onclick="switchCategory('math'); showPassages();">
                    <div class="feature-highlight-icon">&#128290;</div>
                    <h3 class="feature-highlight-title">Math</h3>
                    <p class="feature-highlight-desc">Build confidence from algebra to advanced concepts</p>
                </div>
            </div>

            <!-- Premium Section - Duolingo Super style -->
            <div class="premium-promo-section">
                <div class="premium-promo-content">
                    <div class="premium-promo-badge">KEUVI PREMIUM</div>
                    <h3 class="premium-promo-title">Unlock Your Full Potential</h3>
                    <p class="premium-promo-desc">
                        Double the practice questions, exclusive content drops every week, and zero ads.
                    </p>
                    <div class="premium-promo-price">
                        <span class="premium-price-amount">$5</span>
                        <span class="premium-price-period">/month</span>
                    </div>
                    <button class="btn-premium" onclick="upgradeToPremium()">Try Premium Free</button>
                </div>
            </div>
        </div>
        
        <!-- Passages View -->
        <div class="passages-view" id="passagesView">
            <div class="view-toggle">
                <button class="btn btn-secondary active" onclick="showPassages()">Passages</button>
                <button class="btn btn-secondary" onclick="showLanding()">Home</button>
            </div>
            
            <div class="main-content">
                <div class="content-column">
                    <!-- Category Picker -->
                    <div class="category-picker">
                        <button class="active" onclick="switchCategory('reading')" id="category-reading-btn">Reading</button>
                        <button onclick="switchCategory('writing')" id="category-writing-btn">Writing</button>
                        <button onclick="switchCategory('math')" id="category-math-btn">Math</button>
                    </div>
                    
                    <!-- Reading Category Content -->
                    <div class="category-content active" id="category-reading">
                        <!-- View Mode Toggle -->
                        <div class="view-mode-toggle" id="readingViewToggle">
                            <button class="active" onclick="setViewMode('reading', 'grid')" id="reading-grid-btn"> Skills</button>
                            <button onclick="setViewMode('reading', 'list')" id="reading-list-btn"> List</button>
                        </div>

                        <!-- Reading Grid View (Duolingo-style) -->
                        <div class="passages-section" id="readingGridSection">
                            <h2>Reading Skills</h2>
                            <div class="skills-grid" id="readingSkillsGrid"></div>
                        </div>

                        <!-- Reading Lessons List View (hidden by default) -->
                        <div class="passages-section" id="readingLessonsListSection" style="margin-bottom: 40px; display: none;">
                            <h2>Reading Lessons</h2>
                            <div id="readingLessonsList"></div>
                        </div>

                        <!-- Reading Passages List View (hidden by default) -->
                        <div class="passages-section" id="passagesListSection" style="display: none;">
                            <h2>Reading Passages</h2>
                            <div id="passagesList"></div>
                        </div>
                    </div>
                    
                    <!-- Writing Category Content -->
                    <div class="category-content" id="category-writing">
                        <!-- View Mode Toggle -->
                        <div class="view-mode-toggle" id="writingViewToggle">
                            <button class="active" onclick="setViewMode('writing', 'grid')" id="writing-grid-btn"> Skills</button>
                            <button onclick="setViewMode('writing', 'list')" id="writing-list-btn"> List</button>
                        </div>

                        <!-- Writing Grid View (Duolingo-style) -->
                        <div class="passages-section" id="writingGridSection">
                            <h2>Writing Skills</h2>
                            <div class="skills-grid" id="writingSkillsGrid"></div>
                        </div>

                        <!-- Writing Lessons List View (hidden by default) -->
                        <div class="passages-section" id="writingLessonsListSection" style="margin-bottom: 40px; display: none;">
                            <h2>Writing Lessons</h2>
                            <div id="writingLessonsList"></div>
                        </div>

                        <!-- Writing Sections List View - COMMENTED OUT: Writing sections removed, only showing lessons -->
                        <!--
                        <div class="passages-section" id="writingSectionsListSection">
                            <h2>Writing Sections</h2>
                            <div id="writingSectionsList"></div>
                        </div>
                        -->
                    </div>
                    
                    <!-- Math Category Content -->
                    <div class="category-content" id="category-math">
                        <!-- View Mode Toggle -->
                        <div class="view-mode-toggle" id="mathViewToggle">
                            <button class="active" onclick="setViewMode('math', 'grid')" id="math-grid-btn"> Skills</button>
                            <button onclick="setViewMode('math', 'list')" id="math-list-btn"> List</button>
                        </div>

                        <!-- Math Grid View (Duolingo-style) -->
                        <div class="passages-section" id="mathGridSection">
                            <h2>Math Skills</h2>
                            <div class="skills-grid" id="mathSkillsGrid"></div>
                        </div>

                        <!-- Math Lessons List View (hidden by default) -->
                        <div class="passages-section" id="mathLessonsListSection" style="margin-bottom: 40px; display: none;">
                            <h2>Math Lessons</h2>
                            <div id="mathLessonsList"></div>
                        </div>

                        <!-- Math Sections List View - COMMENTED OUT: Math sections removed, only showing lessons -->
                        <!--
                        <div class="passages-section" id="mathSectionsListSection">
                            <h2>Math Sections</h2>
                            <div id="mathSectionsList"></div>
                        </div>
                        -->
                    </div>
                    
                    <!-- Passage/Lesson Detail View -->
                    <div class="passage-detail-section" id="passageDetailSection" style="display: none;">
                        <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center;">
                            <button class="btn btn-secondary" onclick="backToPassagesList()"> Back</button>
                            <span id="attemptHistoryButtonContainer"></span>
                        </div>
                        <div id="passageContent"></div>
                        <div id="questionsContainer"></div>
                        <div id="submitSection" style="margin-top: 30px;">
                            <button class="btn btn-primary" onclick="submitAnswers()" id="submitBtn">Submit Answers</button>
                        </div>
                        <div id="resultsSection" style="display: none; margin-top: 30px;"></div>
                    </div>
                </div>
                
                <div class="sidebar">
                    <!-- Gamification Stats -->
                    <div class="gamification-stats" id="gamificationStats">
                        <div class="stat-row">
                            <div class="stat-icon"></div>
                            <div class="stat-info">
                                <div class="stat-label">Day Streak</div>
                                <div class="stat-value" id="streakCount">0</div>
                                <div class="streak-flames" id="streakFlames">
                                    <span class="streak-flame"></span>
                                    <span class="streak-flame"></span>
                                    <span class="streak-flame"></span>
                                    <span class="streak-flame"></span>
                                    <span class="streak-flame"></span>
                                    <span class="streak-flame"></span>
                                    <span class="streak-flame"></span>
                                </div>
                            </div>
                        </div>
                        <div class="stat-row">
                            <div class="stat-icon"></div>
                            <div class="stat-info">
                                <div class="stat-label">Total XP</div>
                                <div class="stat-value" id="totalXP">0</div>
                            </div>
                        </div>
                        <div class="stat-row">
                            <div class="stat-icon"></div>
                            <div class="stat-info">
                                <div class="stat-label">Completed</div>
                                <div class="stat-value" id="completedCount">0</div>
                            </div>
                        </div>
                    </div>

                    <div class="word-of-day" id="wordOfDay">
                        <h3>Word of the Day</h3>
                        <div class="loading">Loading...</div>
                    </div>
                    
                    <div id="questionExplanation" class="hidden" style="display: none; background: var(--bg-secondary); border-radius: 8px; padding: 12px 16px; margin-bottom: 20px; box-shadow: 0 2px 4px var(--shadow); border-left: 3px solid var(--accent-color);">
                        <h3 style="color: var(--accent-color); margin-bottom: 8px; font-size: 16px; margin-left: 0;">Explanation</h3>
                        <div id="questionExplanationContent" style="color: var(--text-primary); line-height: 1.6;">
                            <!-- Explanation will be inserted here -->
                        </div>
                    </div>
                    
                    <div id="userInfo" class="hidden">
                        <div class="user-info">
                            <strong>Logged in as:</strong><br>
                            <span id="userEmail"></span>
                        </div>
                        <div class="subscription-info" id="subscriptionInfo">
                            <strong>Subscription:</strong><br>
                            <span id="subscriptionStatus">Free</span><br>
                            <button class="btn btn-success" id="subscriptionButton" onclick="upgradeToPremium()" style="margin-top: 10px; width: 100%;">
                                Upgrade to Premium ($5/month)
                            </button>
                            <button class="btn btn-secondary" onclick="refreshUserData()" style="margin-top: 5px; width: 100%; font-size: 12px; padding: 6px;">
                                 Refresh Status
                            </button>
                            <!-- Promo Code Section -->
                            <div id="promoCodeSection" style="margin-top: 10px;">
                                <a href="#" id="promoCodeLink" onclick="togglePromoCodeInput(event)" style="color: var(--accent-color); font-size: 12px; text-decoration: none;">Have a promo code?</a>
                                <div id="promoCodeInputSection" style="display: none; margin-top: 8px;">
                                    <input type="text" id="promoCodeInput" placeholder="Enter code" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 14px; background: var(--bg-primary); color: var(--text-primary); box-sizing: border-box;">
                                    <button class="btn btn-primary" onclick="redeemPromoCode()" id="redeemPromoBtn" style="margin-top: 5px; width: 100%; font-size: 12px; padding: 8px;">
                                        Redeem
                                    </button>
                                    <div id="promoCodeMessage" style="margin-top: 5px; font-size: 12px; display: none;"></div>
                                </div>
                            </div>
                        </div>
                        <button class="btn btn-primary" onclick="showProfile()" style="margin-top: 15px; width: 100%;">
                            My Profile
                        </button>
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
                            <strong style="color: var(--text-secondary); font-size: 12px;">Support:</strong><br>
                            <a href="/support/" style="color: var(--accent-color); font-size: 12px; text-decoration: none;">Support</a>
                            <span style="margin: 0 4px;"></span>
                            <a href="/terms/" style="color: var(--accent-color); font-size: 12px; text-decoration: none;">Terms</a>
                            <span style="margin: 0 4px;"></span>
                            <a href="/privacy/" style="color: var(--accent-color); font-size: 12px; text-decoration: none;">Privacy</a>
                            <br>
                            <a href="mailto:admin@argosventures.pro" style="color: var(--accent-color); font-size: 12px; text-decoration: none;">admin@argosventures.pro</a>
                        </div>
                        <button class="btn btn-secondary" onclick="logout()" style="margin-top: 10px; width: 100%;">
                            Logout
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Profile View -->
    <div class="profile-view" id="profileView" style="display: none;">
        <div class="container">
            <div class="view-toggle">
                <button class="btn btn-secondary" onclick="showPassages()"> Back to Passages</button>
            </div>
            
            <div class="profile-content" style="margin-top: 30px;">
                <h1 style="color: var(--text-primary); margin-bottom: 24px; font-size: 24px; font-weight: 600;">My Profile</h1>
                
                <div id="profileLoading" style="text-align: center; padding: 40px;">
                    <p style="color: var(--text-secondary);">Loading your profile...</p>
                </div>
                
                <div id="profileData" style="display: none;">
                    <!-- User Info -->
                    <div class="profile-section" style="background: var(--bg-secondary); border-radius: 8px; padding: 24px; margin-bottom: 20px;">
                        <h2 style="color: var(--text-primary); margin-bottom: 12px; font-size: 18px; font-weight: 600;">Account</h2>
                        <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 6px;"><span id="profileEmail"></span></p>
                        <p style="color: var(--text-secondary); font-size: 14px;"><span id="profileStatus"></span></p>
                    </div>
                    
                    <!-- Study Plan Section -->
                    <div class="profile-section" style="background: var(--bg-secondary); border-radius: 8px; padding: 24px; margin-bottom: 20px;">
                        <h2 style="color: var(--text-primary); margin-bottom: 20px; font-size: 18px; font-weight: 600;">Diagnostic Progress</h2>
                        
                        <!-- Diagnostic Status Cards -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 20px;">
                            <!-- Reading Diagnostic -->
                            <div id="readingDiagnosticCard" class="diagnostic-card" style="background: var(--bg-primary); border-radius: 6px; padding: 16px; border: 1px solid var(--border-color);">
                                <h3 style="color: var(--text-primary); margin-bottom: 8px; font-size: 14px; font-weight: 600;">Reading</h3>
                                <div id="readingDiagnosticStatus"></div>
                            </div>
                            
                            <!-- Writing Diagnostic -->
                            <div id="writingDiagnosticCard" class="diagnostic-card" style="background: var(--bg-primary); border-radius: 6px; padding: 16px; border: 1px solid var(--border-color);">
                                <h3 style="color: var(--text-primary); margin-bottom: 8px; font-size: 14px; font-weight: 600;">Writing</h3>
                                <div id="writingDiagnosticStatus"></div>
                            </div>
                            
                            <!-- Math Diagnostic -->
                            <div id="mathDiagnosticCard" class="diagnostic-card" style="background: var(--bg-primary); border-radius: 6px; padding: 16px; border: 1px solid var(--border-color);">
                                <h3 style="color: var(--text-primary); margin-bottom: 8px; font-size: 14px; font-weight: 600;">Math</h3>
                                <div id="mathDiagnosticStatus"></div>
                            </div>
                        </div>
                        
                        <!-- Recommended Lessons -->
                        <div id="recommendedLessons" style="display: none;">
                            <h3 style="color: var(--text-primary); margin-bottom: 12px; font-size: 14px; font-weight: 600;">Recommended</h3>
                            <div id="recommendedLessonsList" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
                        </div>
                    </div>
                    
                    <!-- Strengths -->
                    <div class="profile-section" style="background: var(--bg-secondary); border-radius: 8px; padding: 24px; margin-bottom: 20px;">
                        <h2 style="color: var(--text-primary); margin-bottom: 16px; font-size: 18px; font-weight: 600;">Strengths</h2>
                        <div id="strengthsList">
                            <p style="color: var(--text-secondary); font-size: 14px;">Complete a diagnostic to see your strengths.</p>
                        </div>
                    </div>
                    
                    <!-- Weaknesses -->
                    <div class="profile-section" style="background: var(--bg-secondary); border-radius: 8px; padding: 24px; margin-bottom: 20px;">
                        <h2 style="color: var(--text-primary); margin-bottom: 16px; font-size: 18px; font-weight: 600;">Areas to Improve</h2>
                        <div id="weaknessesList">
                            <p style="color: var(--text-secondary); font-size: 14px;">Complete a diagnostic to see areas for improvement.</p>
                        </div>
                    </div>
                    
                    <!-- All Performance -->
                    <div class="profile-section" style="background: var(--bg-secondary); border-radius: 8px; padding: 24px;">
                        <h2 style="color: var(--text-primary); margin-bottom: 16px; font-size: 18px; font-weight: 600;">Performance Summary</h2>
                        <div id="performanceList">
                            <p style="color: var(--text-secondary); font-size: 14px;">No performance data yet.</p>
                        </div>
                    </div>
                </div>
                
                <div id="profileEmpty" style="display: none; text-align: center; padding: 40px;">
                    <p style="color: var(--text-secondary); font-size: 18px;">No performance data yet.</p>
                    <p style="color: var(--text-secondary);">Complete some passages and lessons to see your strengths and weaknesses!</p>
                    <button class="btn btn-primary" onclick="showPassages()" style="margin-top: 20px;">Start Practicing</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Login Modal -->
    <div id="loginModal" class="modal">
        <div class="modal-content">
            <h2>Login</h2>
            <form id="loginForm" onsubmit="handleLogin(event)">
                <div class="form-group">
                    <label>Email</label>
                    <input type="email" name="email" required>
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" name="password" required>
                </div>
                <div id="loginError" class="error"></div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">Login</button>
                <div style="text-align: center; margin: 15px 0; color: #666;">or</div>
                <button type="button" class="btn" onclick="handleGoogleLogin()" style="width: 100%; background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color); display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <svg width="18" height="18" viewBox="0 0 18 18">
                        <path fill="#4285F4" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z"/>
                        <path fill="#34A853" d="M9 18c2.43 0 4.467-.806 5.956-2.184l-2.908-2.258c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z"/>
                        <path fill="#FBBC05" d="M3.964 10.712c-.18-.54-.282-1.117-.282-1.712s.102-1.172.282-1.712V4.956H.957C.347 6.175 0 7.55 0 9s.348 2.825.957 4.044l3.007-2.332z"/>
                        <path fill="#EA4335" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.956L3.964 7.288C4.672 5.163 6.656 3.58 9 3.58z"/>
                    </svg>
                    Sign in with Google
                </button>
                <button type="button" class="btn btn-secondary" onclick="closeModal('loginModal')" style="width: 100%; margin-top: 10px;">Cancel</button>
            </form>
        </div>
    </div>
    
    <!-- Register Modal -->
    <div id="registerModal" class="modal">
        <div class="modal-content">
            <h2>Register</h2>
            <form id="registerForm" onsubmit="handleRegister(event)">
                <div class="form-group">
                    <label>Email</label>
                    <input type="email" name="email" required>
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" name="password" required minlength="8">
                </div>
                <div id="registerError" class="error"></div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">Register</button>
                <div style="text-align: center; margin: 15px 0; color: #666;">or</div>
                <button type="button" class="btn" onclick="handleGoogleLogin()" style="width: 100%; background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color); display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <svg width="18" height="18" viewBox="0 0 18 18">
                        <path fill="#4285F4" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z"/>
                        <path fill="#34A853" d="M9 18c2.43 0 4.467-.806 5.956-2.184l-2.908-2.258c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z"/>
                        <path fill="#FBBC05" d="M3.964 10.712c-.18-.54-.282-1.117-.282-1.712s.102-1.172.282-1.712V4.956H.957C.347 6.175 0 7.55 0 9s.348 2.825.957 4.044l3.007-2.332z"/>
                        <path fill="#EA4335" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.956L3.964 7.288C4.672 5.163 6.656 3.58 9 3.58z"/>
                    </svg>
                    Sign in with Google
                </button>
                <button type="button" class="btn btn-secondary" onclick="closeModal('registerModal')" style="width: 100%; margin-top: 10px;">Cancel</button>
            </form>
        </div>
    </div>
    
    <script>
        // Dark Mode Toggle Functionality
        function initDarkMode() {
            const darkMode = localStorage.getItem('darkMode') === 'true';
            if (darkMode) {
                document.body.classList.add('dark-mode');
            }
        }
        
        function toggleDarkMode() {
            const isDark = document.body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', isDark);
            // Force update of all dynamically generated content
            updateDarkModeTextColors();
        }
        
        // Helper function to get current text color based on mode
        function getTextColor() {
            return document.body.classList.contains('dark-mode') ? '#ffffff' : '#000000';
        }
        
        function getTextSecondaryColor() {
            return document.body.classList.contains('dark-mode') ? '#b0b0b0' : '#666666';
        }
        
        // Function to get penguin message based on score
        function getPenguinMessage(score, totalQuestions, isPractice = false) {
            const percentage = Math.round((score / totalQuestions) * 100);
            
            // Perfect score for practice
            if (isPractice && score === totalQuestions && totalQuestions > 0) {
                const perfectMessages = [
                    "Perfectamundo!",
                    "Perfect! We'll have to find some harder questions next time."
                ];
                return perfectMessages[Math.floor(Math.random() * perfectMessages.length)];
            }
            
            // 70% or higher
            if (percentage >= 70) {
                const goodMessages = [
                    "Good stuff!",
                    "Nice, nice.",
                    "Very cool."
                ];
                return goodMessages[Math.floor(Math.random() * goodMessages.length)];
            }
            
            // Below 70%
            const encouragingMessages = [
                "The hardest work is the most important work",
                "The only way through it is through it.",
                "Getting there."
            ];
            return encouragingMessages[Math.floor(Math.random() * encouragingMessages.length)];
        }
        
        // Helper function to get background color for example boxes
        function getExampleBgColor(type) {
            const isDark = document.body.classList.contains('dark-mode');
            if (type === 'example') {
                return isDark ? 'rgba(52, 152, 219, 0.15)' : '#f0f8ff';
            } else if (type === 'correct') {
                return isDark ? 'rgba(40, 167, 69, 0.15)' : '#f0fff0';
            } else if (type === 'incorrect') {
                return isDark ? 'rgba(220, 53, 69, 0.15)' : '#fff0f0';
            } else if (type === 'rule') {
                return isDark ? 'rgba(255, 193, 7, 0.15)' : '#fff9e6';
            }
            return isDark ? 'var(--bg-secondary)' : '#f9f9f9';
        }
        
        // Update all inline styles with black text to use current mode
        function updateDarkModeTextColors() {
            const isDark = document.body.classList.contains('dark-mode');
            const textColor = isDark ? '#ffffff' : '#000000';
            const textSecondary = isDark ? '#b0b0b0' : '#666666';
            
            // Update all elements with inline color styles
            document.querySelectorAll('[style*="color: #000"], [style*="color:#000"], [style*="color: #333"], [style*="color:#333"]').forEach(el => {
                const style = el.getAttribute('style') || '';
                el.setAttribute('style', style.replace(/color:\s*#(000|333|222|666|555|000000|333333)/gi, `color: ${textColor}`));
            });
        }
        
        // Initialize dark mode on page load
        initDarkMode();
        
        const API_BASE = '/api/v1';
        let authToken = localStorage.getItem('authToken');
        let currentUser = null;
        
        // Intro lesson titles that are accessible without login (case-insensitive)
        const INTRO_LESSON_TITLES = ['intro', 'waves', 'guided tour'];
        
        // Check if a lesson is an intro lesson (accessible without login)
        // Must be exact match or start with the intro title (e.g., "The Waves" matches, but "Introductions..." doesn't match "intro")
        function isIntroLesson(lessonTitle) {
            if (!lessonTitle) return false;
            const titleLower = lessonTitle.toLowerCase().trim();
            
            // Check for specific intro lessons:
            // - "Intro" or starts with "Intro " (Math intro)
            // - Contains "Waves" as a word (Writing intro: "The Waves")
            // - Contains "Guided Tour" (Reading intro: "A Guided Tour")
            
            // Exact matches or word boundary matches
            if (titleLower === 'intro' || titleLower.startsWith('intro ') || titleLower.endsWith(' intro')) return true;
            if (titleLower.includes('waves')) return true;
            if (titleLower.includes('guided tour')) return true;
            
            return false;
        }
        
        // Show login required modal
        function showLoginRequiredModal() {
            // Create and show a modal prompting user to login
            const existingModal = document.getElementById('loginRequiredModal');
            if (existingModal) {
                existingModal.style.display = 'flex';
                return;
            }
            
            const modal = document.createElement('div');
            modal.id = 'loginRequiredModal';
            modal.className = 'modal';
            modal.style.cssText = 'display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 1000;';
            modal.innerHTML = `
                <div style="background: var(--bg-secondary); padding: 30px; border-radius: 12px; max-width: 400px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                    <h2 style="color: var(--accent-color); margin-bottom: 15px;">Login Required</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 25px; line-height: 1.6;">
                        Please log in or create an account to access this content. 
                        <br><br>
                        <em>Tip: Try our intro lessons first - they're free without login!</em>
                    </p>
                    <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                        <button onclick="document.getElementById('loginRequiredModal').style.display='none'; openModal('loginModal');" class="btn btn-primary" style="padding: 12px 24px;">
                            Login
                        </button>
                        <button onclick="document.getElementById('loginRequiredModal').style.display='none'; openModal('registerModal');" class="btn btn-success" style="padding: 12px 24px; background: #27ae60;">
                            Sign Up
                        </button>
                        <button onclick="document.getElementById('loginRequiredModal').style.display='none';" class="btn btn-secondary" style="padding: 12px 24px;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Close on click outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            });
        }
        
        // If we have a token on page load, check auth immediately
        if (authToken) {
            console.log('Found authToken in localStorage on page load');
        }

        // =====================================================
        // Penguin Coach Onboarding System
        // =====================================================
        let currentOnboardingData = null;

        /**
         * Fetch profile data and extract onboarding state
         * @returns {Promise<Object|null>} The onboarding data or null
         */
        async function fetchOnboardingData() {
            if (!authToken) {
                console.log('fetchOnboardingData: No auth token, skipping');
                return null;
            }

            try {
                const response = await fetch(`${API_BASE}/profile`, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                if (!response.ok) {
                    console.error('fetchOnboardingData: Failed to fetch profile');
                    return null;
                }

                const data = await response.json();
                currentOnboardingData = data.onboarding || null;
                console.log('fetchOnboardingData: Got onboarding data:', currentOnboardingData);
                return currentOnboardingData;
            } catch (error) {
                console.error('fetchOnboardingData: Error:', error);
                return null;
            }
        }

        /**
         * Show the penguin coach with current onboarding prompt
         */
        function showPenguinCoach() {
            if (!currentOnboardingData || !currentOnboardingData.prompt) {
                console.log('showPenguinCoach: No prompt to show');
                hidePenguinCoach();
                return;
            }

            const prompt = currentOnboardingData.prompt;
            const container = document.getElementById('penguinCoachContainer');
            const primaryMsg = document.getElementById('penguinCoachMessagePrimary');
            const secondaryMsg = document.getElementById('penguinCoachMessageSecondary');
            const actionBtn = document.getElementById('penguinCoachActionBtn');
            const dismissBtn = document.getElementById('penguinCoachDismissBtn');

            if (!container) {
                console.error('showPenguinCoach: Container not found');
                return;
            }

            // Set message content
            primaryMsg.textContent = prompt.message || '';
            secondaryMsg.textContent = prompt.secondary_message || '';
            secondaryMsg.style.display = prompt.secondary_message ? 'block' : 'none';

            // Set action button
            if (prompt.action) {
                actionBtn.textContent = prompt.action.label || 'Continue';
                actionBtn.style.display = 'block';
                actionBtn.onclick = () => handlePenguinCoachAction(prompt);
            } else {
                actionBtn.style.display = 'none';
            }

            // Set dismiss button visibility (welcome is not dismissible)
            dismissBtn.style.display = prompt.dismissible ? 'flex' : 'none';
            dismissBtn.onclick = () => handlePenguinCoachDismiss(prompt.id);

            // Show the container with animation
            container.classList.add('visible');
            console.log('showPenguinCoach: Displayed prompt:', prompt.id);
        }

        /**
         * Hide the penguin coach with animation
         */
        function hidePenguinCoach() {
            const container = document.getElementById('penguinCoachContainer');
            if (container) {
                container.classList.remove('visible');
            }
        }

        /**
         * Handle action button click on penguin coach
         * @param {Object} prompt - The current prompt object
         */
        async function handlePenguinCoachAction(prompt) {
            if (!prompt || !prompt.action) return;

            const actionType = prompt.action.type;
            const target = prompt.action.target;

            console.log('handlePenguinCoachAction:', actionType, target);

            // First, handle the state transition if needed
            if (prompt.id === 'welcome') {
                // Mark welcome as seen
                await markWelcomeSeen();
            }

            // Then handle the navigation/action
            switch (actionType) {
                case 'continue':
                    // For welcome, just refresh state and show next prompt
                    await refreshOnboardingAndShow();
                    break;

                case 'navigate':
                    hidePenguinCoach();
                    handleOnboardingNavigation(target);
                    break;

                default:
                    console.log('handlePenguinCoachAction: Unknown action type:', actionType);
            }
        }

        /**
         * Handle navigation targets from onboarding prompts
         * @param {string} target - The navigation target
         */
        function handleOnboardingNavigation(target) {
            console.log('handleOnboardingNavigation:', target);

            switch (target) {
                case 'profile_edit':
                    showProfile();
                    break;

                case 'diagnostic_selection':
                    // Navigate to passages view and show diagnostic options
                    showPassages();
                    // Small delay to ensure view is rendered
                    setTimeout(() => {
                        showDiagnosticSelectionPrompt();
                    }, 300);
                    break;

                case 'diagnostic_resume':
                    // Similar to diagnostic_selection - show where they can continue
                    showPassages();
                    break;

                case 'practice':
                    showPassages();
                    break;

                default:
                    console.log('handleOnboardingNavigation: Unknown target:', target);
                    showPassages();
            }
        }

        /**
         * Show a prompt to select which diagnostic to start
         */
        function showDiagnosticSelectionPrompt() {
            // Create a simple modal for diagnostic selection
            const existingModal = document.getElementById('diagnosticSelectionModal');
            if (existingModal) {
                existingModal.style.display = 'flex';
                return;
            }

            const modal = document.createElement('div');
            modal.id = 'diagnosticSelectionModal';
            modal.className = 'modal';
            modal.style.cssText = 'display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 1001;';
            modal.innerHTML = `
                <div style="background: var(--bg-secondary); padding: 30px; border-radius: 16px; max-width: 500px; width: calc(100% - 40px); box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
                    <div style="text-align: center; margin-bottom: 24px;">
                        <img src="{% static 'web/images/penguin.png' %}" alt="Penguin" style="width: 64px; height: auto; margin-bottom: 12px;">
                        <h2 style="color: var(--text-primary); margin: 0 0 8px 0; font-size: 20px;">Choose a Diagnostic</h2>
                        <p style="color: var(--text-secondary); margin: 0; font-size: 14px; line-height: 1.5;">
                            Each takes about 15 minutes. I'll use the results to build your personalized study plan.
                        </p>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <button onclick="startDiagnosticFromModal('reading')" class="btn" style="padding: 16px 20px; background: var(--bg-primary); border: 2px solid var(--border-color); border-radius: 12px; text-align: left; cursor: pointer; transition: border-color 0.2s;">
                            <strong style="color: var(--text-primary); display: block; margin-bottom: 4px;">Reading</strong>
                            <span style="color: var(--text-secondary); font-size: 13px;">Comprehension, vocabulary, and analysis</span>
                        </button>
                        <button onclick="startDiagnosticFromModal('writing')" class="btn" style="padding: 16px 20px; background: var(--bg-primary); border: 2px solid var(--border-color); border-radius: 12px; text-align: left; cursor: pointer; transition: border-color 0.2s;">
                            <strong style="color: var(--text-primary); display: block; margin-bottom: 4px;">Writing</strong>
                            <span style="color: var(--text-secondary); font-size: 13px;">Grammar, style, and expression</span>
                        </button>
                        <button onclick="startDiagnosticFromModal('math')" class="btn" style="padding: 16px 20px; background: var(--bg-primary); border: 2px solid var(--border-color); border-radius: 12px; text-align: left; cursor: pointer; transition: border-color 0.2s;">
                            <strong style="color: var(--text-primary); display: block; margin-bottom: 4px;">Math</strong>
                            <span style="color: var(--text-secondary); font-size: 13px;">Pre-algebra, Algebra, geometry, and problem solving</span>
                        </button>
                    </div>
                    <button onclick="closeDiagnosticSelectionModal()" class="btn btn-secondary" style="width: 100%; margin-top: 16px; padding: 12px;">
                        Maybe Later
                    </button>
                </div>
            `;
            document.body.appendChild(modal);

            // Close on click outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeDiagnosticSelectionModal();
                }
            });

            // Add hover effects
            const buttons = modal.querySelectorAll('.btn');
            buttons.forEach(btn => {
                if (btn.textContent.includes('Reading') || btn.textContent.includes('Writing') || btn.textContent.includes('Math')) {
                    btn.addEventListener('mouseenter', () => {
                        btn.style.borderColor = 'var(--accent-color)';
                    });
                    btn.addEventListener('mouseleave', () => {
                        btn.style.borderColor = 'var(--border-color)';
                    });
                }
            });
        }

        /**
         * Close the diagnostic selection modal
         */
        function closeDiagnosticSelectionModal() {
            const modal = document.getElementById('diagnosticSelectionModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        /**
         * Start a diagnostic from the selection modal
         * @param {string} category - 'reading', 'writing', or 'math'
         */
        async function startDiagnosticFromModal(category) {
            closeDiagnosticSelectionModal();

            // Fetch the study plan to get diagnostic IDs
            try {
                const response = await fetch(`${API_BASE}/profile`, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });

                if (!response.ok) {
                    console.error('Failed to fetch profile for diagnostic');
                    return;
                }

                const data = await response.json();
                const studyPlan = data.study_plan;

                if (!studyPlan) {
                    console.error('No study plan available');
                    alert('No diagnostics available yet. Please try again later.');
                    return;
                }

                // Get the diagnostic ID for the selected category
                let diagnosticId = null;
                let diagnosticType = 'lesson';

                if (category === 'reading' && studyPlan.reading) {
                    diagnosticId = studyPlan.reading.diagnostic_passage_id;
                    diagnosticType = 'passage';
                } else if (category === 'writing' && studyPlan.writing) {
                    diagnosticId = studyPlan.writing.diagnostic_lesson_id;
                    diagnosticType = 'lesson';
                } else if (category === 'math' && studyPlan.math) {
                    diagnosticId = studyPlan.math.diagnostic_lesson_id;
                    diagnosticType = 'lesson';
                }

                if (diagnosticId) {
                    startDiagnostic(diagnosticId, diagnosticType);
                } else {
                    console.error('No diagnostic ID found for category:', category);
                    alert(`No ${category} diagnostic available yet.`);
                }
            } catch (error) {
                console.error('Error starting diagnostic:', error);
            }
        }

        /**
         * Handle dismiss button click on penguin coach
         * @param {string} promptId - The prompt ID to dismiss
         */
        async function handlePenguinCoachDismiss(promptId) {
            console.log('handlePenguinCoachDismiss:', promptId);

            hidePenguinCoach();

            try {
                const response = await fetch(`${API_BASE}/onboarding/dismiss`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ prompt_id: promptId })
                });

                if (!response.ok) {
                    console.error('handlePenguinCoachDismiss: Failed to dismiss prompt');
                }

                // Refresh onboarding state (will show no prompt since dismissed)
                await refreshOnboardingAndShow();
            } catch (error) {
                console.error('handlePenguinCoachDismiss: Error:', error);
            }
        }

        /**
         * Mark welcome prompt as seen
         */
        async function markWelcomeSeen() {
            try {
                const response = await fetch(`${API_BASE}/onboarding/welcome-seen`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    console.error('markWelcomeSeen: Failed to mark welcome as seen');
                }
            } catch (error) {
                console.error('markWelcomeSeen: Error:', error);
            }
        }

        /**
         * Refresh onboarding data and show the penguin coach if there's a prompt
         */
        async function refreshOnboardingAndShow() {
            const data = await fetchOnboardingData();
            if (data && data.prompt) {
                showPenguinCoach();
            } else {
                hidePenguinCoach();
            }
        }

        /**
         * Initialize the penguin coach on page load (for logged-in users)
         */
        async function initPenguinCoach() {
            if (!authToken) {
                console.log('initPenguinCoach: No auth token, skipping');
                return;
            }

            // Small delay to let the page settle
            setTimeout(async () => {
                await refreshOnboardingAndShow();
            }, 500);
        }
        
        // Check URL hash to determine initial view
        function handleHashRoute() {
            const hash = window.location.hash.substring(1); // Remove #
            console.log('Hash route handler called with hash:', hash);
            
            if (hash.startsWith('passage/')) {
                const passageId = hash.split('/')[1];
                // Only open if we're not already opening this passage and it's different from current (prevent loop)
                if (!isOpeningPassage && currentPassageId !== passageId) {
                    showPassages(true);
                    setTimeout(() => {
                        console.log('Opening passage from hash:', passageId);
                        openPassage(passageId);
                    }, 100);
                }
            } else if (hash.startsWith('lesson/')) {
                const lessonId = hash.split('/')[1];
                // Only open if it's different from current lesson (prevent loop)
                if (currentLessonId !== lessonId) {
                showPassages(true);
                setTimeout(() => {
                    console.log('Opening lesson from hash:', lessonId);
                    openLesson(lessonId);
                }, 100);
                }
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // } else if (hash.startsWith('writing-section/')) {
            //     const sectionId = hash.split('/')[1];
            //     showPassages(true);
            //     setTimeout(() => {
            //         console.log('Opening writing section from hash:', sectionId);
            //         openWritingSection(sectionId);
            //     }, 100);
            } else if (hash.startsWith('math-section/')) {
                const sectionId = hash.split('/')[1];
                // Only open if we're not already opening this section and it's different from current (prevent loop)
                if (!isOpeningMathSection && currentMathSectionId !== sectionId) {
                    // Show passages view but don't reload content (we're opening a detail view)
                    document.getElementById('landingPage').style.display = 'none';
                    document.getElementById('passagesView').style.display = 'block';
                    document.querySelector('header').style.display = 'flex';
                    // Don't call showPassages(true) as it will show the list - we want to show the detail
                    setTimeout(() => {
                        console.log('Opening math section from hash:', sectionId);
                        openMathSection(sectionId);
                    }, 100);
                }
            } else if (hash === 'passages' || hash === 'lessons' || hash === 'math-sections' || hash === '') {
                // COMMENTED OUT: 'writing-sections' removed from hash check
                console.log('Showing passages view from hash');
                // Only show passages if we're not currently viewing a detail (prevent loop)
                if (!currentPassageId && !currentLessonId && !currentMathSectionId) {
                showPassages(true);
                } else {
                    // We're navigating away from a detail view, clear state and show list
                    currentPassageId = null;
                    currentLessonId = null;
                    currentMathSectionId = null;
                    showPassages(true);
                }
            } else {
                showLanding();
            }
        }
        
        // Listen for hash changes
        window.addEventListener('hashchange', handleHashRoute);
        
        // Initial route handling - wait for DOM to be ready
        // Check if we're returning from Stripe checkout
        const urlParams = new URLSearchParams(window.location.search);
        const fromSubscription = urlParams.get('from') === 'subscription' || localStorage.getItem('pendingSubscription') === 'true';
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                // Check for Google OAuth callback first (before hash route)
                handleGoogleCallback();
                // If we have a token but no user, check auth
                if (authToken && !currentUser) {
                    checkAuth();
                } else if (authToken && fromSubscription) {
                    // Refresh user data after returning from subscription
                    // Delay to ensure all functions are defined
                    setTimeout(() => {
                        if (typeof refreshUserData === 'function') {
                            refreshUserData().then(() => {
                                localStorage.removeItem('pendingSubscription');
                                showPassages();
                            }).catch(err => {
                                console.error('Error refreshing user data:', err);
                                showPassages();
                            });
                        } else {
                            // Fallback: just check auth
                            checkAuth();
                            showPassages();
                        }
                    }, 500);
                } else {
                    handleHashRoute();
                }
            });
        } else {
            // DOM is already ready, but add small delay to ensure all elements are accessible
            setTimeout(() => {
                // Check for Google OAuth callback first (before hash route)
                handleGoogleCallback();
                // If we have a token but no user, check auth
                if (authToken && !currentUser) {
                    checkAuth();
                } else if (authToken && fromSubscription) {
                    // Refresh user data after returning from subscription
                    // Delay to ensure all functions are defined
                    setTimeout(() => {
                        if (typeof refreshUserData === 'function') {
                            refreshUserData().then(() => {
                                localStorage.removeItem('pendingSubscription');
                                showPassages();
                            }).catch(err => {
                                console.error('Error refreshing user data:', err);
                                showPassages();
                            });
                        } else {
                            // Fallback: just check auth
                            checkAuth();
                            showPassages();
                        }
                    }, 500);
                } else {
                    handleHashRoute();
                }
            }, 50);
        }
        
        // Check if user is logged in on load
        if (authToken) {
            checkAuth();
        }
        
        // Load word of the day
        loadWordOfDay();
        
        function showLanding() {
            document.getElementById('landingPage').style.display = 'block';
            document.getElementById('passagesView').style.display = 'none';
            // Hide header on landing page
            document.querySelector('header').style.display = 'none';
            // Update toggle buttons
            document.querySelectorAll('.view-toggle button').forEach(btn => {
                btn.classList.remove('active');
            });
            // Clear any detail view state
            currentPassageId = null;
            currentLessonId = null;
            currentMathSectionId = null;
            // Clear URL hash completely when going to landing page
            if (window.location.hash !== '') {
                window.history.replaceState(null, '', window.location.pathname);
            }
        }
        
        function showPassages(forceReload = false) {
            document.getElementById('landingPage').style.display = 'none';
            document.getElementById('passagesView').style.display = 'block';
            // Show header on passages view
            document.querySelector('header').style.display = 'flex';
            // Update toggle buttons
            document.querySelectorAll('.view-toggle button').forEach(btn => {
                if (btn.textContent === 'Passages') {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            // Reset to list view - make sure all list sections are visible
            document.getElementById('passageDetailSection').style.display = 'none';
            // Make sure list sections are visible
            const passagesListSection = document.getElementById('passagesListSection');
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // const writingSectionsListSection = document.getElementById('writingSectionsListSection');
            // COMMENTED OUT: Math sections removed, only showing lessons
            // const mathSectionsListSection = document.getElementById('mathSectionsListSection');
            if (passagesListSection) passagesListSection.style.display = 'block';
            // if (writingSectionsListSection) writingSectionsListSection.style.display = 'block';
            // if (mathSectionsListSection) mathSectionsListSection.style.display = 'block';
            // Clear any detail view state
            currentPassageId = null;
            currentLessonId = null;
            currentMathSectionId = null;
            // Always update URL to #passages when showing list view (this prevents hashchange from re-opening detail views)
            const currentHash = window.location.hash.substring(1);
            if (currentHash !== 'passages') {
                // Use replaceState to avoid triggering hashchange event
                window.history.replaceState(null, '', window.location.pathname + '#passages');
            }
            // Load content for the current category
            switchCategory(currentCategory, forceReload);
        }
        
        async function checkAuth() {
            if (!authToken) {
                console.log('checkAuth: No authToken, skipping');
                return;
            }
            console.log('checkAuth: Checking auth with token');
            try {
                const response = await fetch(`${API_BASE}/auth/me`, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });
                
                if (response.ok) {
                    currentUser = await response.json();
                    console.log('checkAuth: User authenticated:', currentUser.email);
                    updateUI();
                    // Initialize penguin coach for logged-in users
                    initPenguinCoach();
                    // Keep landing page visible - user can navigate to passages when ready
                } else {
                    console.log('checkAuth: Auth failed, removing token');
                    localStorage.removeItem('authToken');
                    authToken = null;
                    currentUser = null;
                    updateUI();
                    loadPassages();
                }
            } catch (error) {
                console.error('Auth check failed:', error);
                localStorage.removeItem('authToken');
                authToken = null;
                currentUser = null;
                updateUI();
                loadPassages();
            }
        }
        
        async function handleLogin(e) {
            e.preventDefault();
            const formData = new FormData(e.target);
            const data = {
                email: formData.get('email'),
                password: formData.get('password')
            };
            
            try {
                const response = await fetch(`${API_BASE}/auth/login`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    authToken = result.tokens.access;
                    localStorage.setItem('authToken', authToken);
                    currentUser = result.user;
                    closeModal('loginModal');
                    updateUI();
                    // Initialize penguin coach after login
                    initPenguinCoach();
                    // Stay on landing page - user can navigate to passages when ready
                } else {
                    document.getElementById('loginError').textContent = result.error?.message || 'Login failed';
                }
            } catch (error) {
                document.getElementById('loginError').textContent = 'Network error. Please try again.';
            }
        }
        
        async function handleGoogleLogin() {
            try {
                // Get the Google OAuth URL from backend
                const response = await fetch(`${API_BASE}/auth/google/url`);
                const result = await response.json();
                
                if (response.ok && result.auth_url) {
                    // Close modals
                    closeModal('loginModal');
                    closeModal('registerModal');
                    // Redirect to Google OAuth
                    window.location.href = result.auth_url;
                } else {
                    alert('Failed to initiate Google login. Please try again.');
                }
            } catch (error) {
                console.error('Google login error:', error);
                alert('Network error. Please try again.');
            }
        }
        
        // Handle Google OAuth callback
        async function handleGoogleCallback() {
            console.log('handleGoogleCallback called, hash:', window.location.hash);
            // Check for tokens in URL fragment (from backend redirect)
            const hash = window.location.hash;
            if (hash.includes('google_oauth=')) {
                console.log('Found google_oauth in hash');
                // Parse hash - could be #passages?google_oauth=... or just #google_oauth=...
                let hashPart = hash.substring(1); // Remove #
                let tokenData = null;
                
                // Check if it has query params
                if (hashPart.includes('?')) {
                    const parts = hashPart.split('?');
                    const params = new URLSearchParams(parts[1]);
                    tokenData = params.get('google_oauth');
                } else {
                    // Direct parameter in hash
                    const params = new URLSearchParams(hashPart);
                    tokenData = params.get('google_oauth');
                }
                
                if (tokenData) {
                    console.log('Found token data, decoding...');
                    try {
                        // Decode base64 token data
                        let padded = tokenData;
                        while (padded.length % 4) {
                            padded += '=';
                        }
                        const decoded = atob(padded);
                        const result = JSON.parse(decoded);
                        console.log('Decoded tokens, full result:', result);
                        
                        // Backend sends: { access, refresh, user }
                        // Validate result structure
                        if (!result.access) {
                            throw new Error('Invalid token structure: missing access token');
                        }
                        if (!result.user) {
                            throw new Error('Invalid token structure: missing user');
                        }
                        
                        // Store tokens and user info
                        try {
                            authToken = result.access;
                            // Also store refresh token for future use
                            if (result.refresh) {
                                localStorage.setItem('refreshToken', result.refresh);
                            }
                            localStorage.setItem('authToken', authToken);
                            currentUser = result.user;
                            console.log('Stored authToken and currentUser:', authToken ? 'YES' : 'NO', currentUser ? 'YES' : 'NO');
                            
                            // Clean up URL - remove google_oauth param but keep navigation
                            const cleanHash = hashPart.split('?')[0] || '#passages';
                            window.history.replaceState({}, document.title, window.location.pathname + cleanHash);
                            
                            // Update UI and navigate - wait a bit for DOM to be ready
                            console.log('Calling updateUI()');
                            try {
                                // Ensure DOM is ready
                                if (document.readyState === 'loading') {
                                    await new Promise(resolve => {
                                        if (document.readyState === 'complete') {
                                            resolve();
                                        } else {
                                            document.addEventListener('DOMContentLoaded', resolve);
                                        }
                                    });
                                }
                                // Small delay to ensure all elements are rendered
                                await new Promise(resolve => setTimeout(resolve, 100));
                                updateUI();
                                console.log('updateUI() completed');
                            } catch (uiError) {
                                console.error('Error in updateUI():', uiError);
                                // Don't throw - try to continue anyway
                            }
                            
                            // Initialize penguin coach after Google login
                            initPenguinCoach();

                            // Navigate to passages view if not already there
                            if (!hashPart.includes('passages') && !hashPart.includes('writing') && !hashPart.includes('math')) {
                                console.log('Navigating to passages');
                                try {
                                    showPassages();
                                    console.log('showPassages() completed');
                                } catch (navError) {
                                    console.error('Error in showPassages():', navError);
                                    throw navError;
                                }
                            } else {
                                // Already on a view, just trigger the hash change handler
                                console.log('Already on view, calling handleHashRoute');
                                try {
                                    handleHashRoute();
                                    console.log('handleHashRoute() completed');
                                } catch (routeError) {
                                    console.error('Error in handleHashRoute():', routeError);
                                    throw routeError;
                                }
                            }
                            return;
                        } catch (storageError) {
                            console.error('Error storing tokens or updating UI:', storageError);
                            throw storageError;
                        }
                    } catch (error) {
                        console.error('Error in Google OAuth callback:', error);
                        console.error('Error stack:', error.stack);
                        // Try to continue anyway if we have the data
                        if (currentUser && authToken) {
                            console.log('Have user and token, continuing despite error');
                            try {
                                updateUI();
                                showPassages();
                            } catch (recoveryError) {
                                console.error('Recovery also failed:', recoveryError);
                                alert('Login successful but UI update failed. Please refresh the page.');
                            }
                        } else {
                            alert('Failed to complete Google login: ' + (error.message || 'Unknown error'));
                            window.history.replaceState({}, document.title, window.location.pathname);
                        }
                        return;
                    }
                }
            }
            console.log('No google_oauth found in hash');
            
            // Fallback: Check for code in query string (direct API call)
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const error = urlParams.get('error');
            
            if (error) {
                alert(`Google login failed: ${error}`);
                window.history.replaceState({}, document.title, window.location.pathname);
                return;
            }
            
            if (code) {
                try {
                    // Exchange code for tokens
                    const response = await fetch(`${API_BASE}/auth/google/callback?code=${encodeURIComponent(code)}`);
                    const result = await response.json();
                    
                    if (response.ok) {
                        authToken = result.tokens.access;
                        localStorage.setItem('authToken', authToken);
                        currentUser = result.user;
                        window.history.replaceState({}, document.title, window.location.pathname);
                        updateUI();
                        // Initialize penguin coach after Google login
                        initPenguinCoach();
                        // Navigate to passages after login
                        showPassages();
                    } else {
                        alert(result.error?.message || 'Google login failed');
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }
                } catch (error) {
                    console.error('Google callback error:', error);
                    alert('Failed to complete Google login. Please try again.');
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            }
        }
        
        async function handleRegister(e) {
            e.preventDefault();
            const formData = new FormData(e.target);
            const data = {
                email: formData.get('email'),
                password: formData.get('password')
            };
            
            try {
                const response = await fetch(`${API_BASE}/auth/register`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    authToken = result.tokens.access;
                    localStorage.setItem('authToken', authToken);
                    currentUser = result.user;
                    closeModal('registerModal');
                    updateUI();
                    // Initialize penguin coach after registration
                    initPenguinCoach();

                    // If there's a saved attempt from before registration, save it now
                    if (lastAttemptData) {
                        const savedPassageId = lastAttemptData.passage_id;
                        await saveAnonymousAttempt(lastAttemptData);
                        lastAttemptData = null; // Clear after saving
                        
                        // Navigate to passages view
                        showPassages();
                        await loadPassages();
                        
                        // Show attempt history for the passage that was attempted
                        if (savedPassageId) {
                            setTimeout(() => {
                                showAttemptHistory(savedPassageId);
                            }, 500);
                        }
                    } else {
                        // Navigate to passages view
                        showPassages();
                        await loadPassages();
                    }
                } else {
                    document.getElementById('registerError').textContent = result.error?.message || 'Registration failed';
                }
            } catch (error) {
                document.getElementById('registerError').textContent = 'Network error. Please try again.';
            }
        }
        
        let currentCategory = 'reading';

        // View mode state (grid or list) per category
        const viewModes = {
            reading: 'grid',
            writing: 'grid',
            math: 'grid'
        };

        // Stored skills data for grid rendering
        const skillsData = {
            reading: { lessons: [], passages: [] },
            writing: { lessons: [] },
            math: { lessons: [] }
        };

        // Gamification stats
        let userStats = {
            streak: 0,
            totalXP: 0,
            completed: 0
        };

        /**
         * Set the view mode for a category (grid or list)
         */
        function setViewMode(category, mode) {
            console.log(`Setting ${category} view mode to ${mode}`);
            viewModes[category] = mode;

            // Update button states
            const gridBtn = document.getElementById(`${category}-grid-btn`);
            const listBtn = document.getElementById(`${category}-list-btn`);
            if (gridBtn) gridBtn.classList.toggle('active', mode === 'grid');
            if (listBtn) listBtn.classList.toggle('active', mode === 'list');

            // Toggle visibility of sections
            const gridSection = document.getElementById(`${category}GridSection`);
            const lessonsListSection = document.getElementById(`${category}LessonsListSection`);
            const passagesListSection = category === 'reading' ? document.getElementById('passagesListSection') : null;

            if (mode === 'grid') {
                if (gridSection) gridSection.style.display = 'block';
                if (lessonsListSection) lessonsListSection.style.display = 'none';
                if (passagesListSection) passagesListSection.style.display = 'none';
                // Render the grid if we have data
                renderSkillsGrid(category);
            } else {
                if (gridSection) gridSection.style.display = 'none';
                if (lessonsListSection) lessonsListSection.style.display = 'block';
                if (passagesListSection) passagesListSection.style.display = 'block';
            }
        }

        /**
         * Get color class based on icon_color or category
         */
        function getSkillColorClass(iconColor, category) {
            if (iconColor) {
                const colorMap = {
                    'green': 'skill-bg-green',
                    'purple': 'skill-bg-purple',
                    'blue': 'skill-bg-blue',
                    'orange': 'skill-bg-orange',
                    'red': 'skill-bg-red',
                    'yellow': 'skill-bg-yellow',
                    'teal': 'skill-bg-teal',
                    'pink': 'skill-bg-pink'
                };
                if (colorMap[iconColor.toLowerCase()]) {
                    return colorMap[iconColor.toLowerCase()];
                }
                // If it's a hex color, return empty (will use inline style)
                return '';
            }
            // Default colors by category
            const categoryColors = {
                'reading': 'skill-color-reading',
                'writing': 'skill-color-writing',
                'math': 'skill-color-math'
            };
            return categoryColors[category] || 'skill-color-reading';
        }

        /**
         * Get inline background style if hex color provided
         */
        function getSkillColorStyle(iconColor) {
            if (iconColor && iconColor.startsWith('#')) {
                // Darken the color for gradient
                const darkerColor = darkenHexColor(iconColor, 20);
                return `background: linear-gradient(135deg, ${iconColor} 0%, ${darkerColor} 100%);`;
            }
            return '';
        }

        /**
         * Darken a hex color by a percentage
         */
        function darkenHexColor(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max((num >> 16) - amt, 0);
            const G = Math.max((num >> 8 & 0x00FF) - amt, 0);
            const B = Math.max((num & 0x0000FF) - amt, 0);
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        /**
         * Create a progress ring SVG
         */
        function createProgressRing(progress, colorClass, iconColor) {
            const radius = 44;
            const circumference = 2 * Math.PI * radius;
            const offset = circumference - (progress / 100) * circumference;
            const strokeColor = iconColor && iconColor.startsWith('#') ? iconColor : 'var(--accent-color)';

            return `
                <div class="progress-ring-container">
                    <svg class="progress-ring" viewBox="0 0 100 100">
                        <circle class="progress-ring-bg" cx="50" cy="50" r="${radius}"/>
                        <circle class="progress-ring-fill" cx="50" cy="50" r="${radius}"
                            stroke="${strokeColor}"
                            stroke-dasharray="${circumference}"
                            stroke-dashoffset="${offset}"/>
                    </svg>
                </div>
            `;
        }

        /**
         * Create a skill node HTML element
         */
        function createSkillNode(item, category, type) {
            const iconUrl = item.effective_icon_url;
            const iconColor = item.effective_icon_color;
            const isPremium = item.tier === 'premium';
            const hasAccess = !isPremium || (currentUser && (currentUser.is_premium || currentUser.has_active_subscription));
            const isLocked = isPremium && !hasAccess;

            // Calculate progress (based on attempt data if available)
            let progress = 0;
            if (item.attempt_count && item.attempt_count > 0) {
                // If there's an attempt, show at least some progress
                progress = item.attempt_summary?.best_score || 25;
            }
            const isCompleted = progress >= 80;

            // Get first letter for placeholder
            const firstLetter = (item.title || 'K').charAt(0).toUpperCase();

            // Build color class or style
            const colorClass = getSkillColorClass(iconColor, category);
            const colorStyle = getSkillColorStyle(iconColor);

            // Icon content: image or letter placeholder
            const iconContent = iconUrl
                ? `<img src="${escapeHtml(iconUrl)}" alt="${escapeHtml(item.title)}" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                   <span class="skill-icon-letter" style="display: none;">${firstLetter}</span>`
                : `<span class="skill-icon-letter">${firstLetter}</span>`;

            // Badges
            const crownBadge = isCompleted ? '<span class="skill-crown"></span>' : '';
            const lockBadge = isLocked ? '<span class="skill-lock"></span>' : '';

            // Click handler based on type
            const clickHandler = type === 'passage'
                ? `openPassage('${item.id}')`
                : `openLesson('${item.id}', '${escapeHtml(item.title).replace(/'/g, "\\'")}')`;

            return `
                <div class="skill-node ${isLocked ? 'locked' : ''}" onclick="${clickHandler}">
                    <div class="skill-icon ${colorClass}" style="${colorStyle}">
                        ${iconContent}
                        ${createProgressRing(progress, colorClass, iconColor)}
                        ${crownBadge}
                        ${lockBadge}
                    </div>
                    <span class="skill-title">${escapeHtml(item.title)}</span>
                </div>
            `;
        }

        /**
         * Render the skills grid for a category
         */
        function renderSkillsGrid(category) {
            const gridContainer = document.getElementById(`${category}SkillsGrid`);
            if (!gridContainer) return;

            const data = skillsData[category];
            if (!data) return;

            let html = '';

            // Render lessons grouped by header
            if (data.lessons && data.lessons.length > 0) {
                // Group lessons by header
                const lessonsByHeader = {};
                const lessonsWithoutHeader = [];

                data.lessons.forEach(lesson => {
                    if (lesson.header && lesson.header.id) {
                        const headerId = lesson.header.id;
                        if (!lessonsByHeader[headerId]) {
                            lessonsByHeader[headerId] = {
                                header: lesson.header,
                                lessons: []
                            };
                        }
                        lessonsByHeader[headerId].lessons.push(lesson);
                    } else {
                        lessonsWithoutHeader.push(lesson);
                    }
                });

                // Sort headers by display_order
                const sortedHeaders = Object.values(lessonsByHeader).sort((a, b) =>
                    (b.header.display_order || 0) - (a.header.display_order || 0)
                );

                // Sort lessons within each header
                sortedHeaders.forEach(headerGroup => {
                    headerGroup.lessons.sort((a, b) =>
                        (b.order_within_header || 0) - (a.order_within_header || 0)
                    );
                });

                // Render each header group
                sortedHeaders.forEach(headerGroup => {
                    html += `<div class="skills-category-header"><h3>${escapeHtml(headerGroup.header.title)}</h3></div>`;
                    headerGroup.lessons.forEach(lesson => {
                        html += createSkillNode(lesson, category, 'lesson');
                    });
                });

                // Render lessons without headers
                if (lessonsWithoutHeader.length > 0) {
                    if (sortedHeaders.length > 0) {
                        html += `<div class="skills-category-header"><h3>Other Lessons</h3></div>`;
                    }
                    lessonsWithoutHeader.forEach(lesson => {
                        html += createSkillNode(lesson, category, 'lesson');
                    });
                }
            }

            // Render passages (for reading category)
            if (category === 'reading' && data.passages && data.passages.length > 0) {
                html += `<div class="skills-category-header"><h3>Practice Passages</h3></div>`;

                // Group passages by header
                const passagesByHeader = {};
                const passagesWithoutHeader = [];

                data.passages.forEach(passage => {
                    if (passage.header && passage.header.id) {
                        const headerId = passage.header.id;
                        if (!passagesByHeader[headerId]) {
                            passagesByHeader[headerId] = {
                                header: passage.header,
                                passages: []
                            };
                        }
                        passagesByHeader[headerId].passages.push(passage);
                    } else {
                        passagesWithoutHeader.push(passage);
                    }
                });

                // Sort and render
                const sortedPassageHeaders = Object.values(passagesByHeader).sort((a, b) =>
                    (b.header.display_order || 0) - (a.header.display_order || 0)
                );

                sortedPassageHeaders.forEach(headerGroup => {
                    headerGroup.passages.sort((a, b) =>
                        (b.order_within_header || 0) - (a.order_within_header || 0)
                    );
                    headerGroup.passages.forEach(passage => {
                        html += createSkillNode(passage, category, 'passage');
                    });
                });

                passagesWithoutHeader.forEach(passage => {
                    html += createSkillNode(passage, category, 'passage');
                });
            }

            // Add CTA banner for non-logged-in users
            if (!currentUser && data.lessons && data.lessons.length > 0) {
                html += `
                    <div style="width: 100%; background: linear-gradient(135deg, #3498DB 0%, #2980b9 100%); color: white; padding: 20px; border-radius: 12px; margin-top: 25px; text-align: center;">
                        <h4 style="margin: 0 0 8px 0; font-size: 18px;">Unlock all skills!</h4>
                        <p style="margin: 0 0 15px 0; opacity: 0.9;">Create a free account to track your progress and get personalized recommendations.</p>
                        <button onclick="showLoginModal()" style="background: white; color: #3498DB; border: none; padding: 10px 25px; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">Sign Up Free</button>
                    </div>
                `;
            }

            if (html === '') {
                html = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">No content available yet.</p>';
            }

            gridContainer.innerHTML = html;
        }

        /**
         * Update gamification stats in sidebar
         */
        function updateGamificationStats() {
            // Calculate stats from skillsData
            let completed = 0;
            let totalXP = 0;

            Object.values(skillsData).forEach(categoryData => {
                if (categoryData.lessons) {
                    categoryData.lessons.forEach(lesson => {
                        if (lesson.attempt_count && lesson.attempt_count > 0) {
                            // XP based on best score
                            const bestScore = lesson.attempt_summary?.best_score || 0;
                            totalXP += Math.floor(bestScore * 10);
                            if (bestScore >= 80) completed++;
                        }
                    });
                }
                if (categoryData.passages) {
                    categoryData.passages.forEach(passage => {
                        if (passage.attempt_count && passage.attempt_count > 0) {
                            const bestScore = passage.attempt_summary?.best_score || 0;
                            totalXP += Math.floor(bestScore * 10);
                            if (bestScore >= 80) completed++;
                        }
                    });
                }
            });

            userStats.totalXP = totalXP;
            userStats.completed = completed;

            // Update DOM
            const streakEl = document.getElementById('streakCount');
            const xpEl = document.getElementById('totalXP');
            const completedEl = document.getElementById('completedCount');

            if (streakEl) streakEl.textContent = userStats.streak;
            if (xpEl) xpEl.textContent = userStats.totalXP.toLocaleString();
            if (completedEl) completedEl.textContent = userStats.completed;

            // Update streak flames
            const flamesContainer = document.getElementById('streakFlames');
            if (flamesContainer) {
                const flames = flamesContainer.querySelectorAll('.streak-flame');
                flames.forEach((flame, i) => {
                    flame.classList.toggle('active', i < userStats.streak);
                });
            }
        }

        /**
         * Load skills data for grid view
         */
        async function loadSkillsData(category) {
            const headers = {};
            if (authToken) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }

            try {
                // Load lessons for this category
                const lessonsResponse = await fetch(`${API_BASE}/lessons/?lesson_type=${category}&limit=200`, {headers});
                const lessonsData = await lessonsResponse.json();
                skillsData[category].lessons = lessonsData.results || [];

                // Load passages for reading category
                if (category === 'reading') {
                    const passagesResponse = await fetch(`${API_BASE}/passages/`, {headers});
                    const passagesData = await passagesResponse.json();
                    let passages = Array.isArray(passagesData) ? passagesData : (passagesData.results || []);

                    // Filter to intro passages if not logged in
                    if (!currentUser) {
                        passages = passages.filter(p => isIntroLesson(p.title));
                    }
                    skillsData[category].passages = passages;
                }

                // Render the grid
                if (viewModes[category] === 'grid') {
                    renderSkillsGrid(category);
                }

                // Update gamification stats
                updateGamificationStats();

            } catch (error) {
                console.error(`Failed to load skills data for ${category}:`, error);
            }
        }

        function switchCategory(category, forceReload = false) {
            console.log('switchCategory called with:', category);
            currentCategory = category;
            
            // Hide detail section when switching categories
            const passageDetailSection = document.getElementById('passageDetailSection');
            if (passageDetailSection) {
                passageDetailSection.style.display = 'none';
            }
            
            // Clear current detail view state
            currentPassageId = null;
            currentLessonId = null;
            currentMathSectionId = null;
            
            // Update button states
            document.querySelectorAll('.category-picker button').forEach(btn => {
                btn.classList.remove('active');
            });
            const categoryBtn = document.getElementById(`category-${category}-btn`);
            if (categoryBtn) {
                categoryBtn.classList.add('active');
                console.log('Category button activated:', category);
            } else {
                console.error('Category button not found:', `category-${category}-btn`);
            }
            
            // Update content visibility - hide all category content first
            document.querySelectorAll('.category-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none'; // Explicitly hide
            });
            
            // Show the selected category content
            const categoryContent = document.getElementById(`category-${category}`);
            if (categoryContent) {
                categoryContent.classList.add('active');
                categoryContent.style.display = 'block'; // Explicitly show
                console.log('Category content activated:', category);
            } else {
                console.error('Category content not found:', `category-${category}`);
            }
            
            // Show sections based on current view mode
            const currentViewMode = viewModes[category] || 'grid';

            // All sections to manage
            const allSections = [
                'readingGridSection', 'readingLessonsListSection', 'passagesListSection',
                'writingGridSection', 'writingLessonsListSection',
                'mathGridSection', 'mathLessonsListSection'
            ];

            // Hide all sections first
            allSections.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.style.display = 'none';
                }
            });

            // Show appropriate sections based on view mode
            if (currentViewMode === 'grid') {
                const gridSection = document.getElementById(`${category}GridSection`);
                if (gridSection) {
                    gridSection.style.display = 'block';
                    console.log(`${category} grid section shown`);
                }
            } else {
                // List mode
                if (category === 'reading') {
                    const readingLessonsListSection = document.getElementById('readingLessonsListSection');
                    const passagesListSection = document.getElementById('passagesListSection');
                    if (readingLessonsListSection) readingLessonsListSection.style.display = 'block';
                    if (passagesListSection) passagesListSection.style.display = 'block';
                } else if (category === 'writing') {
                    const writingLessonsListSection = document.getElementById('writingLessonsListSection');
                    if (writingLessonsListSection) writingLessonsListSection.style.display = 'block';
                } else if (category === 'math') {
                    const mathLessonsListSection = document.getElementById('mathLessonsListSection');
                    if (mathLessonsListSection) mathLessonsListSection.style.display = 'block';
                }
            }

            // Load content for the selected category
            // Use setTimeout to ensure DOM is ready
            setTimeout(() => {
                // Always load skills data for grid view
                const skillsGridEl = document.getElementById(`${category}SkillsGrid`);
                if (forceReload || !skillsGridEl || skillsGridEl.innerHTML === '') {
                    loadSkillsData(category);
                } else if (viewModes[category] === 'grid') {
                    // Just re-render if we already have data
                    renderSkillsGrid(category);
                }

                // Also load list data (for fallback)
                if (category === 'reading') {
                    const readingLessonsEl = document.getElementById('readingLessonsList');
                    const passagesEl = document.getElementById('passagesList');
                    if (forceReload || !readingLessonsEl || readingLessonsEl.innerHTML === '') {
                        loadLessonsByType('reading', 'readingLessonsList');
                    }
                    if (forceReload || !passagesEl || passagesEl.innerHTML === '') {
                        loadPassages();
                    }
                } else if (category === 'writing') {
                    const writingLessonsEl = document.getElementById('writingLessonsList');
                    if (forceReload || !writingLessonsEl || writingLessonsEl.innerHTML === '') {
                        loadLessonsByType('writing', 'writingLessonsList');
                    }
                } else if (category === 'math') {
                    const mathLessonsEl = document.getElementById('mathLessonsList');
                    if (forceReload || !mathLessonsEl || mathLessonsEl.innerHTML === '') {
                        loadLessonsByType('math', 'mathLessonsList');
                    }
                    // COMMENTED OUT: Math sections removed, only showing lessons
                    // if (forceReload || !mathSectionsEl || mathSectionsEl.innerHTML === '') {
                    //     loadMathSections();
                    // }
                }
            }, 0);
        }
        
        // Make switchCategory globally accessible
        window.switchCategory = switchCategory;
        window.setViewMode = setViewMode;
        
        async function loadLessonsByType(lessonType, listElementId) {
            try {
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`${API_BASE}/lessons/?lesson_type=${lessonType}&limit=200`, {headers});
                const data = await response.json();
                
                console.log(`Loaded ${lessonType} lessons:`, data.results);
                
                const lessonsList = document.getElementById(listElementId);
                lessonsList.innerHTML = '';
                
                if (data.results && data.results.length > 0) {
                    // Filter to only intro lessons if user is not logged in
                    let filteredResults = data.results;
                    if (!currentUser) {
                        filteredResults = data.results.filter(lesson => isIntroLesson(lesson.title));
                    }
                    
                    // Group lessons by header
                    const lessonsByHeader = {};
                    const lessonsWithoutHeader = [];
                    
                    filteredResults.forEach(lesson => {
                        console.log(`Lesson "${lesson.title}" has header:`, lesson.header);
                        if (lesson.header && lesson.header.id) {
                            const headerId = lesson.header.id;
                            if (!lessonsByHeader[headerId]) {
                                lessonsByHeader[headerId] = {
                                    header: lesson.header,
                                    lessons: []
                                };
                            }
                            lessonsByHeader[headerId].lessons.push(lesson);
                        } else {
                            lessonsWithoutHeader.push(lesson);
                        }
                    });
                    
                    // Sort headers by display_order (higher first)
                    const sortedHeaders = Object.values(lessonsByHeader).sort((a, b) => 
                        (b.header.display_order || 0) - (a.header.display_order || 0)
                    );
                    
                    // Sort lessons within each header by order_within_header (higher first)
                    sortedHeaders.forEach(headerGroup => {
                        headerGroup.lessons.sort((a, b) => 
                            (b.order_within_header || 0) - (a.order_within_header || 0)
                        );
                    });
                    
                    // Display headers with their lessons
                    sortedHeaders.forEach(headerGroup => {
                        // Header section
                        const headerDiv = document.createElement('div');
                        headerDiv.style.cssText = 'margin-bottom: 30px;';
                        headerDiv.innerHTML = `
                            <h3 style="color: #3498DB; font-size: 24px; font-weight: 600; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #3498DB;">
                                ${escapeHtml(headerGroup.header.title)}
                            </h3>
                        `;
                        lessonsList.appendChild(headerDiv);
                        
                        // Lessons under this header
                        const lessonsContainer = document.createElement('div');
                        lessonsContainer.style.cssText = 'margin-left: 20px;';
                        headerGroup.lessons.forEach(lesson => {
                            const card = document.createElement('div');
                            card.className = `passage-card ${lesson.tier === 'premium' ? 'premium' : ''}`;
                            card.style.cssText = 'margin-bottom: 15px;';
                            const isPremium = lesson.tier === 'premium';
                            card.innerHTML = `
                                <h4>${escapeHtml(lesson.title)} ${isPremium ? '<span class="premium-badge">PREMIUM</span> <span class="premium-lock"></span>' : ''}</h4>
                            `;
                            card.onclick = () => openLesson(lesson.id, lesson.title);
                            lessonsContainer.appendChild(card);
                        });
                        headerDiv.appendChild(lessonsContainer);
                    });
                    
                    // Display lessons without headers
                    if (lessonsWithoutHeader.length > 0) {
                        const noHeaderDiv = document.createElement('div');
                        noHeaderDiv.style.cssText = 'margin-top: 30px;';
                        noHeaderDiv.innerHTML = '<h3 style="color: #666; font-size: 20px; font-weight: 600; margin-bottom: 15px;">Other Lessons</h3>';
                        lessonsList.appendChild(noHeaderDiv);
                        
                        const lessonsContainer = document.createElement('div');
                        lessonsContainer.style.cssText = 'margin-left: 20px;';
                        lessonsWithoutHeader.forEach(lesson => {
                            const card = document.createElement('div');
                            card.className = `passage-card ${lesson.tier === 'premium' ? 'premium' : ''}`;
                            card.style.cssText = 'margin-bottom: 15px;';
                            const isPremium = lesson.tier === 'premium';
                            card.innerHTML = `
                                <h4>${escapeHtml(lesson.title)} ${isPremium ? '<span class="premium-badge">PREMIUM</span> <span class="premium-lock"></span>' : ''}</h4>
                            `;
                            card.onclick = () => openLesson(lesson.id, lesson.title);
                            lessonsContainer.appendChild(card);
                        });
                        noHeaderDiv.appendChild(lessonsContainer);
                    }
                    
                    if (sortedHeaders.length === 0 && lessonsWithoutHeader.length === 0) {
                        if (!currentUser) {
                            lessonsList.innerHTML = '<p style="color: #666; font-style: italic;">Log in to access all lessons.</p>';
                        } else {
                        lessonsList.innerHTML = '<p style="color: #666; font-style: italic;">No lessons available yet.</p>';
                    }
                    } else if (!currentUser) {
                        // Add CTA banner for non-logged-in users
                        const ctaBanner = document.createElement('div');
                        ctaBanner.style.cssText = 'background: linear-gradient(135deg, #3498DB 0%, #2980b9 100%); color: white; padding: 20px; border-radius: 12px; margin-top: 25px; text-align: center;';
                        ctaBanner.innerHTML = `
                            <h4 style="margin: 0 0 8px 0; font-size: 18px;">Want more lessons?</h4>
                            <p style="margin: 0 0 15px 0; opacity: 0.9;">Create a (free) account so that we can make your personalized study plan and start to track your progress!</p>
                            <button onclick="showLoginModal()" style="background: white; color: #3498DB; border: none; padding: 10px 25px; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">Sign Up Free</button>
                        `;
                        lessonsList.appendChild(ctaBanner);
                    }
                } else {
                    if (!currentUser) {
                        lessonsList.innerHTML = '<p style="color: #666; font-style: italic;">Log in to access all lessons.</p>';
                } else {
                    lessonsList.innerHTML = '<p style="color: #666; font-style: italic;">No lessons available yet.</p>';
                    }
                }
            } catch (error) {
                console.error(`Failed to load ${lessonType} lessons:`, error);
                const lessonsList = document.getElementById(listElementId);
                lessonsList.innerHTML = '<p style="color: #999;">Unable to load lessons.</p>';
            }
        }
        
        // COMMENTED OUT: Writing sections removed, only showing lessons
        /*
        async function loadWritingSections() {
            try {
                console.log('Loading writing sections...');
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`${API_BASE}/writing-sections/`, {headers});
                if (!response.ok) {
                    console.error('Failed to fetch writing sections:', response.status, response.statusText);
                    const writingSectionsList = document.getElementById('writingSectionsList');
                    if (writingSectionsList) {
                        writingSectionsList.innerHTML = '<p style="color: #999;">Failed to load writing sections. Please try again.</p>';
                    }
                    return;
                }
                
                const data = await response.json();
                console.log('Writing sections data received:', data);
                
                const writingSectionsList = document.getElementById('writingSectionsList');
                if (!writingSectionsList) {
                    console.error('writingSectionsList element not found!');
                    return;
                }
                writingSectionsList.innerHTML = '';
                
                // Handle both paginated (data.results) and non-paginated (data is array) responses
                const writingSections = Array.isArray(data) ? data : (data.results || []);
                console.log('Processing writing sections:', writingSections.length, 'sections');
                
                if (writingSections && writingSections.length > 0) {
                    writingSections.forEach(writingSection => {
                        const card = document.createElement('div');
                        card.className = `passage-card ${writingSection.tier === 'premium' ? 'premium' : ''}`;
                        const attemptCount = writingSection.attempt_count || 0;
                        const attemptText = attemptCount > 0 ? ` | ${attemptCount} attempt${attemptCount !== 1 ? 's' : ''}` : '';
                        
                        let attemptSummaryHTML = '';
                        if (writingSection.attempt_summary && attemptCount > 0) {
                            const summary = writingSection.attempt_summary;
                            attemptSummaryHTML = `
                                <div style="background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-top: 10px; font-size: 13px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                        <span style="color: #666;"><strong>Best Score:</strong></span>
                                        <span style="color: #3498DB; font-weight: bold;">${summary.best_score}%</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                        <span style="color: #666;"><strong>Latest Score:</strong></span>
                                        <span style="color: #000; font-weight: bold;">${summary.latest_score}%</span>
                                    </div>
                                    ${summary.recent_attempts && summary.recent_attempts.length > 0 ? `
                                        <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #e0e0e0;">
                                            <div style="color: #666; margin-bottom: 6px; font-size: 12px;"><strong>Recent Attempts:</strong></div>
                                            ${summary.recent_attempts.map((attempt, idx) => {
                                                const date = new Date(attempt.completed_at);
                                                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                                                return `
                                                    <div style="display: flex; justify-content: space-between; font-size: 11px; color: #666; margin-bottom: 4px;">
                                                        <span>${dateStr}</span>
                                                        <span style="font-weight: bold; color: #000;">${attempt.score}%</span>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    ` : ''}
                                </div>
                            `;
                        }
                        
                        const isPremium = writingSection.tier === 'premium';
                        const hasAccess = !isPremium || (currentUser && (currentUser.is_premium || currentUser.has_active_subscription));
                        card.innerHTML = `
                            <h3>${writingSection.title} ${isPremium ? '<span class="premium-badge">PREMIUM</span> <span class="premium-lock"></span>' : ''}</h3>
                            <p>Selections: ${writingSection.selection_count || 0}${attemptText}</p>
                            ${attemptSummaryHTML}
                            ${attemptCount > 0 && authToken ? `<button class="btn btn-secondary" onclick="event.stopPropagation(); showWritingSectionAttemptHistory('${writingSection.id}')" style="margin-top: 10px; font-size: 12px; padding: 6px 12px; width: 100%;">View Full Attempt History</button>` : ''}
                        `;
                        card.addEventListener('click', (e) => {
                            // Don't trigger if clicking on a button
                            if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                                return;
                            }
                            console.log('Writing section card clicked:', writingSection.id, writingSection.title);
                            e.preventDefault();
                            e.stopPropagation();
                            openWritingSection(writingSection.id);
                        });
                        card.style.cursor = 'pointer';
                        writingSectionsList.appendChild(card);
                    });
                } else {
                    console.log('No writing sections found in response');
                    writingSectionsList.innerHTML = '<p style="color: #666; font-style: italic;">No writing sections available yet.</p>';
                }
            } catch (error) {
                console.error('Failed to load writing sections:', error);
                console.error('Error details:', error.message, error.stack);
                const writingSectionsList = document.getElementById('writingSectionsList');
                if (writingSectionsList) {
                    writingSectionsList.innerHTML = `<p style="color: #999;">Error loading writing sections: ${error.message}. Please refresh the page.</p>`;
                }
            }
        }
        */
        
        async function loadMathSections() {
            try {
                console.log('Loading math sections...');
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`${API_BASE}/math-sections/`, {headers});
                if (!response.ok) {
                    console.error('Failed to fetch math sections:', response.status, response.statusText);
                    const mathSectionsList = document.getElementById('mathSectionsList');
                    if (mathSectionsList) {
                        mathSectionsList.innerHTML = '<p style="color: #999;">Failed to load math sections. Please try again.</p>';
                    }
                    return;
                }
                
                const data = await response.json();
                console.log('Math sections data received:', data);
                
                const mathSectionsList = document.getElementById('mathSectionsList');
                if (!mathSectionsList) {
                    console.error('mathSectionsList element not found!');
                    return;
                }
                mathSectionsList.innerHTML = '';
                
                // Handle both paginated (data.results) and non-paginated (data is array) responses
                const mathSections = Array.isArray(data) ? data : (data.results || []);
                console.log('Processing math sections:', mathSections.length, 'sections');
                console.log('First math section sample:', mathSections[0]);
                
                if (mathSections && mathSections.length > 0) {
                    // Group math sections by header
                    const sectionsByHeader = {};
                    const sectionsWithoutHeader = [];
                    
                    mathSections.forEach(mathSection => {
                        if (mathSection.header && mathSection.header.id) {
                            const headerId = mathSection.header.id;
                            if (!sectionsByHeader[headerId]) {
                                sectionsByHeader[headerId] = {
                                    header: mathSection.header,
                                    sections: []
                                };
                            }
                            sectionsByHeader[headerId].sections.push(mathSection);
                        } else {
                            sectionsWithoutHeader.push(mathSection);
                        }
                    });
                    
                    // Sort headers by display_order (higher first)
                    const sortedHeaders = Object.values(sectionsByHeader).sort((a, b) => 
                        (b.header.display_order || 0) - (a.header.display_order || 0)
                    );
                    
                    // Sort sections within each header by order_within_header (higher first)
                    sortedHeaders.forEach(headerGroup => {
                        headerGroup.sections.sort((a, b) => 
                            (b.order_within_header || 0) - (a.order_within_header || 0)
                        );
                    });
                    
                    // Display headers with their sections
                    sortedHeaders.forEach(headerGroup => {
                        // Header section
                        const headerDiv = document.createElement('div');
                        headerDiv.style.cssText = 'margin-bottom: 30px;';
                        headerDiv.innerHTML = `
                            <h3 style="color: #3498DB; font-size: 24px; font-weight: 600; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #3498DB;">
                                ${escapeHtml(headerGroup.header.title)}
                            </h3>
                        `;
                        mathSectionsList.appendChild(headerDiv);
                        
                        // Sections under this header
                        const sectionsContainer = document.createElement('div');
                        sectionsContainer.style.cssText = 'margin-left: 20px;';
                        headerGroup.sections.forEach(mathSection => {
                        const card = document.createElement('div');
                        card.className = `passage-card ${mathSection.tier === 'premium' ? 'premium' : ''}`;
                        const attemptCount = mathSection.attempt_count || 0;
                        const attemptText = attemptCount > 0 ? ` | ${attemptCount} attempt${attemptCount !== 1 ? 's' : ''}` : '';
                        
                        let attemptSummaryHTML = '';
                        if (mathSection.attempt_summary && attemptCount > 0) {
                            const summary = mathSection.attempt_summary;
                            attemptSummaryHTML = `
                                <div style="background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-top: 10px; font-size: 13px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                        <span style="color: #666;"><strong>Best Score:</strong></span>
                                        <span style="color: #3498DB; font-weight: bold;">${summary.best_score}%</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                        <span style="color: #666;"><strong>Latest Score:</strong></span>
                                        <span style="color: #000; font-weight: bold;">${summary.latest_score}%</span>
                                    </div>
                                    ${summary.recent_attempts && summary.recent_attempts.length > 0 ? `
                                        <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #e0e0e0;">
                                            <div style="color: #666; margin-bottom: 6px; font-size: 12px;"><strong>Recent Attempts:</strong></div>
                                            ${summary.recent_attempts.map((attempt, idx) => {
                                                const date = new Date(attempt.completed_at);
                                                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                                                return `
                                                    <div style="display: flex; justify-content: space-between; font-size: 11px; color: #666; margin-bottom: 4px;">
                                                        <span>${dateStr}</span>
                                                        <span style="font-weight: bold; color: #000;">${attempt.score}%</span>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    ` : ''}
                                </div>
                            `;
                        }
                        
                        const isPremium = mathSection.tier === 'premium';
                        const hasAccess = !isPremium || (currentUser && (currentUser.is_premium || currentUser.has_active_subscription));
                        card.innerHTML = `
                            <h3>${mathSection.title} ${isPremium ? '<span class="premium-badge">PREMIUM</span> <span class="premium-lock"></span>' : ''}</h3>
                            ${attemptText ? `<p>${attemptText}</p>` : ''}
                            ${attemptSummaryHTML}
                            ${attemptCount > 0 && authToken ? `<button class="btn btn-secondary" onclick="event.stopPropagation(); showMathSectionAttemptHistory('${mathSection.id}')" style="margin-top: 10px; font-size: 12px; padding: 6px 12px; width: 100%;">View Full Attempt History</button>` : ''}
                        `;
                        card.addEventListener('click', (e) => {
                            // Don't trigger if clicking on a button
                            if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                                return;
                            }
                            console.log('Math section card clicked:', mathSection.id, mathSection.title);
                            e.preventDefault();
                            e.stopPropagation();
                            openMathSection(mathSection.id);
                        });
                        card.style.cursor = 'pointer';
                        sectionsContainer.appendChild(card);
                        });
                        headerDiv.appendChild(sectionsContainer);
                    });
                    
                    // Display sections without headers
                    if (sectionsWithoutHeader.length > 0) {
                        sectionsWithoutHeader.forEach(mathSection => {
                            const card = document.createElement('div');
                            card.className = `passage-card ${mathSection.tier === 'premium' ? 'premium' : ''}`;
                            const attemptCount = mathSection.attempt_count || 0;
                            const attemptText = attemptCount > 0 ? ` | ${attemptCount} attempt${attemptCount !== 1 ? 's' : ''}` : '';
                            
                            let attemptSummaryHTML = '';
                            if (mathSection.attempt_summary && attemptCount > 0) {
                                const summary = mathSection.attempt_summary;
                                attemptSummaryHTML = `
                                    <div style="background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-top: 10px; font-size: 13px;">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: #666;"><strong>Best Score:</strong></span>
                                            <span style="color: #3498DB; font-weight: bold;">${summary.best_score}%</span>
                                        </div>
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: #666;"><strong>Latest Score:</strong></span>
                                            <span style="color: #000; font-weight: bold;">${summary.latest_score}%</span>
                                        </div>
                                        ${summary.recent_attempts && summary.recent_attempts.length > 0 ? `
                                            <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #e0e0e0;">
                                                <div style="color: #666; margin-bottom: 6px; font-size: 12px;"><strong>Recent Attempts:</strong></div>
                                                ${summary.recent_attempts.map((attempt, idx) => {
                                                    const date = new Date(attempt.completed_at);
                                                    const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                                                    return `
                                                        <div style="display: flex; justify-content: space-between; font-size: 11px; color: #666; margin-bottom: 4px;">
                                                            <span>${dateStr}</span>
                                                            <span style="font-weight: bold; color: #000;">${attempt.score}%</span>
                                                        </div>
                                                    `;
                                                }).join('')}
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            }
                            
                            const isPremium = mathSection.tier === 'premium';
                            card.innerHTML = `
                                <h3>${mathSection.title} ${isPremium ? '<span class="premium-badge">PREMIUM</span> <span class="premium-lock"></span>' : ''}</h3>
                                ${attemptText ? `<p>${attemptText}</p>` : ''}
                                ${attemptSummaryHTML}
                                ${attemptCount > 0 && authToken ? `<button class="btn btn-secondary" onclick="event.stopPropagation(); showMathSectionAttemptHistory('${mathSection.id}')" style="margin-top: 10px; font-size: 12px; padding: 6px 12px; width: 100%;">View Full Attempt History</button>` : ''}
                            `;
                            card.addEventListener('click', (e) => {
                                // Don't trigger if clicking on a button
                                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                                    return;
                                }
                                console.log('Math section card clicked (no header):', mathSection.id, mathSection.title);
                                e.preventDefault();
                                e.stopPropagation();
                                openMathSection(mathSection.id);
                            });
                            card.style.cursor = 'pointer';
                            mathSectionsList.appendChild(card);
                        });
                    }
                } else {
                    console.log('No math sections found in response');
                    mathSectionsList.innerHTML = '<p style="color: #666; font-style: italic;">No math sections available yet.</p>';
                }
            } catch (error) {
                console.error('Failed to load math sections:', error);
                console.error('Error details:', error.message, error.stack);
                const mathSectionsList = document.getElementById('mathSectionsList');
                if (mathSectionsList) {
                    mathSectionsList.innerHTML = `<p style="color: #999;">Error loading math sections: ${error.message}. Please refresh the page.</p>`;
                }
            }
        }
        
        async function loadPassages() {
            try {
                console.log('Loading passages...');
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`${API_BASE}/passages/`, {headers});
                if (!response.ok) {
                    console.error('Failed to fetch passages:', response.status, response.statusText);
                    const passagesList = document.getElementById('passagesList');
                    if (passagesList) {
                        passagesList.innerHTML = '<p style="color: #999;">Failed to load passages. Please try again.</p>';
                    }
                    return;
                }
                
                const data = await response.json();
                console.log('Passages data received:', data);
                
                const passagesList = document.getElementById('passagesList');
                if (!passagesList) {
                    console.error('passagesList element not found!');
                    return;
                }
                passagesList.innerHTML = '';
                
                // Handle both paginated (data.results) and non-paginated (data is array) responses
                let passages = Array.isArray(data) ? data : (data.results || []);
                console.log('Processing passages:', passages.length, 'passages');
                console.log('First passage sample:', passages[0]);
                
                // Filter to only intro passages if user is not logged in
                if (!currentUser) {
                    passages = passages.filter(passage => isIntroLesson(passage.title));
                }
                
                if (passages && passages.length > 0) {
                    // Group passages by header
                    const passagesByHeader = {};
                    const passagesWithoutHeader = [];
                    
                    passages.forEach(passage => {
                        if (passage.header && passage.header.id) {
                            const headerId = passage.header.id;
                            if (!passagesByHeader[headerId]) {
                                passagesByHeader[headerId] = {
                                    header: passage.header,
                                    passages: []
                                };
                            }
                            passagesByHeader[headerId].passages.push(passage);
                        } else {
                            passagesWithoutHeader.push(passage);
                        }
                    });
                    
                    // Sort headers by display_order (higher first)
                    const sortedHeaders = Object.values(passagesByHeader).sort((a, b) => 
                        (b.header.display_order || 0) - (a.header.display_order || 0)
                    );
                    
                    // Sort passages within each header by order_within_header (higher first)
                    sortedHeaders.forEach(headerGroup => {
                        headerGroup.passages.sort((a, b) => 
                            (b.order_within_header || 0) - (a.order_within_header || 0)
                        );
                    });
                    
                    // Display headers with their passages
                    sortedHeaders.forEach(headerGroup => {
                        // Header section
                        const headerDiv = document.createElement('div');
                        headerDiv.style.cssText = 'margin-bottom: 30px;';
                        headerDiv.innerHTML = `
                            <h3 style="color: #3498DB; font-size: 24px; font-weight: 600; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #3498DB;">
                                ${escapeHtml(headerGroup.header.title)}
                            </h3>
                        `;
                        passagesList.appendChild(headerDiv);
                        
                        // Passages under this header
                        const passagesContainer = document.createElement('div');
                        passagesContainer.style.cssText = 'margin-left: 20px;';
                        headerGroup.passages.forEach(passage => {
                            const card = document.createElement('div');
                            card.className = `passage-card ${passage.tier === 'premium' ? 'premium' : ''}`;
                            card.style.cssText = 'margin-bottom: 15px;';
                            const attemptCount = passage.attempt_count || 0;
                            const attemptText = attemptCount > 0 ? ` | ${attemptCount} attempt${attemptCount !== 1 ? 's' : ''}` : '';
                            
                            let attemptSummaryHTML = '';
                            if (passage.attempt_summary && attemptCount > 0) {
                                const summary = passage.attempt_summary;
                                attemptSummaryHTML = `
                                    <div style="background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-top: 10px; font-size: 13px;">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: #666;"><strong>Best Score:</strong></span>
                                            <span style="color: #3498DB; font-weight: bold;">${summary.best_score}%</span>
                                        </div>
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: #666;"><strong>Latest Score:</strong></span>
                                            <span style="color: #000; font-weight: bold;">${summary.latest_score}%</span>
                                        </div>
                                        ${summary.recent_attempts && summary.recent_attempts.length > 0 ? `
                                            <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #e0e0e0;">
                                                <div style="color: #666; margin-bottom: 6px; font-size: 12px;"><strong>Recent Attempts:</strong></div>
                                                ${summary.recent_attempts.map((attempt, idx) => {
                                                    const date = new Date(attempt.completed_at);
                                                    const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                                                    return `
                                                        <div style="display: flex; justify-content: space-between; font-size: 11px; color: #666; margin-bottom: 4px;">
                                                            <span>${dateStr}</span>
                                                            <span style="font-weight: bold; color: #000;">${attempt.score}%</span>
                                                        </div>
                                                    `;
                                                }).join('')}
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            }
                            
                            const isPremium = passage.tier === 'premium';
                            card.setAttribute('data-passage-id', passage.id);
                            card.innerHTML = `
                                <h3>${escapeHtml(passage.title)} ${isPremium ? '<span class="premium-badge">PREMIUM</span> <span class="premium-lock"></span>' : ''}</h3>
                                ${attemptText ? `<p>${attemptText}</p>` : ''}
                                ${attemptSummaryHTML}
                                ${attemptCount > 0 && authToken ? `<button class="btn btn-secondary" onclick="event.stopPropagation(); event.preventDefault(); showAttemptHistory('${passage.id}'); return false;" style="margin-top: 10px; font-size: 12px; padding: 6px 12px; width: 100%;">View Full Attempt History</button>` : ''}
                            `;
                            card.addEventListener('click', (e) => {
                                // Don't trigger if clicking on a button
                                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                                    return;
                                }
                                console.log('Passage card clicked:', passage.id, passage.title);
                                e.preventDefault();
                                e.stopPropagation();
                                openPassage(passage.id);
                            });
                            card.style.cursor = 'pointer';
                            passagesContainer.appendChild(card);
                        });
                        headerDiv.appendChild(passagesContainer);
                    });
                    
                    // Display passages without headers
                    if (passagesWithoutHeader.length > 0) {
                        passagesWithoutHeader.forEach(passage => {
                            const card = document.createElement('div');
                            card.className = `passage-card ${passage.tier === 'premium' ? 'premium' : ''}`;
                            card.style.cssText = 'margin-bottom: 15px;';
                            const attemptCount = passage.attempt_count || 0;
                            const attemptText = attemptCount > 0 ? ` | ${attemptCount} attempt${attemptCount !== 1 ? 's' : ''}` : '';
                            
                            let attemptSummaryHTML = '';
                            if (passage.attempt_summary && attemptCount > 0) {
                                const summary = passage.attempt_summary;
                                attemptSummaryHTML = `
                                    <div style="background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-top: 10px; font-size: 13px;">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: #666;"><strong>Best Score:</strong></span>
                                            <span style="color: #3498DB; font-weight: bold;">${summary.best_score}%</span>
                                        </div>
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: #666;"><strong>Latest Score:</strong></span>
                                            <span style="color: #000; font-weight: bold;">${summary.latest_score}%</span>
                                        </div>
                                        ${summary.recent_attempts && summary.recent_attempts.length > 0 ? `
                                            <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #e0e0e0;">
                                                <div style="color: #666; margin-bottom: 6px; font-size: 12px;"><strong>Recent Attempts:</strong></div>
                                                ${summary.recent_attempts.map((attempt, idx) => {
                                                    const date = new Date(attempt.completed_at);
                                                    const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                                                    return `
                                                        <div style="display: flex; justify-content: space-between; font-size: 11px; color: #666; margin-bottom: 4px;">
                                                            <span>${dateStr}</span>
                                                            <span style="font-weight: bold; color: #000;">${attempt.score}%</span>
                                                        </div>
                                                    `;
                                                }).join('')}
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            }
                            
                            const isPremium = passage.tier === 'premium';
                            card.setAttribute('data-passage-id', passage.id);
                            card.innerHTML = `
                                <h3>${escapeHtml(passage.title)} ${isPremium ? '<span class="premium-badge">PREMIUM</span> <span class="premium-lock"></span>' : ''}</h3>
                                ${attemptText ? `<p>${attemptText}</p>` : ''}
                                ${attemptSummaryHTML}
                                ${attemptCount > 0 && authToken ? `<button class="btn btn-secondary" onclick="event.stopPropagation(); event.preventDefault(); showAttemptHistory('${passage.id}'); return false;" style="margin-top: 10px; font-size: 12px; padding: 6px 12px; width: 100%;">View Full Attempt History</button>` : ''}
                            `;
                            card.addEventListener('click', (e) => {
                                // Don't trigger if clicking on a button
                                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                                    return;
                                }
                                console.log('Passage card clicked (no header):', passage.id, passage.title);
                                e.preventDefault();
                                e.stopPropagation();
                                openPassage(passage.id);
                            });
                            card.style.cursor = 'pointer';
                            passagesList.appendChild(card);
                        });
                    }
                    
                    // Add CTA banner for non-logged-in users
                    if (!currentUser) {
                        const ctaBanner = document.createElement('div');
                        ctaBanner.style.cssText = 'background: linear-gradient(135deg, #3498DB 0%, #2980b9 100%); color: white; padding: 20px; border-radius: 12px; margin-top: 25px; text-align: center;';
                        ctaBanner.innerHTML = `
                            <h4 style="margin: 0 0 8px 0; font-size: 18px;">Want more passages?</h4>
                            <p style="margin: 0 0 15px 0; opacity: 0.9;">Create a (free) account so that we can make your personalized study plan and start to track your improvement!</p>
                            <button onclick="showLoginModal()" style="background: white; color: #3498DB; border: none; padding: 10px 25px; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">Sign Up Free</button>
                        `;
                        passagesList.appendChild(ctaBanner);
                    }
                } else {
                    console.log('No passages found in response');
                    if (!currentUser) {
                        passagesList.innerHTML = '<p style="color: #666; font-style: italic;">Log in to access all passages.</p>';
                    } else {
                    passagesList.innerHTML = '<p style="color: #666; font-style: italic;">No passages available yet.</p>';
                    }
                }
            } catch (error) {
                console.error('Failed to load passages:', error);
                console.error('Error details:', error.message, error.stack);
                const passagesList = document.getElementById('passagesList');
                if (passagesList) {
                    passagesList.innerHTML = `<p style="color: #999;">Error loading passages: ${error.message}. Please refresh the page.</p>`;
                }
            }
        }
        
        let currentPassageId = null;
        let currentPassageData = null;
        let currentLessonId = null;
        let currentLessonData = null;
        let currentWritingSectionId = null;
        let currentMathSectionId = null;
        let currentMathSectionData = null;
        let currentWritingSectionData = null;
        let userAnswers = {};
        
        async function openLesson(lessonId, lessonTitle = null) {
            try {
                // If we know the lesson title, check if it's an intro lesson
                // Intro lessons are accessible without login
                if (lessonTitle && !isIntroLesson(lessonTitle) && !currentUser) {
                    showLoginRequiredModal();
                    return;
                }
                
                currentLessonId = lessonId;
                // Clear other detail view states
                currentPassageId = null;
                currentPassageData = null;
                currentMathSectionId = null;
                currentMathSectionData = null;
                currentWritingSectionId = null;
                currentWritingSectionData = null;
                userAnswers = {};
                
                // Update URL hash (replaceState doesn't trigger hashchange, which is what we want)
                window.history.replaceState(null, '', window.location.pathname + `#lesson/${lessonId}`);
                
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                // Fetch lesson detail
                const lessonResponse = await fetch(`${API_BASE}/lessons/${lessonId}`, {headers});
                if (lessonResponse.status === 403) {
                    // Try to get lesson data anyway for preview
                    const previewResponse = await fetch(`${API_BASE}/lessons/${lessonId}`, {});
                    if (previewResponse.ok) {
                        const lessonData = await previewResponse.json();
                        displayLessonPreview(lessonData, 'lesson');
                    } else {
                        // Show upgrade modal instead of alert
                        showUpgradeModal('lesson');
                    }
                    return;
                }
                
                if (!lessonResponse.ok) {
                    alert('Failed to load lesson. Please try again.');
                    return;
                }
                
                const lessonData = await lessonResponse.json();
                currentLessonData = lessonData;
                
                // Check if user needs to login (non-intro lessons require login)
                if (!currentUser && !isIntroLesson(lessonData.title)) {
                    showLoginRequiredModal();
                    return;
                }
                
                // Check if premium and user doesn't have access
                if (lessonData.tier === 'premium' && (!currentUser || (!currentUser.is_premium && !currentUser.has_active_subscription))) {
                    displayLessonPreview(lessonData, 'lesson');
                } else {
                    // Display lesson
                    displayLesson(lessonData);
                }
                
            } catch (error) {
                console.error('Failed to open lesson:', error);
                alert('Network error. Please try again.');
            }
        }
        
        function displayLesson(lesson) {
            // Hide all category content containers (which contain the list sections)
            document.querySelectorAll('.category-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Hide all list sections individually as well
            const passagesListSection = document.getElementById('passagesListSection');
            const readingLessonsListSection = document.getElementById('readingLessonsListSection');
            const writingSectionsListSection = document.getElementById('writingSectionsListSection');
            const writingLessonsListSection = document.getElementById('writingLessonsListSection');
            const mathSectionsListSection = document.getElementById('mathSectionsListSection');
            const mathLessonsListSection = document.getElementById('mathLessonsListSection');
            const passageDetailSection = document.getElementById('passageDetailSection');
            
            if (passagesListSection) passagesListSection.style.display = 'none';
            if (readingLessonsListSection) readingLessonsListSection.style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // if (writingSectionsListSection) writingSectionsListSection.style.display = 'none';
            if (writingLessonsListSection) writingLessonsListSection.style.display = 'none';
            if (mathSectionsListSection) mathSectionsListSection.style.display = 'none';
            if (mathLessonsListSection) mathLessonsListSection.style.display = 'none';
            if (passageDetailSection) passageDetailSection.style.display = 'block';
            
            // Hide word of the day when viewing lessons
            const wordOfDay = document.getElementById('wordOfDay');
            if (wordOfDay) wordOfDay.style.display = 'none';
            
            // Clear attempt history button
            document.getElementById('attemptHistoryButtonContainer').innerHTML = '';
            
            // Build a map of questions by chunk_index to their assets and question objects
            const questionAssetsMap = {};
            const questionMap = {}; // Map chunk_index to question object
            if (lesson.questions) {
                lesson.questions.forEach(question => {
                    questionMap[question.chunk_index] = question;
                    if (question.assets && question.assets.length > 0) {
                        questionAssetsMap[question.chunk_index] = question.assets;
                        console.log(`Question at chunk ${question.chunk_index} has ${question.assets.length} asset(s) from question.assets`);
                    }
                });
            }
            
            // Also check chunks directly for assets (in case they're in the JSON but not linked yet)
            if (lesson.chunks) {
                lesson.chunks.forEach((chunk, chunkIdx) => {
                    if (chunk.type === 'question' && chunk.assets && chunk.assets.length > 0) {
                        // If we don't have assets from question object, use chunk assets
                        if (!questionAssetsMap[chunkIdx]) {
                            // Map asset_ids to full asset objects from lesson.assets
                            const chunkAssetObjects = [];
                            chunk.assets.forEach(assetId => {
                                // Find the asset in lesson.assets by asset_id
                                const asset = lesson.assets?.find(a => a.asset_id === assetId);
                                if (asset) {
                                    chunkAssetObjects.push(asset);
                                } else {
                                    console.warn(`Asset ${assetId} referenced in chunk ${chunkIdx} but not found in lesson.assets`);
                                }
                            });
                            if (chunkAssetObjects.length > 0) {
                                questionAssetsMap[chunkIdx] = chunkAssetObjects;
                                console.log(`Found ${chunkAssetObjects.length} asset(s) for chunk ${chunkIdx} from chunk.assets`);
                            }
                        }
                    }
                });
            }
            
            // If we still don't have assets but lesson.assets exists, try to match by question order
            // This is a fallback for cases where assets exist but aren't linked
            if (lesson.assets && lesson.assets.length > 0 && Object.keys(questionAssetsMap).length === 0) {
                console.warn('No assets linked to questions, but lesson has assets. Attempting to match by question order...');
                // For now, just log - we'd need more context to match properly
                // But at least show that assets exist
                console.log(`Lesson has ${lesson.assets.length} asset(s) available but not linked to questions`);
            }
            
            // Debug logging
            console.log('Lesson assets:', lesson.assets);
            console.log('Lesson lesson_id:', lesson.lesson_id);
            console.log('Question assets map:', questionAssetsMap);
            console.log('Lesson chunks with assets:', lesson.chunks?.filter(c => c.type === 'question' && c.assets));
            
            // Check for sentinels in chunks
            if (lesson.chunks) {
                lesson.chunks.forEach((chunk, idx) => {
                    if (chunk.text && chunk.text.includes('[[Diagram')) {
                        console.log(`Chunk ${idx} (type: ${chunk.type}) contains sentinel:`, chunk.text.substring(0, 200));
                    }
                });
            }
            
            // Log each question's assets
            if (lesson.questions) {
                lesson.questions.forEach(q => {
                    if (q.assets && q.assets.length > 0) {
                        console.log(`Question at chunk ${q.chunk_index} has assets:`, q.assets);
                    }
                });
            }
            
            // Split chunks into pages based on page_break markers
            const pages = [];
            let currentPage = [];
            
            if (lesson.chunks) {
                lesson.chunks.forEach((chunk, chunkIdx) => {
                    if (chunk.type === 'page_break') {
                        // Save current page and start a new one
                        if (currentPage.length > 0) {
                            pages.push(currentPage);
                            currentPage = [];
                        }
                    } else {
                        currentPage.push({chunk, chunkIdx});
                    }
                });
                // Add the last page if it has content
                if (currentPage.length > 0) {
                    pages.push(currentPage);
                }
            }
            
            // If no page breaks, treat entire lesson as one page
            if (pages.length === 0 && lesson.chunks) {
                const allChunks = lesson.chunks.map((chunk, idx) => ({chunk, chunkIdx: idx}));
                pages.push(allChunks);
            }
            
            // Store pages in lesson data for navigation
            lesson.pages = pages;
            lesson.currentPageIndex = 0;
            
            // Render the first page
            renderLessonPage(lesson, 0, questionAssetsMap, questionMap);
        }
        
        function renderLessonPage(lesson, pageIndex, questionAssetsMap, questionMap) {
            const pages = lesson.pages || [];
            if (pageIndex < 0 || pageIndex >= pages.length) {
                console.error('Invalid page index:', pageIndex);
                return;
            }
            
            const currentPage = pages[pageIndex];
            const totalPages = pages.length;
            
            // Render lesson content from chunks for this page
            let contentHTML = `<h2 style="color: #3498DB; margin-bottom: 15px;">${escapeHtml(lesson.title)}</h2>`;
            
            // Add pagination controls
            if (totalPages > 1) {
                const paginationBg = document.body.classList.contains('dark-mode') ? 'var(--bg-secondary)' : '#f5f5f5';
                const paginationText = document.body.classList.contains('dark-mode') ? 'var(--text-primary)' : '#333';
                contentHTML += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding: 10px; background: ${paginationBg}; border-radius: 8px; border: 1px solid var(--border-color);">`;
                contentHTML += `<button id="prevPageBtn" onclick="navigateLessonPage(${pageIndex - 1})" ${pageIndex === 0 ? 'disabled style="opacity: 0.5; cursor: not-allowed; padding: 8px 16px; background: var(--bg-tertiary); color: var(--text-secondary); border: none; border-radius: 4px;"' : 'style="padding: 8px 16px; background: var(--accent-color); color: white; border: none; border-radius: 4px; cursor: pointer;"'}>&larr; Previous</button>`;
                contentHTML += `<span style="font-weight: bold; color: ${paginationText};">Page ${pageIndex + 1} of ${totalPages}</span>`;
                contentHTML += `<button id="nextPageBtn" onclick="navigateLessonPage(${pageIndex + 1})" ${pageIndex === totalPages - 1 ? 'disabled style="opacity: 0.5; cursor: not-allowed; padding: 8px 16px; background: var(--bg-tertiary); color: var(--text-secondary); border: none; border-radius: 4px;"' : 'style="padding: 8px 16px; background: var(--accent-color); color: white; border: none; border-radius: 4px; cursor: pointer;"'}>Next &rarr;</button>`;
                contentHTML += `</div>`;
            }
            
            contentHTML += '<div class="lesson-content" style="max-width: 800px; margin: 0 auto;">';
            
            currentPage.forEach(({chunk, chunkIdx}) => {
                const chunkType = chunk.type;
                
                // Debug: log chunk types to see what we're rendering
                if (chunkIdx === 0 || chunkType === 'side_by_side' || chunkType === 'paragraph') {
                    console.log(`Chunk ${chunkIdx}: type="${chunkType}"`, chunk);
                }
                
                if (chunkType === 'header') {
                    const level = chunk.level || 1;
                    const text = chunk.text || '';
                    const tag = `h${Math.min(level + 1, 6)}`;
                    contentHTML += `<${tag} style="color: #3498DB; margin-top: 20px; margin-bottom: 10px;">${escapeHtml(text)}</${tag}>`;
                } else if (chunkType === 'paragraph') {
                    const chunkText = chunk.text || '';
                    // Debug: log if this paragraph contains a sentinel
                    if (chunkText.includes('[[Diagram')) {
                        console.log(`Paragraph chunk ${chunkIdx} contains sentinel. Text:`, chunkText.substring(0, 200));
                    }
                    let processedText = replaceDiagramSentinels(chunkText, lesson.assets || [], lesson.lesson_id);
                    processedText = replaceUnderlineSentinels(processedText);
                    contentHTML += `<p style="margin-bottom: 15px; line-height: 1.6; color: #000;">${processedText}</p>`;
                } else if (chunkType === 'example') {
                    let processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    processedText = replaceUnderlineSentinels(processedText);
                    contentHTML += `<div style="background: #f0f8ff; border-left: 4px solid #3498DB; padding: 10px 15px; margin: 15px 0; font-style: italic; color: #000;">${processedText}</div>`;
                } else if (chunkType === 'example_correct') {
                    let processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    processedText = replaceUnderlineSentinels(processedText);
                    contentHTML += `<div style="background: #f0fff0; border-left: 4px solid #28a745; padding: 10px 15px; margin: 15px 0; font-style: italic; color: #000;">${processedText}</div>`;
                } else if (chunkType === 'example_incorrect') {
                    let processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    processedText = replaceUnderlineSentinels(processedText);
                    contentHTML += `<div style="background: #fff0f0; border-left: 4px solid #dc3545; padding: 10px 15px; margin: 15px 0; font-style: italic; color: #000;"> ${processedText}</div>`;
                } else if (chunkType === 'rule') {
                    let processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    processedText = replaceUnderlineSentinels(processedText);
                    contentHTML += `<div style="background: #fff9e6; border-left: 4px solid #ffc107; padding: 10px 15px; margin: 15px 0; font-weight: bold; color: #000;">Rule: ${processedText}</div>`;
                } else if (chunkType === 'definition') {
                    let processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    processedText = replaceUnderlineSentinels(processedText);
                    contentHTML += `<div style="margin: 15px 0;"><strong style="color: #3498DB;">${escapeHtml(chunk.term || '')}:</strong> <span style="color: #000;">${processedText}</span></div>`;
                } else if (chunkType === 'list' || chunkType === 'bullet_list') {
                    const items = chunk.items || [];
                    const listType = chunkType === 'bullet_list' ? 'ul' : 'ol';
                    contentHTML += `<${listType} style="margin: 15px 0; padding-left: 30px; color: #000;">`;
                    items.forEach(item => {
                        let processedItem = replaceDiagramSentinels(item, lesson.assets || [], lesson.lesson_id);
                        processedItem = replaceUnderlineSentinels(processedItem);
                        contentHTML += `<li style="margin-bottom: 8px;">${processedItem}</li>`;
                    });
                    contentHTML += `</${listType}>`;
                } else if (chunkType === 'question') {
                    // Get the question object if it exists
                    const questionObj = questionMap[chunkIdx];
                    const questionId = questionObj ? questionObj.id : `chunk_${chunkIdx}`;
                    
                    // Get assets for this question - prefer question-specific assets, but always include lesson assets
                    // Aggregate all available assets so we can find diagrams by asset_id
                    const questionSpecificAssets = questionAssetsMap[chunkIdx] || (questionObj && questionObj.assets) || [];
                    const allLessonAssets = lesson.assets || [];
                    
                    // Combine question-specific and lesson assets (lesson assets as fallback)
                    // Use a Map to deduplicate by asset_id, preferring question-specific assets
                    const assetMap = new Map();
                    // First add all lesson assets
                    allLessonAssets.forEach(asset => {
                        if (asset && asset.asset_id) {
                            assetMap.set(asset.asset_id, asset);
                        }
                    });
                    // Then add question-specific assets (these will override if same asset_id)
                    questionSpecificAssets.forEach(asset => {
                        if (asset && asset.asset_id) {
                            assetMap.set(asset.asset_id, asset);
                        }
                    });
                    const questionAssets = Array.from(assetMap.values());
                    
                    const lessonId = lesson.lesson_id || '';
                    
                    // Debug logging for assets
                    console.log(`Question ${questionId} - Question-specific assets: ${questionSpecificAssets.length}, Lesson assets: ${allLessonAssets.length}, Combined: ${questionAssets.length}`);
                    if (allLessonAssets.length > 0) {
                        console.log(`Available lesson asset IDs:`, allLessonAssets.map(a => a.asset_id));
                    }
                    
                    // Render question directly from chunk (questions are embedded in chunks)
                    contentHTML += `<div class="question-card" style="margin: 20px 0; padding: 15px; border: 2px solid #3498DB; border-radius: 8px; background: #f9f9f9;">`;
                    
                    // Handle both JSON blocks (from questionObj.text) and plain text (from chunk.prompt)
                    let processedPrompt = '';
                    if (questionObj && Array.isArray(questionObj.text)) {
                        // New format: array of blocks
                        processedPrompt = formatLessonPrompt(questionObj.text, questionAssets, lessonId);
                    } else if (chunk.prompt) {
                        // Old format: plain text from chunk
                        processedPrompt = replaceDiagramSentinels(chunk.prompt, questionAssets, lessonId);
                        processedPrompt = replaceUnderlineSentinels(processedPrompt);
                        processedPrompt = `<h4 style="color: #000; margin-bottom: 10px;">${processedPrompt}</h4>`;
                    } else {
                        processedPrompt = '<h4 style="color: #000; margin-bottom: 10px;">[No question text]</h4>';
                    }
                    contentHTML += processedPrompt;
                    
                    // Diagrams should ONLY appear if embedded in the prompt blocks themselves
                    // (via side-by-side blocks or sentinels). We do NOT show linked assets
                    // separately to avoid artifacts. If a question needs a diagram, it must
                    // be added to the prompt blocks using the admin editor.
                    
                    // Get choices - prefer questionObj.options (from database, can be edited in admin), fallback to chunk.choices (from JSON)
                    let choices = [];
                    if (questionObj && questionObj.options && questionObj.options.length > 0) {
                        // Use options from database (can include diagrams edited in admin)
                        choices = questionObj.options.map(opt => opt.text || opt);
                        console.log(`Using questionObj.options for question ${questionId}, ${choices.length} options`);
                    } else if (chunk.choices && chunk.choices.length > 0) {
                        // Fallback to chunk.choices from JSON
                        choices = chunk.choices;
                        console.log(`Using chunk.choices for question ${questionId}, ${choices.length} options`);
                    }
                    
                    contentHTML += `<div class="options-container">`;
                    choices.forEach((choice, idx) => {
                        // Handle both string and object format for choices
                        let choiceText = typeof choice === 'string' ? choice : (choice.text || choice);
                        
                        // Process choice text for diagrams (if it contains sentinels)
                        let processedChoice = choiceText;
                        if (typeof choiceText === 'string' && choiceText.includes('[[Diagram')) {
                            // Process diagram sentinels in choice text using question-specific or lesson assets
                            console.log(`Processing diagram in choice ${idx}, text:`, choiceText, 'assets:', questionAssets.length, 'lessonId:', lessonId);
                            console.log('Available assets:', questionAssets);
                            processedChoice = replaceDiagramSentinels(choiceText, questionAssets, lessonId);
                            console.log(`Processed choice ${idx}:`, processedChoice);
                            // If still contains sentinel after processing, log warning (we already aggregated all assets)
                            if (processedChoice.includes('[[Diagram')) {
                                console.warn(`Diagram sentinel not replaced in choice ${idx} after trying all aggregated assets. Text: ${choiceText}`);
                                console.warn(`Available asset IDs:`, questionAssets.map(a => a.asset_id));
                            }
                        } else {
                            // Escape HTML if no diagrams
                            processedChoice = escapeHtml(choiceText);
                        }
                        
                        contentHTML += `
                            <div class="option" onclick="selectOption('${questionId}', ${idx})">
                                <input type="radio" name="question_${questionId}" value="${idx}" id="opt_${questionId}_${idx}">
                                <label class="option-label" for="opt_${questionId}_${idx}" style="color: #000; cursor: pointer; display: block; padding: 8px; border-radius: 4px; transition: background 0.2s;">
                                    ${String.fromCharCode(65 + idx)}. ${processedChoice}
                                </label>
                            </div>
                        `;
                    });
                    contentHTML += `</div>`;
                    
                    // Add explanation container (hidden initially, shown after selection)
                    const explanation = questionObj ? questionObj.explanation : null;
                    if (explanation) {
                        let processedExplanation = '';
                        if (Array.isArray(explanation)) {
                            // New format: array of blocks (use formatMathExplanation which handles both)
                            // formatMathExplanation will use currentLessonData.assets internally for side_by_side blocks
                            processedExplanation = formatMathExplanation(explanation, false);
                            // Also process any remaining diagram sentinels in the explanation text
                            processedExplanation = replaceDiagramSentinels(processedExplanation, lesson.assets || [], lesson.lesson_id);
                        } else if (typeof explanation === 'string') {
                            // Old format: plain text
                            processedExplanation = replaceDiagramSentinels(explanation, lesson.assets || [], lesson.lesson_id);
                            processedExplanation = replaceUnderlineSentinels(processedExplanation);
                        }
                        const explanationBg = document.body.classList.contains('dark-mode') ? 'rgba(52, 152, 219, 0.15)' : '#f0f8ff';
                        const explanationColor = document.body.classList.contains('dark-mode') ? 'var(--text-primary)' : '#000';
                        contentHTML += `<div id="explanation_${questionId}" style="display: none; margin-top: 15px; padding: 12px; background: ${explanationBg}; border-left: 4px solid var(--accent-color); border-radius: 4px; color: ${explanationColor};">
                            <strong>Explanation:</strong> ${processedExplanation}
                        </div>`;
                    }
                    
                    contentHTML += `</div>`;
                } else if (chunkType === 'note') {
                    const processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    contentHTML += `<div style="background: #e3f2fd; border-left: 4px solid #2196F3; padding: 10px 15px; margin: 15px 0; color: #000;"> Note: ${processedText}</div>`;
                } else if (chunkType === 'warning') {
                    const processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    contentHTML += `<div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 10px 15px; margin: 15px 0; color: #000;"><strong>Note:</strong> ${processedText}</div>`;
                } else if (chunkType === 'summary') {
                    const processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    contentHTML += `<div style="background: #f0f0f0; border: 2px solid #666; padding: 15px; margin: 20px 0; border-radius: 8px; color: #000;"><strong>Summary:</strong> ${processedText}</div>`;
                } else if (chunkType === 'side_by_side') {
                    // Side-by-side layout: supports multiple rows (explanation/diagram pairs)
                    console.log('Rendering side_by_side chunk:', chunk);
                    
                    // Support both new format (rows array) and legacy format (single explanation/diagram)
                    let rows = [];
                    if (chunk.rows && Array.isArray(chunk.rows)) {
                        // New format: multiple rows
                        rows = chunk.rows;
                    } else if (chunk.explanation || chunk.diagram_asset_id) {
                        // Legacy format: single row
                        rows = [{
                            explanation: chunk.explanation || '',
                            diagram_asset_id: chunk.diagram_asset_id || ''
                        }];
                    }
                    
                    // Render each row
                    rows.forEach((row, rowIndex) => {
                        const explanation = row.explanation || '';
                        const diagramAssetId = row.diagram_asset_id || '';
                        const rightText = row.right_text || '';
                        const rightTextFormatting = row.right_text_formatting !== false; // Default to true
                        
                        // Escape and process explanation text (handle underlines)
                        let processedExplanation = escapeHtml(explanation);
                        processedExplanation = replaceUnderlineSentinels(processedExplanation);
                        
                        // Determine right side content: diagram or text
                        let rightSideHtml = '';
                        
                        if (diagramAssetId) {
                            // Use diagram
                            if (lesson.assets) {
                                const diagramAsset = lesson.assets.find(asset => asset.asset_id === diagramAssetId);
                                if (diagramAsset) {
                                    let imageUrl = diagramAsset.s3_url || diagramAsset.url || '';
                                    if (imageUrl) {
                                        imageUrl = imageUrl.trim().replace(/[: ]+$/, '');
                                        if (!/\.(png|jpg|jpeg|gif|svg|webp)$/i.test(imageUrl)) {
                                            if (!imageUrl.includes('.')) {
                                                imageUrl += '.png';
                                            }
                                        }
                                        rightSideHtml = `<img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(diagramAssetId)}" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: block;" onerror="console.error('Failed to load diagram:', this.src); this.style.display='none';" />`;
                                    } else if (lesson.lesson_id) {
                                        // Fallback: construct URL
                                        const constructedUrl = `https://keuvi.s3.amazonaws.com/lessons/${lesson.lesson_id}/${diagramAssetId}.png`;
                                        rightSideHtml = `<img src="${escapeHtml(constructedUrl)}" alt="${escapeHtml(diagramAssetId)}" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: block;" onerror="console.error('Failed to load diagram:', this.src); this.style.display='none';" />`;
                                    }
                                } else if (lesson.lesson_id) {
                                    // Asset not found in list, try constructing URL
                                    const constructedUrl = `https://keuvi.s3.amazonaws.com/lessons/${lesson.lesson_id}/${diagramAssetId}.png`;
                                    rightSideHtml = `<img src="${escapeHtml(constructedUrl)}" alt="${escapeHtml(diagramAssetId)}" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: block;" onerror="console.error('Failed to load diagram:', this.src); this.style.display='none';" />`;
                                }
                            }
                            
                            if (!rightSideHtml) {
                                rightSideHtml = `<span style="color: #999; font-style: italic;">[Diagram ${escapeHtml(diagramAssetId)} not found]</span>`;
                            }
                        } else if (rightText) {
                            // Use formatted text
                            let processedRightText = escapeHtml(rightText);
                            if (rightTextFormatting) {
                                // Process bold: *text* -> <strong>text</strong>
                                processedRightText = processedRightText.replace(/\*([^*]+?)\*/g, '<strong>$1</strong>');
                                // Process italic: _text_ -> <em>text</em>
                                processedRightText = processedRightText.replace(/_([^_]+?)_/g, '<em>$1</em>');
                            }
                            rightSideHtml = `<div style="line-height: 1.6; color: var(--text-primary);">${processedRightText}</div>`;
                        }
                        
                        // Create side-by-side layout using flexbox for this row
                        const marginTop = rowIndex > 0 ? '30px' : '20px';
                        contentHTML += `<div style="display: flex; flex-direction: row; gap: 20px; margin-top: ${marginTop}; margin-bottom: 20px; align-items: flex-start; flex-wrap: wrap;">
                            <div style="flex: 1 1 45%; min-width: 250px;">
                                <div style="line-height: 1.6; color: var(--text-primary);">${processedExplanation}</div>
                            </div>
                            <div style="flex: 1 1 45%; min-width: 250px;">
                                ${rightSideHtml || '<span style="color: var(--text-secondary); font-style: italic;">[No content]</span>'}
                            </div>
                        </div>`;
                    });
                }
            });
            
            contentHTML += '</div>';
            
            document.getElementById('passageContent').innerHTML = contentHTML;
            
            // Adjust font size after content is loaded
            setTimeout(adjustReaderFont, 100);
            
            // Show submit section for lessons (questions are inline but can be answered)
            document.getElementById('questionsContainer').innerHTML = '';
            
            // Check if there are questions on the CURRENT page (not just anywhere in the lesson)
            let hasQuestionsOnCurrentPage = false;
            if (lesson.questions && lesson.questions.length > 0 && pages && pages.length > 0 && pageIndex >= 0 && pageIndex < pages.length) {
                const currentPage = pages[pageIndex];
                const currentPageChunkIndices = new Set();
                currentPage.forEach(({chunkIdx}) => {
                    currentPageChunkIndices.add(chunkIdx);
                });
                
                // Check if any question's chunk_index is on the current page
                hasQuestionsOnCurrentPage = lesson.questions.some(q => 
                    q.chunk_index !== undefined && currentPageChunkIndices.has(q.chunk_index)
                );
            }
            
            if (hasQuestionsOnCurrentPage) {
                document.getElementById('submitSection').style.display = 'block';
            } else {
                document.getElementById('submitSection').style.display = 'none';
            }
            document.getElementById('resultsSection').style.display = 'none';
            
            // Update lesson's current page index
            lesson.currentPageIndex = pageIndex;
        }
        
        function navigateLessonPage(newPageIndex) {
            if (!currentLessonData) {
                console.error('No lesson data available');
                return;
            }
            
            const pages = currentLessonData.pages || [];
            if (newPageIndex < 0 || newPageIndex >= pages.length) {
                console.error('Invalid page index:', newPageIndex);
                return;
            }
            
            // Rebuild question maps (needed for rendering)
            const questionAssetsMap = {};
            const questionMap = {};
            if (currentLessonData.questions) {
                currentLessonData.questions.forEach(question => {
                    questionMap[question.chunk_index] = question;
                    if (question.assets && question.assets.length > 0) {
                        questionAssetsMap[question.chunk_index] = question.assets;
                    }
                });
            }
            
            // Render the new page
            renderLessonPage(currentLessonData, newPageIndex, questionAssetsMap, questionMap);
            
            // Scroll to top of content
            document.getElementById('passageContent').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        function displayLessonPreview(lesson, type) {
            // Hide all list sections, show detail view
            document.getElementById('passagesListSection').style.display = 'none';
            document.getElementById('lessonsListSection').style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // document.getElementById('writingSectionsListSection').style.display = 'none';
            document.getElementById('passageDetailSection').style.display = 'block';
            
            // Hide word of the day when viewing lesson previews
            const wordOfDay = document.getElementById('wordOfDay');
            if (wordOfDay) wordOfDay.style.display = 'none';
            
            // Get first few chunks for preview
            const previewChunks = lesson.chunks ? lesson.chunks.slice(0, 3) : [];
            let contentHTML = `<h2 style="color: #3498DB; margin-bottom: 15px;">${escapeHtml(lesson.title)} <span class="premium-badge">PREMIUM</span> <span class="premium-lock"></span></h2>`;
            contentHTML += '<div class="lesson-content premium-preview-overlay" style="max-width: 800px; margin: 0 auto;">';
            
            previewChunks.forEach((chunk, chunkIdx) => {
                if (chunk.type === 'header') {
                    contentHTML += `<h${chunk.level || 1} style="color: #000; margin-top: 20px; margin-bottom: 10px;">${escapeHtml(chunk.text)}</h${chunk.level || 1}>`;
                } else if (chunk.type === 'paragraph') {
                    contentHTML += `<p style="margin-bottom: 15px; color: #000; line-height: 1.6;">${escapeHtml(chunk.text)}</p>`;
                }
            });
            
            contentHTML += '</div>';
            
            // Add upgrade prompt
            contentHTML += `
                <div class="premium-upgrade-prompt">
                    <h3> Premium Content</h3>
                    <p>This lesson is part of our premium collection. Upgrade to unlock full access to all lessons, passages, and writing sections.</p>
                    ${authToken ? 
                        `<button class="btn" onclick="upgradeToPremium()">Upgrade to Premium - $5/month</button>` :
                        `<button class="btn" onclick="showRegisterModal()">Sign Up to Upgrade</button>`
                    }
                </div>
            `;
            
            document.getElementById('passageContent').innerHTML = contentHTML;
            document.getElementById('questionsContainer').innerHTML = '';
            document.getElementById('submitSection').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'none';
        }
        
        function displayPassagePreview(passage) {
            // Hide passages list, show passage detail
            document.getElementById('passagesListSection').style.display = 'none';
            document.getElementById('lessonsListSection').style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // document.getElementById('writingSectionsListSection').style.display = 'none';
            document.getElementById('passageDetailSection').style.display = 'block';
            
            // Show first ~500 characters with gradient fade
            const previewLength = 500;
            const previewContent = passage.content ? passage.content.substring(0, previewLength) + '...' : '';
            const formattedContent = formatPassageForSAT(previewContent);
            
            document.getElementById('passageContent').innerHTML = `
                <h2 style="color: #3498DB; margin-bottom: 15px;">${escapeHtml(passage.title)} <span class="premium-badge">PREMIUM</span> <span class="premium-lock"></span></h2>
                <div class="passage-reading-container">
                    <div class="passage-content-sat premium-preview-overlay">${formattedContent}</div>
                </div>
            `;
            
            // Add upgrade prompt
            const upgradeHTML = `
                <div class="premium-upgrade-prompt">
                    <h3> Premium Content</h3>
                    <p>This passage is part of our premium collection. Upgrade to unlock full access to all passages, lessons, and writing sections.</p>
                    ${authToken ? 
                        `<button class="btn" onclick="upgradeToPremium()">Upgrade to Premium - $5/month</button>` :
                        `<button class="btn" onclick="showRegisterModal()">Sign Up to Upgrade</button>`
                    }
                </div>
            `;
            document.getElementById('passageContent').innerHTML += upgradeHTML;
            
            // Hide questions and submit
            document.getElementById('questionsContainer').innerHTML = '';
            document.getElementById('submitSection').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'none';
        }
        
        function displayWritingSectionPreview(writingSection) {
            // Hide all list sections, show detail view
            document.getElementById('passagesListSection').style.display = 'none';
            document.getElementById('lessonsListSection').style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // document.getElementById('writingSectionsListSection').style.display = 'none';
            document.getElementById('mathSectionsListSection').style.display = 'none';
            document.getElementById('passageDetailSection').style.display = 'block';
            
            // Show first ~500 characters with gradient fade
            const previewLength = 500;
            const previewContent = writingSection.content ? writingSection.content.substring(0, previewLength) + '...' : '';
            const formattedContent = formatWritingSectionContent(previewContent, writingSection.selections || []);
            
            document.getElementById('passageContent').innerHTML = `
                <h2 style="color: #3498DB; margin-bottom: 15px;">${escapeHtml(writingSection.title)} <span class="premium-badge">PREMIUM</span> <span class="premium-lock"></span></h2>
                <div class="premium-preview-overlay">${formattedContent}</div>
            `;
            
            // Add upgrade prompt
            const upgradeHTML = `
                <div class="premium-upgrade-prompt">
                    <h3> Premium Content</h3>
                    <p>This writing section is part of our premium collection. Upgrade to unlock full access to all writing sections, passages, and lessons.</p>
                    ${authToken ? 
                        `<button class="btn" onclick="upgradeToPremium()">Upgrade to Premium - $5/month</button>` :
                        `<button class="btn" onclick="showRegisterModal()">Sign Up to Upgrade</button>`
                    }
                </div>
            `;
            document.getElementById('passageContent').innerHTML += upgradeHTML;
            
            // Hide questions and submit
            document.getElementById('questionsContainer').innerHTML = '';
            document.getElementById('submitSection').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'none';
        }
        
        let isOpeningPassage = false; // Flag to prevent hashchange loop
        let isOpeningMathSection = false; // Flag to prevent hashchange loop for math sections
        
        async function openPassage(passageId) {
            console.log('openPassage called with ID:', passageId);
            // Prevent re-triggering if already opening this passage
            if (isOpeningPassage && currentPassageId === passageId) {
                console.log('Already opening this passage, skipping');
                return;
            }
            
            // Require login to access passages (they are not intro content)
            if (!currentUser) {
                showLoginRequiredModal();
                return;
            }
            
            try {
                console.log('Opening passage:', passageId);
                isOpeningPassage = true;
                currentPassageId = passageId;
                // Clear other detail view states
                currentLessonId = null;
                currentLessonData = null;
                currentMathSectionId = null;
                currentMathSectionData = null;
                currentWritingSectionId = null;
                currentWritingSectionData = null;
                userAnswers = {};
                
                // Update URL hash (replaceState doesn't trigger hashchange, which is what we want)
                window.history.replaceState(null, '', window.location.pathname + `#passage/${passageId}`);
                
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                // Fetch passage detail with content
                const passageResponse = await fetch(`${API_BASE}/passages/${passageId}`, {headers});
                if (passageResponse.status === 403) {
                    // Try to get passage data anyway for preview
                    const previewResponse = await fetch(`${API_BASE}/passages/${passageId}`, {});
                    if (previewResponse.ok) {
                        const passageData = await previewResponse.json();
                        displayPassagePreview(passageData);
                    } else {
                        // Show upgrade modal instead of alert
                        showUpgradeModal('passage');
                    }
                    isOpeningPassage = false;
                    return;
                }
                
                if (!passageResponse.ok) {
                    alert('Failed to load passage. Please try again.');
                    isOpeningPassage = false;
                    return;
                }
                
                const passageData = await passageResponse.json();
                currentPassageData = passageData;
                
                // Fetch questions (without answers)
                const questionsResponse = await fetch(`${API_BASE}/passages/${passageId}/questions`, {headers});
                if (!questionsResponse.ok) {
                    alert('Failed to load questions. Please try again.');
                    isOpeningPassage = false;
                    return;
                }
                
                const questionsData = await questionsResponse.json();
                
                // Display passage
                console.log('About to display passage:', passageData.title);
                displayPassage(passageData, questionsData);
                console.log('Passage displayed successfully');
                
            } catch (error) {
                console.error('Failed to open passage:', error);
                console.error('Error stack:', error.stack);
                alert('Network error. Please try again.');
            } finally {
                isOpeningPassage = false;
            }
        }
        
        // Make openPassage globally accessible
        window.openPassage = openPassage;
        
        function formatPassageForSAT(content) {
            // First, normalize content: convert literal \n strings to actual newlines
            if (typeof content === 'string') {
                // Handle literal \n strings (both \\n and \n)
                content = content.replace(/\\\\n/g, '\n');
                content = content.replace(/\\n/g, '\n');
            }
            
            // Split content into paragraphs (double newlines separate paragraphs)
            // Preserve original line breaks but wrap to 50 characters
            const allLines = [];
            const paragraphs = content.split(/\n\n+/);
            
            paragraphs.forEach((paragraph, paraIndex) => {
                // Split paragraph by single newlines to preserve line breaks
                const originalLines = paragraph.split(/\n/);
                
                originalLines.forEach(originalLine => {
                    const trimmed = originalLine.trim();
                    
                    if (!trimmed) {
                        // Empty line - preserve it as blank line
                        allLines.push('');
                        return;
                    }
                    
                    // Wrap this line to 50 characters
                    const words = trimmed.split(/\s+/);
                    let currentLine = '';
                    
                    words.forEach(word => {
                        const testLine = currentLine ? currentLine + ' ' + word : word;
                        if (testLine.length <= 50) {
                            currentLine = testLine;
                        } else {
                            // Save current line and start new one
                            if (currentLine) {
                                allLines.push(currentLine);
                            }
                            // If word itself is longer than 50 chars, split it
                            if (word.length > 50) {
                                let remaining = word;
                                while (remaining.length > 50) {
                                    allLines.push(remaining.substring(0, 50));
                                    remaining = remaining.substring(50);
                                }
                                currentLine = remaining;
                            } else {
                                currentLine = word;
                            }
                        }
                    });
                    
                    // Add remaining line
                    if (currentLine) {
                        allLines.push(currentLine);
                    }
                });
                
                // Add blank line between paragraphs (but not after last paragraph)
                if (paraIndex < paragraphs.length - 1) {
                    allLines.push('');
                }
            });
            
            // Calculate line numbers: skip blank lines in numbering
            let lineNumber = 0; // This counts only non-blank lines
            const linesWithNumbers = allLines.map(line => {
                const isBlank = !line || line.trim() === '';
                if (!isBlank) {
                    lineNumber++;
                }
                return {
                    text: line,
                    isBlank: isBlank,
                    lineNumber: isBlank ? null : lineNumber
                };
            });
            
            // Format lines with line numbers every 5 lines (5, 10, 15, 20, etc.)
            // But only show numbers on non-blank lines
            let formattedHTML = '<div class="passage-columns">';
            const linesPerColumn = Math.ceil(linesWithNumbers.length / 2);
            
            // Create two columns
            for (let col = 0; col < 2; col++) {
                formattedHTML += '<div class="passage-column">';
                const startLine = col * linesPerColumn;
                const endLine = Math.min(startLine + linesPerColumn, linesWithNumbers.length);
                
                for (let i = startLine; i < endLine; i++) {
                    const lineData = linesWithNumbers[i];
                    const line = lineData.text;
                    const lineNum = lineData.lineNumber;
                    
                    // Show line number every 5 lines (5, 10, 15, 20, etc.) but only on non-blank lines
                    const shouldShowNumber = lineNum !== null && lineNum % 5 === 0;
                    
                    if (shouldShowNumber) {
                        formattedHTML += `<div class="passage-line-numbered">`;
                        formattedHTML += `<span class="line-number">${lineNum}</span>`;
                        formattedHTML += `<span class="line-text">${escapeHtml(line || ' ')}</span>`;
                        formattedHTML += `</div>`;
                    } else {
                        // Still use numbered format for alignment, but with empty number
                        formattedHTML += `<div class="passage-line-numbered">`;
                        formattedHTML += `<span class="line-number"></span>`;
                        formattedHTML += `<span class="line-text">${escapeHtml(line || ' ')}</span>`;
                        formattedHTML += `</div>`;
                    }
                }
                
                formattedHTML += '</div>';
            }
            
            formattedHTML += '</div>';
            return formattedHTML;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        /**
         * Replace sentinel markers like [[Diagram asset_id]] with image tags
         * @param {string} text - The text containing sentinels
         * @param {Array} assets - Array of asset objects with asset_id and s3_url
         * @param {string} lessonId - Lesson ID for constructing URLs if needed
         * @returns {string} - HTML with sentinels replaced by images
         */
        function replaceUnderlineSentinels(text) {
            if (!text) return text;
            if (typeof text !== 'string') return String(text);
            // Replace *text* with <u>text</u> for underlines
            // Use non-greedy matching to handle multiple underlines in the same text
            // Match *word* but not **bold** (which uses double asterisks)
            // Pattern: *text* where text doesn't contain asterisks
            return text.replace(/\*([^*]+?)\*/g, '<u>$1</u>');
        }
        
        function formatExplanation(explanation, assets, lessonId) {
            // Handle both string and array explanations
            if (!explanation) return '';
            
            if (typeof explanation === 'string') {
                return replaceUnderlineSentinels(replaceDiagramSentinels(explanation, assets, lessonId));
            }
            
            if (Array.isArray(explanation)) {
                // Array of blocks - use formatMathExplanation which handles this
                return formatMathExplanation(explanation, false);
            }
            
            // Object or other - try to stringify
            return escapeHtml(JSON.stringify(explanation));
        }
        
        function replaceBoldItalicSentinels(text) {
            if (!text) return text;
            // Replace **text** with <strong>text</strong> for bold
            // Replace _text_ with <em>text</em> for italic
            // Process bold first, then italic
            text = text.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
            text = text.replace(/_([^_]+?)_/g, '<em>$1</em>');
            return text;
        }
        
        function formatLessonPrompt(promptBlocks, lessonAssets, lessonId) {
            // Format lesson question prompt blocks (similar to formatMathPrompt)
            if (!promptBlocks || !Array.isArray(promptBlocks)) {
                return '';
            }
            
            const result = [];
            
            for (let i = 0; i < promptBlocks.length; i++) {
                const block = promptBlocks[i];
                let part = '';
                
                if (typeof block === 'string') {
                    part = block;
                } else if (block && typeof block === 'object') {
                    if (block.type === 'paragraph') {
                        let processedText = block.text || '';
                        processedText = replaceDiagramSentinels(processedText, lessonAssets || [], lessonId);
                        processedText = replaceUnderlineSentinels(processedText);
                        processedText = replaceBoldItalicSentinels(processedText);
                        part = `<p style="margin-bottom: 15px; line-height: 1.6; color: #000;">${processedText}</p>`;
                    } else if (block.type === 'side_by_side') {
                        // Handle side-by-side blocks
                        let rows = [];
                        if (block.rows && Array.isArray(block.rows)) {
                            rows = block.rows;
                        } else if (block.explanation !== undefined || block.diagram_asset_id !== undefined) {
                            rows = [{
                                explanation: block.explanation || '',
                                diagram_asset_id: block.diagram_asset_id || ''
                            }];
                        }
                        
                        const rowsHtml = rows.map((row, rowIndex) => {
                            let processedExplanation = row.explanation || '';
                            processedExplanation = replaceUnderlineSentinels(processedExplanation);
                            processedExplanation = replaceBoldItalicSentinels(processedExplanation);
                            
                            let rightSideHtml = '';
                            if (row.diagram_asset_id) {
                                const asset = lessonAssets.find(a => a.asset_id === row.diagram_asset_id);
                                let imageUrl = '';
                                
                                if (asset && asset.s3_url) {
                                    imageUrl = asset.s3_url;
                                } else if (row.diagram_asset_id && lessonId) {
                                    imageUrl = `https://keuvi.s3.amazonaws.com/lessons/${lessonId}/${row.diagram_asset_id}.png`;
                                }
                                
                                if (imageUrl) {
                                    rightSideHtml = `<img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(row.diagram_asset_id)}" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px;" onerror="this.style.display='none'; console.error('Failed to load diagram:', '${row.diagram_asset_id}');">`;
                                } else {
                                    rightSideHtml = `<span style="color: #999; font-style: italic;">[Diagram ${escapeHtml(row.diagram_asset_id)} not found]</span>`;
                                }
                            } else if (row.right_text) {
                                let processedText = row.right_text || '';
                                processedText = replaceUnderlineSentinels(processedText);
                                processedText = replaceBoldItalicSentinels(processedText);
                                rightSideHtml = `<div style="line-height: 1.6; color: #000;">${processedText}</div>`;
                            } else {
                                rightSideHtml = '<span style="color: #999; font-style: italic;">[No content]</span>';
                            }
                            
                            const marginTop = rowIndex > 0 ? '30px' : '20px';
                            return `<div style="display: flex; flex-direction: row; gap: 20px; margin-top: ${marginTop}; margin-bottom: 20px; align-items: flex-start; flex-wrap: wrap;">
                                <div style="flex: 1 1 45%; min-width: 250px;">
                                    <div style="line-height: 1.6; color: var(--text-primary);">${processedExplanation}</div>
                                </div>
                                <div style="flex: 1 1 45%; min-width: 250px;">
                                    ${rightSideHtml}
                                </div>
                            </div>`;
                        }).join('');
                        
                        part = rowsHtml;
                    } else if (block.text) {
                        // Fallback
                        part = block.text;
                    }
                }
                
                if (part && part.trim().length > 0) {
                    if (block && block.type === 'side_by_side') {
                        if (result.length > 0) {
                            result.push('<div style="margin-top: 20px;"></div>' + part);
                        } else {
                            result.push(part);
                        }
                    } else {
                        result.push(part);
                    }
                }
            }
            
            return result.join('');
        }
        
        function formatMathPrompt(promptBlocks, mathAssets, mathSectionId) {
            // Format math question prompt blocks (similar to formatMathExplanation)
            if (!promptBlocks || !Array.isArray(promptBlocks)) {
                return '';
            }
            
            const result = [];
            
            for (let i = 0; i < promptBlocks.length; i++) {
                const block = promptBlocks[i];
                let part = '';
                
                if (typeof block === 'string') {
                    part = block;
                } else if (block && typeof block === 'object') {
                    if (block.type === 'paragraph') {
                        let processedText = block.text || '';
                        processedText = replaceDiagramSentinels(processedText, mathAssets, mathSectionId);
                        processedText = replaceUnderlineSentinels(processedText);
                        processedText = replaceBoldItalicSentinels(processedText);
                        part = `<p style="margin-bottom: 15px; line-height: 1.6; color: #000;">${processedText}</p>`;
                    } else if (block.type === 'side_by_side') {
                        // Handle side-by-side blocks
                        let rows = [];
                        if (block.rows && Array.isArray(block.rows)) {
                            rows = block.rows;
                        } else if (block.explanation !== undefined || block.diagram_asset_id !== undefined) {
                            rows = [{
                                explanation: block.explanation || '',
                                diagram_asset_id: block.diagram_asset_id || ''
                            }];
                        }
                        
                        const rowsHtml = rows.map((row, rowIndex) => {
                            let processedExplanation = row.explanation || '';
                            processedExplanation = replaceUnderlineSentinels(processedExplanation);
                            processedExplanation = replaceBoldItalicSentinels(processedExplanation);
                            
                            let rightSideHtml = '';
                            if (row.diagram_asset_id) {
                                const asset = mathAssets.find(a => a.asset_id === row.diagram_asset_id);
                                let imageUrl = '';
                                
                                if (asset && asset.s3_url) {
                                    imageUrl = asset.s3_url;
                                } else if (row.diagram_asset_id && mathSectionId) {
                                    imageUrl = `https://keuvi.s3.amazonaws.com/math-sections/${mathSectionId}/${row.diagram_asset_id}.png`;
                                }
                                
                                if (imageUrl) {
                                    rightSideHtml = `<img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(row.diagram_asset_id)}" style="max-width: 100%; height: auto; border: 1px solid var(--border-color); border-radius: 4px;" onerror="this.style.display='none'; console.error('Failed to load diagram:', '${row.diagram_asset_id}');">`;
                                } else {
                                    rightSideHtml = `<span style="color: var(--text-secondary); font-style: italic;">[Diagram ${escapeHtml(row.diagram_asset_id)} not found]</span>`;
                                }
                            } else if (row.right_text) {
                                let processedText = row.right_text || '';
                                processedText = replaceUnderlineSentinels(processedText);
                                processedText = replaceBoldItalicSentinels(processedText);
                                // Use CSS variables for dark mode support
                                rightSideHtml = `<div style="line-height: 1.6; color: var(--text-primary);">${processedText}</div>`;
                            } else {
                                rightSideHtml = '<span style="color: var(--text-secondary); font-style: italic;">[No content]</span>';
                            }
                            
                            const marginTop = rowIndex > 0 ? '30px' : '20px';
                            return `<div style="display: flex; flex-direction: row; gap: 20px; margin-top: ${marginTop}; margin-bottom: 20px; align-items: flex-start; flex-wrap: wrap;">
                                <div style="flex: 1 1 45%; min-width: 250px;">
                                    <div style="line-height: 1.6; color: var(--text-primary);">${processedExplanation}</div>
                                </div>
                                <div style="flex: 1 1 45%; min-width: 250px;">
                                    ${rightSideHtml}
                                </div>
                            </div>`;
                        }).join('');
                        
                        part = rowsHtml;
                    } else if (block.text) {
                        // Fallback
                        part = block.text;
                    }
                }
                
                if (part && part.trim().length > 0) {
                    if (block && block.type === 'side_by_side') {
                        if (result.length > 0) {
                            result.push('<div style="margin-top: 20px;"></div>' + part);
                        } else {
                            result.push(part);
                        }
                    } else {
                        result.push(part);
                    }
                }
            }
            
            return result.join('');
        }
        
        function formatMathExplanation(explanation, isMathSection = false) {
            // Handle null/undefined
            if (!explanation) {
                return '';
            }
            
            // If it's a JSON string, parse it first
            if (typeof explanation === 'string') {
                try {
                    // Try to parse as JSON
                    const parsed = JSON.parse(explanation);
                    explanation = parsed;
                } catch (e) {
                    // Not JSON, return as-is
                    return explanation;
                }
            }
            
            // Math questions have explanation as an array of objects
            // Always check if it's an array first (math sections use arrays)
            if (Array.isArray(explanation)) {
                const result = [];
                
                for (let i = 0; i < explanation.length; i++) {
                    const block = explanation[i];
                    let part = '';
                    
                    if (typeof block === 'string') {
                        part = block;
                    } else if (block && typeof block === 'object') {
                        if (block.type === 'paragraph' || block.type === 'note' || block.type === 'example') {
                            part = block.text || '';
                        } else if (block.type === 'equation') {
                            // Convert LaTeX to plain text for display
                            if (block.latex) {
                                let equationText = block.latex;
                                // Remove LaTeX commands and convert to readable text
                                // Common LaTeX to text conversions
                                equationText = equationText.replace(/\\angle\s*/g, '');
                                equationText = equationText.replace(/\\degree/g, '');
                                equationText = equationText.replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '($1)/($2)');
                                equationText = equationText.replace(/\\sqrt\{([^}]+)\}/g, '($1)');
                                equationText = equationText.replace(/\\times/g, '');
                                equationText = equationText.replace(/\\div/g, '');
                                equationText = equationText.replace(/\\pm/g, '');
                                equationText = equationText.replace(/\\leq/g, '');
                                equationText = equationText.replace(/\\geq/g, '');
                                equationText = equationText.replace(/\\neq/g, '');
                                equationText = equationText.replace(/\\approx/g, '');
                                equationText = equationText.replace(/\\pi/g, '');
                                equationText = equationText.replace(/\\theta/g, '');
                                equationText = equationText.replace(/\\text\{([^}]+)\}/g, '$1');
                                equationText = equationText.replace(/\\alpha/g, '');
                                equationText = equationText.replace(/\\beta/g, '');
                                equationText = equationText.replace(/\\gamma/g, '');
                                equationText = equationText.replace(/\\Delta/g, '');
                                equationText = equationText.replace(/\\sum/g, '');
                                equationText = equationText.replace(/\\int/g, '');
                                // Remove remaining LaTeX braces
                                equationText = equationText.replace(/\{([^}]+)\}/g, '$1');
                                // Remove backslashes before single characters (common LaTeX commands)
                                equationText = equationText.replace(/\\([a-zA-Z])/g, '$1');
                                // Clean up extra spaces
                                equationText = equationText.replace(/\s+/g, ' ').trim();
                                // Wrap in styled container for dark mode support
                                const isDarkMode = document.body.classList.contains('dark-mode');
                                const eqBg = isDarkMode ? 'var(--bg-tertiary)' : '#ffffff';
                                const eqColor = isDarkMode ? 'var(--text-primary)' : '#000';
                                const eqBorder = isDarkMode ? '1px solid var(--border-color)' : '1px solid #ddd';
                                part = `<div style="display: inline-block; padding: 8px 12px; margin: 4px 0; background: ${eqBg}; border: ${eqBorder}; border-radius: 4px; color: ${eqColor}; font-family: monospace;">${escapeHtml(equationText)}</div>`;
                            }
                        } else if (block.type === 'side_by_side') {
                            // Handle side-by-side blocks - render as HTML
                            let rows = [];
                            if (block.rows && Array.isArray(block.rows)) {
                                rows = block.rows;
                            } else if (block.explanation !== undefined || block.diagram_asset_id !== undefined) {
                                // Legacy format: convert to rows array
                                rows = [{
                                    explanation: block.explanation || '',
                                    diagram_asset_id: block.diagram_asset_id || ''
                                }];
                            }
                            
                            // Determine if this is a lesson or math section, and get appropriate assets
                            const isLesson = !!currentLessonData;
                            const lessonAssets = currentLessonData?.assets || [];
                            const lessonId = currentLessonData?.lesson_id || '';
                            const mathAssets = currentMathSectionData?.assets || [];
                            const mathSectionId = currentMathSectionData?.section_id || currentMathSectionData?.id || '';
                            
                            // Use lesson assets if available, otherwise math section assets
                            const availableAssets = isLesson ? lessonAssets : mathAssets;
                            const contextId = isLesson ? lessonId : mathSectionId;
                            
                            // Render each row
                            const rowsHtml = rows.map((row, rowIndex) => {
                                let processedExplanation = row.explanation || '';
                                // Process sentinels in explanation (including diagram sentinels)
                                processedExplanation = replaceDiagramSentinels(processedExplanation, availableAssets, contextId);
                                processedExplanation = replaceUnderlineSentinels(processedExplanation);
                                processedExplanation = replaceBoldItalicSentinels(processedExplanation);
                                
                                let rightSideHtml = '';
                                if (row.diagram_asset_id) {
                                    // Find the asset in the assets array
                                    const asset = availableAssets.find(a => a.asset_id === row.diagram_asset_id);
                                    let imageUrl = '';
                                    
                                    if (asset && asset.s3_url) {
                                        imageUrl = asset.s3_url;
                                    } else if (row.diagram_asset_id && contextId) {
                                        // Fallback: construct URL (use lessons/ prefix for both lessons and math sections)
                                        imageUrl = `https://keuvi.s3.amazonaws.com/lessons/${contextId}/${row.diagram_asset_id}.png`;
                                    }
                                    
                                    if (imageUrl) {
                                        rightSideHtml = `<img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(row.diagram_asset_id)}" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px;" onerror="this.style.display='none'; console.error('Failed to load diagram:', '${row.diagram_asset_id}');">`;
                                    } else {
                                        rightSideHtml = `<span style="color: #999; font-style: italic;">[Diagram ${escapeHtml(row.diagram_asset_id)} not found]</span>`;
                                    }
                                } else if (row.right_text) {
                                    let processedText = row.right_text || '';
                                    processedText = replaceUnderlineSentinels(processedText);
                                    processedText = replaceBoldItalicSentinels(processedText);
                                    // Use CSS variables for dark mode support
                                    rightSideHtml = `<div style="line-height: 1.6; color: var(--text-primary);">${processedText}</div>`;
                                } else {
                                    rightSideHtml = '<span style="color: var(--text-secondary); font-style: italic;">[No content]</span>';
                                }
                                
                                const marginTop = rowIndex > 0 ? '30px' : '20px';
                                return `<div style="display: flex; flex-direction: row; gap: 20px; margin-top: ${marginTop}; margin-bottom: 20px; align-items: flex-start; flex-wrap: wrap;">
                                    <div style="flex: 1 1 45%; min-width: 250px;">
                                        <div style="line-height: 1.6; color: var(--text-primary);">${processedExplanation}</div>
                                    </div>
                                    <div style="flex: 1 1 45%; min-width: 250px;">
                                        ${rightSideHtml}
                                    </div>
                                </div>`;
                            }).join('');
                            
                            part = rowsHtml;
                        } else if (block.text) {
                            // Fallback: try to get text property if it exists
                            part = block.text;
                        }
                    }
                    
                    // Only add non-empty parts
                    if (part && part.trim().length > 0) {
                        // If this block is an equation and not the first item, add line break before it
                        if (block && block.type === 'equation' && result.length > 0) {
                            result.push('<br><br>' + part); // Add double line break for equations
                        } else if (block && block.type === 'side_by_side') {
                            // Side-by-side blocks are already HTML, just add spacing
                            if (result.length > 0) {
                                result.push('<div style="margin-top: 20px;"></div>' + part);
                            } else {
                                result.push(part);
                            }
                        } else if (result.length > 0) {
                            // Add space between paragraphs
                            result.push(' ' + part);
                        } else {
                            result.push(part);
                        }
                    }
                }
                
                // Join without additional spaces (we already added them above)
                return result.length > 0 ? result.join('') : '';
            }
            
            // If it's an object but not an array, try to extract text
            if (explanation && typeof explanation === 'object') {
                // Try common properties
                if (explanation.text) {
                    return String(explanation.text);
                }
                if (explanation.content) {
                    return String(explanation.content);
                }
                // If it has a type and text, treat it as a single block
                if (explanation.type === 'paragraph' || explanation.type === 'note' || explanation.type === 'example') {
                    return String(explanation.text || '');
                }
                if (explanation.type === 'equation') {
                    // Convert LaTeX to plain text for display
                    if (explanation.latex) {
                        let equationText = explanation.latex;
                        // Remove LaTeX commands and convert to readable text
                        equationText = equationText.replace(/\\angle\s*/g, '');
                        equationText = equationText.replace(/\\degree/g, '');
                        equationText = equationText.replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '($1)/($2)');
                        equationText = equationText.replace(/\\sqrt\{([^}]+)\}/g, '($1)');
                        equationText = equationText.replace(/\\times/g, '');
                        equationText = equationText.replace(/\\div/g, '');
                        equationText = equationText.replace(/\\pm/g, '');
                        equationText = equationText.replace(/\\leq/g, '');
                        equationText = equationText.replace(/\\geq/g, '');
                        equationText = equationText.replace(/\\neq/g, '');
                        equationText = equationText.replace(/\\approx/g, '');
                        equationText = equationText.replace(/\\pi/g, '');
                        equationText = equationText.replace(/\\theta/g, '');
                        equationText = equationText.replace(/\\alpha/g, '');
                        equationText = equationText.replace(/\\beta/g, '');
                        equationText = equationText.replace(/\\gamma/g, '');
                        equationText = equationText.replace(/\\Delta/g, '');
                        equationText = equationText.replace(/\\sum/g, '');
                        equationText = equationText.replace(/\\int/g, '');
                        // Remove remaining LaTeX braces
                        equationText = equationText.replace(/\{([^}]+)\}/g, '$1');
                        // Remove backslashes before single characters
                        equationText = equationText.replace(/\\([a-zA-Z])/g, '$1');
                        // Clean up extra spaces
                        equationText = equationText.replace(/\s+/g, ' ').trim();
                        return equationText;
                    }
                    return '';
                }
            }
            
            // Final fallback - convert to string
            return String(explanation || '');
        }
        
        function replaceDiagramSentinels(text, assets, lessonId) {
            if (!text) {
                console.log('replaceDiagramSentinels: No text provided');
                return text;
            }
            // Don't return early if no assets - we can still construct URLs from sentinels if we have lessonId
            if (!assets || !Array.isArray(assets) || assets.length === 0) {
                console.log('replaceDiagramSentinels: No assets provided, will try to construct URLs from sentinels', {assets, lessonId});
                // Continue processing - we can still construct URLs from asset_id in sentinel
            }
            
            // Only log if text actually contains the marker (reduce noise)
            if (!text.includes('[[Diagram') && !text.includes('[[diagram') && !text.includes('[[DIAGRAM')) {
                return text; // Early return if no sentinel
            }
            
            console.log(' replaceDiagramSentinels called with sentinel in text');
            
            // Check if text contains the sentinel pattern (case-insensitive check first)
            const hasDiagramMarker = text.includes('[[Diagram') || text.includes('[[diagram') || text.includes('[[DIAGRAM');
            
            if (hasDiagramMarker) {
                console.log('Text contains [[Diagram marker. Full text:', text);
                console.log('Text length:', text.length);
                // Show character codes around the marker to check for encoding issues
                const markerIndex = text.indexOf('[[Diagram');
                if (markerIndex >= 0) {
                    const snippet = text.substring(Math.max(0, markerIndex - 20), Math.min(text.length, markerIndex + 50));
                    console.log('Snippet around marker:', snippet);
                    console.log('Character codes:', Array.from(snippet).map(c => c.charCodeAt(0)));
                }
            }
            
            // Pattern to match [[Diagram asset_id]] - be more flexible
            // Match: [[Diagram asset_id]] with optional whitespace (use \s* instead of \s+)
            // Use non-greedy match and allow for various whitespace scenarios
            let sentinelPattern = /\[\[Diagram\s*([^\]]+?)\s*\]\]/gi;
            
            const matches = text.match(sentinelPattern);
            if (matches) {
                console.log(' Found sentinel matches:', matches);
            } else if (hasDiagramMarker) {
                console.log(' Text contains [[Diagram but pattern did not match!');
                console.log('Full text for debugging:', JSON.stringify(text));
                
                // Try alternative patterns - use the most permissive one that works
                console.log('Trying alternative patterns...');
                
                // Pattern 1: Without requiring space after Diagram
                const altPattern1 = /\[\[Diagram([^\]]+)\]\]/gi;
                const altMatches1 = text.match(altPattern1);
                if (altMatches1) {
                    console.log(' Alternative pattern 1 (no space required) matched:', altMatches1);
                    sentinelPattern = altPattern1;
                } else {
                    // Pattern 2: More permissive - any characters between Diagram and ]]
                    const altPattern2 = /\[\[Diagram\s*([^\]]+?)\s*\]\]/gi;
                    const altMatches2 = text.match(altPattern2);
                    if (altMatches2) {
                        console.log(' Alternative pattern 2 (flexible whitespace) matched:', altMatches2);
                        sentinelPattern = altPattern2;
                    } else {
                        // Pattern 3: Very permissive - match anything between [[Diagram and ]]
                        const altPattern3 = /\[\[Diagram\s*([^\]]+)\]\]/gi;
                        const altMatches3 = text.match(altPattern3);
                        if (altMatches3) {
                            console.log(' Alternative pattern 3 (very permissive) matched:', altMatches3);
                            sentinelPattern = altPattern3;
                        }
                    }
                }
            }
            
            return text.replace(sentinelPattern, (match, assetId) => {
                // Trim whitespace from asset_id
                assetId = assetId.trim();
                console.log(`Processing sentinel: "${match}" with asset_id: "${assetId}"`);
                console.log(`Available assets (${assets?.length || 0}):`, assets?.map(a => ({asset_id: a.asset_id, s3_url: a.s3_url?.substring(0, 50) + '...'})));
                
                // Find the asset by asset_id (only if assets array exists and has items)
                const asset = (assets && Array.isArray(assets) && assets.length > 0) 
                    ? assets.find(a => a.asset_id === assetId) 
                    : null;
                console.log(`Found asset for "${assetId}":`, asset);
                
                // If not found, try case-insensitive match
                if (!asset && assets && Array.isArray(assets) && assets.length > 0) {
                    const caseInsensitiveAsset = assets.find(a => a.asset_id && a.asset_id.toLowerCase() === assetId.toLowerCase());
                    if (caseInsensitiveAsset) {
                        console.log(`Found asset with case-insensitive match:`, caseInsensitiveAsset);
                        // Use the case-insensitive match
                        const matchedAsset = caseInsensitiveAsset;
                        if (matchedAsset && matchedAsset.s3_url) {
                            let imageUrl = matchedAsset.s3_url;
                            imageUrl = imageUrl.trim().replace(/[: ]+$/, '');
                            if (!/\.(png|jpg|jpeg|gif|svg|webp)$/i.test(imageUrl)) {
                                if (!imageUrl.includes('.')) {
                                    imageUrl += '.png';
                                }
                            }
                            console.log(`Using image URL from case-insensitive match: ${imageUrl}`);
                            return `<img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(assetId)}" style="max-width: 100%; height: auto; margin: 15px auto; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: block;" onerror="console.error('Failed to load diagram:', this.src); this.style.display='none';" />`;
                        }
                    }
                }
                
                if (asset && asset.s3_url) {
                    // Use the S3 URL from the asset
                    let imageUrl = asset.s3_url;
                    
                    // Clean up malformed URLs
                    imageUrl = imageUrl.trim().replace(/[: ]+$/, '');
                    
                    // Fix malformed URLs - check if URL contains math-sections or lessons
                    if (imageUrl.endsWith('/') || imageUrl.match(/lessons\/[^/]+:$/) || imageUrl.match(/math-sections\/[^/]+:$/)) {
                        // Determine if this is a math section or lesson based on the asset's S3 URL
                        // Math sections now use lessons/ directly (same as lessons) to work with bucket policy
                        // Check for old math-sections/ paths for backwards compatibility
                        const isOldMathSectionPath = imageUrl.includes('math-sections/') && !imageUrl.includes('lessons/');
                        if (isOldMathSectionPath) {
                            // Old path - update to new format
                            imageUrl = `https://keuvi.s3.amazonaws.com/lessons/${lessonId || 'unknown'}/${assetId}.png`;
                        } else {
                            // Use lessons/ prefix (works for both lessons and math sections)
                            imageUrl = `https://keuvi.s3.amazonaws.com/lessons/${lessonId || 'unknown'}/${assetId}.png`;
                        }
                    }
                    
                    // Ensure URL has proper extension
                    if (!/\.(png|jpg|jpeg|gif|svg|webp)$/i.test(imageUrl)) {
                        if (!imageUrl.includes('.')) {
                            imageUrl += '.png';
                        }
                    }
                    
                    console.log(`Using image URL: ${imageUrl}`);
                    // Return image tag - centered horizontally for paragraph chunks
                    return `<img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(assetId)}" style="max-width: 100%; height: auto; margin: 15px auto; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: block;" onerror="console.error('Failed to load diagram:', this.src); this.style.display='none';" />`;
                } else if (assetId && lessonId) {
                    // If asset not found but we have asset_id and lesson_id, construct URL
                    // Both lessons and math sections now use lessons/ prefix
                    // Try multiple URL formats in case the asset was uploaded with different naming
                    const baseUrl = `https://keuvi.s3.amazonaws.com/lessons/${lessonId}/${assetId}`;
                    const constructedUrl = `${baseUrl}.png`;
                    console.log(`Constructing fallback URL: ${constructedUrl}`);
                    console.log(`Lesson ID: "${lessonId}", Asset ID: "${assetId}"`);
                    
                    // Return image with multiple format attempts
                    return `<img src="${escapeHtml(constructedUrl)}" alt="${escapeHtml(assetId)}" style="max-width: 100%; height: auto; margin: 15px auto; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: block;" onerror="console.error('Failed to load diagram from:', this.src); this.onerror=null; this.src='${baseUrl}.jpg'; this.onerror=function(){this.onerror=null; this.src='${baseUrl}';};" />`;
                } else {
                    // Asset not found, return placeholder
                    console.warn(`Diagram sentinel [[Diagram ${assetId}]] found but asset not found. Assets:`, assets);
                    return `<span style="color: #999; font-style: italic;">[Diagram ${escapeHtml(assetId)} not found]</span>`;
                }
            });
        }
        
        function formatWritingSectionContent(content, selections) {
            // First, normalize the content - remove all line breaks and normalize whitespace
            // Convert literal \n strings to actual newlines if needed
            if (typeof content === 'string') {
                content = content.replace(/\\\\n/g, '\n');
                content = content.replace(/\\n/g, '\n');
            }
            
            // Store original for position calculations
            const originalContent = content;
            
            // Normalize whitespace: convert all line breaks to spaces, collapse multiple spaces
            // But we need to map positions from original to normalized
            let normalizedContent = originalContent.replace(/\r\n/g, ' '); // Windows line breaks
            normalizedContent = normalizedContent.replace(/\n/g, ' '); // Unix line breaks
            normalizedContent = normalizedContent.replace(/\r/g, ' '); // Old Mac line breaks
            normalizedContent = normalizedContent.replace(/\s+/g, ' '); // Collapse multiple spaces/tabs/etc to single space
            normalizedContent = normalizedContent.trim();
            
            // Build a mapping from original positions to normalized positions
            // This is complex, so instead let's rebuild selections based on normalized content
            const sortedSelections = [...selections].sort((a, b) => a.start_char - b.start_char);
            
            // Recalculate selection positions in normalized content
            const normalizedSelections = sortedSelections.map(sel => {
                const selectedText = originalContent.substring(sel.start_char, sel.end_char).trim();
                // Find this text in the normalized content
                const pos = normalizedContent.indexOf(selectedText);
                if (pos !== -1) {
                    return {
                        ...sel,
                        start_char: pos,
                        end_char: pos + selectedText.length,
                        selected_text: selectedText
                    };
                }
                // Try case-insensitive
                const normalizedLower = normalizedContent.toLowerCase();
                const selectedLower = selectedText.toLowerCase();
                const posLower = normalizedLower.indexOf(selectedLower);
                if (posLower !== -1) {
                    const actualText = normalizedContent.substring(posLower, posLower + selectedText.length);
                    return {
                        ...sel,
                        start_char: posLower,
                        end_char: posLower + actualText.length,
                        selected_text: actualText
                    };
                }
                return sel; // Keep original if can't find
            });
            
            // Now use normalized content and adjusted selections
            content = normalizedContent;
            
            // Build the formatted content with selections
            let formattedHTML = '<div class="passage-content-sat" style="line-height: 1.8; font-size: 16px; max-width: 100%; box-sizing: border-box;">';
            let lastIndex = 0;
            let htmlParts = [];
            
            // Process each selection and insert underlined text
            normalizedSelections.forEach(selection => {
                // Add text before selection
                if (selection.start_char > lastIndex) {
                    const beforeText = content.substring(lastIndex, selection.start_char);
                    htmlParts.push(escapeHtml(beforeText));
                }
                
                // Add underlined selection with number
                const selectedText = content.substring(selection.start_char, selection.end_char);
                htmlParts.push(`<span style="text-decoration: underline; font-weight: 500; color: #000; background-color: #fffacd; padding: 2px 4px;">
                    [${selection.number}] <u>${escapeHtml(selectedText)}</u>
                </span>`);
                
                lastIndex = selection.end_char;
            });
            
            // Add remaining text after last selection
            if (lastIndex < content.length) {
                const afterText = content.substring(lastIndex);
                htmlParts.push(escapeHtml(afterText));
            }
            
            // Combine all parts
            let fullText = htmlParts.join('');
            
            // Wrap in paragraph tags for natural text flow
            formattedHTML += '<p style="margin-bottom: 12px; text-align: left; white-space: normal;">' + fullText + '</p>';
            
            formattedHTML += '</div>';
            return formattedHTML;
        }
        
        async function openWritingSection(writingSectionId) {
            // Require login to access writing sections
            if (!currentUser) {
                showLoginRequiredModal();
                return;
            }
            
            try {
                currentWritingSectionId = writingSectionId;
                currentPassageId = null; // Clear passage data
                currentPassageData = null;
                currentLessonId = null;
                currentLessonData = null;
                userAnswers = {};
                
                // Update URL hash
                window.history.replaceState(null, '', window.location.pathname + `#writing-section/${writingSectionId}`);
                
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                // Fetch writing section detail
                const sectionResponse = await fetch(`${API_BASE}/writing-sections/${writingSectionId}`, {headers});
                if (sectionResponse.status === 403) {
                    // Try to get section data anyway for preview
                    const previewResponse = await fetch(`${API_BASE}/writing-sections/${writingSectionId}`, {});
                    if (previewResponse.ok) {
                        const sectionData = await previewResponse.json();
                        displayWritingSectionPreview(sectionData);
                    } else {
                        // Show upgrade modal instead of alert
                        showUpgradeModal('writing section');
                    }
                    return;
                }
                
                if (!sectionResponse.ok) {
                    alert('Failed to load writing section. Please try again.');
                    return;
                }
                
                const sectionData = await sectionResponse.json();
                currentWritingSectionData = sectionData;
                
                // Check if writing section is premium and user doesn't have access
                if (sectionData.tier === 'premium' && (!currentUser || (!currentUser.is_premium && !currentUser.has_active_subscription))) {
                    displayWritingSectionPreview(sectionData);
                    return;
                }
                
                // Fetch questions (without answers)
                const questionsResponse = await fetch(`${API_BASE}/writing-sections/${writingSectionId}/questions`, {headers});
                if (!questionsResponse.ok) {
                    alert('Failed to load questions. Please try again.');
                    return;
                }
                
                const questionsData = await questionsResponse.json();
                
                // Display writing section
                displayWritingSection(sectionData, questionsData);
                
            } catch (error) {
                console.error('Failed to open writing section:', error);
                alert('Network error. Please try again.');
            }
        }
        
        async function openMathSection(mathSectionId) {
            // Prevent re-triggering if already opening this section
            if (isOpeningMathSection && currentMathSectionId === mathSectionId) {
                console.log('Already opening this math section, skipping');
                return;
            }
            
            // Require login to access math sections
            if (!currentUser) {
                showLoginRequiredModal();
                return;
            }
            
            try {
                isOpeningMathSection = true;
                currentMathSectionId = mathSectionId;
                currentPassageId = null;
                currentPassageData = null;
                currentLessonId = null;
                currentLessonData = null;
                currentWritingSectionId = null;
                userAnswers = {};
                
                // Update URL hash
                window.history.replaceState(null, '', window.location.pathname + `#math-section/${mathSectionId}`);
                
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                // Fetch math section detail
                const sectionResponse = await fetch(`${API_BASE}/math-sections/${mathSectionId}`, {headers});
                if (sectionResponse.status === 403) {
                    // Try to get section data anyway for preview
                    const previewResponse = await fetch(`${API_BASE}/math-sections/${mathSectionId}`, {});
                    if (previewResponse.ok) {
                        const sectionData = await previewResponse.json();
                        displayMathSectionPreview(sectionData);
                        isOpeningMathSection = false;
                        return;
                    }
                }
                
                if (!sectionResponse.ok) {
                    alert('Failed to fetch math section. Please try again.');
                    isOpeningMathSection = false;
                    return;
                }
                
                const sectionData = await sectionResponse.json();
                
                // Check if premium and user doesn't have access
                if (sectionData.tier === 'premium' && (!currentUser || (!currentUser.is_premium && !currentUser.has_active_subscription))) {
                    displayMathSectionPreview(sectionData);
                    isOpeningMathSection = false;
                    return;
                }
                
                // Fetch questions
                const questionsResponse = await fetch(`${API_BASE}/math-sections/${mathSectionId}/questions/`, {headers});
                if (!questionsResponse.ok) {
                    alert('Failed to fetch questions. Please try again.');
                    isOpeningMathSection = false;
                    return;
                }
                const questionsData = await questionsResponse.json();
                
                // Store math section data for sentinel replacement
                // Merge questions into sectionData so displayResults can find them
                currentMathSectionData = {
                    ...sectionData,
                    questions: questionsData.results || questionsData.questions || [],
                    results: questionsData.results || questionsData.questions || []
                };
                
                // Display math section
                displayMathSection(sectionData, questionsData);
                
            } catch (error) {
                console.error('Failed to open math section:', error);
                alert('Network error. Please try again.');
            } finally {
                // Always clear the flag
                isOpeningMathSection = false;
            }
        }
        
        async function displayWritingSection(writingSection, questions) {
            // Hide all category content containers (which contain the list sections)
            document.querySelectorAll('.category-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Hide all list sections individually as well
            const passagesListSection = document.getElementById('passagesListSection');
            const readingLessonsListSection = document.getElementById('readingLessonsListSection');
            const writingSectionsListSection = document.getElementById('writingSectionsListSection');
            const writingLessonsListSection = document.getElementById('writingLessonsListSection');
            const mathSectionsListSection = document.getElementById('mathSectionsListSection');
            const mathLessonsListSection = document.getElementById('mathLessonsListSection');
            const passageDetailSection = document.getElementById('passageDetailSection');
            
            if (passagesListSection) passagesListSection.style.display = 'none';
            if (readingLessonsListSection) readingLessonsListSection.style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // if (writingSectionsListSection) writingSectionsListSection.style.display = 'none';
            if (writingLessonsListSection) writingLessonsListSection.style.display = 'none';
            if (mathSectionsListSection) mathSectionsListSection.style.display = 'none';
            if (mathLessonsListSection) mathLessonsListSection.style.display = 'none';
            if (passageDetailSection) passageDetailSection.style.display = 'block';
            
            // Hide word of the day, show explanation container
            const wordOfDay = document.getElementById('wordOfDay');
            const questionExplanation = document.getElementById('questionExplanation');
            if (wordOfDay) wordOfDay.style.display = 'none';
            if (questionExplanation) {
                questionExplanation.style.display = 'block';
                questionExplanation.classList.remove('hidden');
            }
            
            // Show attempt history button if user is logged in
            const attemptHistoryContainer = document.getElementById('attemptHistoryButtonContainer');
            if (authToken && writingSection.id) {
                try {
                    const attemptsResponse = await fetch(`${API_BASE}/progress/writing-sections/${writingSection.id}/attempts`, {
                        headers: {'Authorization': `Bearer ${authToken}`}
                    });
                    if (attemptsResponse.ok) {
                        const attempts = await attemptsResponse.json();
                        if (attempts.length > 0) {
                            attemptHistoryContainer.innerHTML = `
                                <button class="btn btn-secondary" onclick="showWritingSectionAttemptHistory('${writingSection.id}')" style="font-size: 12px; padding: 6px 12px;">
                                    View Attempts (${attempts.length})
                                </button>
                            `;
                        } else {
                            attemptHistoryContainer.innerHTML = '';
                        }
                    } else {
                        attemptHistoryContainer.innerHTML = '';
                    }
                } catch (error) {
                    console.error('Failed to load attempt history:', error);
                    attemptHistoryContainer.innerHTML = '';
                }
            } else {
                attemptHistoryContainer.innerHTML = '';
            }
            
            // Format content with underlined selections
            const formattedContent = formatWritingSectionContent(writingSection.content, writingSection.selections || []);
            
            document.getElementById('passageContent').innerHTML = `
                <h2 style="color: #3498DB; margin-bottom: 15px;">${escapeHtml(writingSection.title)}</h2>
                ${formattedContent}
            `;
            
            // Display questions in a grid (maintains order on mobile)
            const questionsContainer = document.getElementById('questionsContainer');
            questionsContainer.innerHTML = '<div class="questions-grid"></div>';
            
            const questionsGrid = questionsContainer.querySelector('.questions-grid');
            
            // Sort questions by order field to ensure correct display order
            const sortedWritingQuestions = [...(questions.questions || [])].sort((a, b) => {
                const orderA = a.order !== undefined ? a.order : 999;
                const orderB = b.order !== undefined ? b.order : 999;
                return orderA - orderB;
            });
            
            // Store questions in map for explanation access
            currentQuestionsMap = {};
            sortedWritingQuestions.forEach(question => {
                currentQuestionsMap[question.id] = question;
            });
            
            sortedWritingQuestions.forEach((question, index) => {
                const questionNumber = question.order !== undefined ? question.order : (index + 1);
                const questionCard = document.createElement('div');
                questionCard.className = 'question-card';
                
                // Show selection number if question is linked to a selection
                let selectionInfo = '';
                if (question.selection_number) {
                    selectionInfo = `<p style="color: #666; font-size: 13px; margin-bottom: 8px;">Refer to selection [${question.selection_number}]</p>`;
                }
                
                // Process question prompt - handle both JSON blocks and plain text
                let questionPrompt = '';
                if (Array.isArray(question.text)) {
                    // New format: array of blocks
                    questionPrompt = formatLessonPrompt(question.text, currentLessonData?.assets || [], currentLessonData?.lesson_id || '');
                } else if (typeof question.text === 'string' && question.text) {
                    // Old format: plain text (backwards compatibility)
                    questionPrompt = `<p style="margin-bottom: 15px; font-size: 16px; color: #000;">${escapeHtml(question.text)}</p>`;
                } else {
                    questionPrompt = `<p style="margin-bottom: 15px; font-size: 16px; color: #000;">[No question text]</p>`;
                }
                
                questionCard.innerHTML = `
                    <h4>Question ${questionNumber}</h4>
                    ${selectionInfo}
                    <div style="margin-bottom: 15px; font-size: 16px; color: #000;">${questionPrompt}</div>
                    <div class="options-container">
                        ${question.options && question.options.length > 0 ? question.options.map((option, optIndex) => `
                            <div class="option" onclick="selectOption('${question.id}', ${optIndex})">
                                <input type="radio" name="question_${question.id}" value="${optIndex}" id="opt_${question.id}_${optIndex}">
                                <label class="option-label" for="opt_${question.id}_${optIndex}">
                                    ${String.fromCharCode(65 + optIndex)}. ${escapeHtml(option.text || option)}
                                </label>
                            </div>
                        `).join('') : '<p style="color: red;">No options available for this question</p>'}
                    </div>
                `;
                
                // Append to grid - CSS handles the 2-column layout
                questionsGrid.appendChild(questionCard);
            });
            
            // For now, hide submit section for writing sections (no backend endpoint yet)
            // Show submit section
            const submitSection = document.getElementById('submitSection');
            const resultsSection = document.getElementById('resultsSection');
            if (submitSection) submitSection.style.display = 'block';
            if (resultsSection) resultsSection.style.display = 'none';
        }
        
        async function displayPassage(passage, questions) {
            // Hide all category content containers (which contain the list sections)
            document.querySelectorAll('.category-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Hide all list sections individually as well
            const passagesListSection = document.getElementById('passagesListSection');
            const readingLessonsListSection = document.getElementById('readingLessonsListSection');
            const writingSectionsListSection = document.getElementById('writingSectionsListSection');
            const writingLessonsListSection = document.getElementById('writingLessonsListSection');
            const mathSectionsListSection = document.getElementById('mathSectionsListSection');
            const mathLessonsListSection = document.getElementById('mathLessonsListSection');
            const passageDetailSection = document.getElementById('passageDetailSection');
            
            if (passagesListSection) passagesListSection.style.display = 'none';
            if (readingLessonsListSection) readingLessonsListSection.style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // if (writingSectionsListSection) writingSectionsListSection.style.display = 'none';
            if (writingLessonsListSection) writingLessonsListSection.style.display = 'none';
            if (mathSectionsListSection) mathSectionsListSection.style.display = 'none';
            if (mathLessonsListSection) mathLessonsListSection.style.display = 'none';
            if (passageDetailSection) passageDetailSection.style.display = 'block';
            
            // Hide word of the day for reading passages (too busy)
            // Show word of the day only for writing/math sections, not reading passages
            const wordOfDay = document.getElementById('wordOfDay');
            const questionExplanation = document.getElementById('questionExplanation');
            if (wordOfDay) wordOfDay.style.display = 'none'; // Hide for reading passages
            if (questionExplanation) {
                questionExplanation.style.display = 'block';
                questionExplanation.classList.remove('hidden');
            }
            
            // Show attempt history button if user is logged in
            const attemptHistoryContainer = document.getElementById('attemptHistoryButtonContainer');
            if (authToken && passage.id) {
                try {
                    const attemptsResponse = await fetch(`${API_BASE}/progress/passages/${passage.id}/attempts`, {
                        headers: {'Authorization': `Bearer ${authToken}`}
                    });
                    if (attemptsResponse.ok) {
                        const attempts = await attemptsResponse.json();
                        if (attempts.length > 0) {
                            attemptHistoryContainer.innerHTML = `
                                <button class="btn btn-secondary" onclick="showAttemptHistory('${passage.id}')" style="font-size: 12px; padding: 6px 12px;">
                                    View Attempts (${attempts.length})
                                </button>
                            `;
                        } else {
                            attemptHistoryContainer.innerHTML = '';
                        }
                    } else {
                        attemptHistoryContainer.innerHTML = '';
                    }
                } catch (error) {
                    console.error('Failed to load attempt count:', error);
                    attemptHistoryContainer.innerHTML = '';
                }
            } else {
                attemptHistoryContainer.innerHTML = '';
            }
            
            // Format passage in SAT style (50 chars per line, two columns, line numbers every 5)
            const formattedContent = formatPassageForSAT(passage.content);
            
            const passageContent = document.getElementById('passageContent');
            if (!passageContent) {
                console.error('passageContent element not found!');
                return;
            }
            passageContent.innerHTML = `
                <h2 style="color: #3498DB; margin-bottom: 15px;">${passage.title}</h2>
                <div class="passage-reading-container">
                    <div class="passage-content-sat">${formattedContent}</div>
                </div>
            `;
            
            // Adjust font size after content is loaded
            setTimeout(adjustReaderFont, 100);
            
            // Display questions in a grid (maintains order on mobile)
            const questionsContainer = document.getElementById('questionsContainer');
            if (!questionsContainer) {
                console.error('questionsContainer element not found!');
                return;
            }
            questionsContainer.innerHTML = '<div class="questions-grid"></div>';
            
            const questionsGrid = questionsContainer.querySelector('.questions-grid');
            
            // Debug: log questions to see what we're getting
            console.log('Questions received:', questions.questions);
            
            // Sort questions by order field to ensure correct display order
            const sortedQuestions = [...(questions.questions || [])].sort((a, b) => {
                const orderA = a.order !== undefined ? a.order : 999;
                const orderB = b.order !== undefined ? b.order : 999;
                return orderA - orderB;
            });
            
            // Store questions in map for explanation access
            currentQuestionsMap = {};
            sortedQuestions.forEach(question => {
                currentQuestionsMap[question.id] = question;
            });
            
            sortedQuestions.forEach((question, index) => {
                // Use question.order if available, otherwise use index + 1
                const questionNumber = question.order !== undefined ? question.order : (index + 1);
                const questionCard = document.createElement('div');
                questionCard.className = 'question-card';
                questionCard.innerHTML = `
                    <h4>Question ${questionNumber}</h4>
                    <p style="margin-bottom: 15px; font-size: 16px; color: #000;">${question.text}</p>
                    <div class="options-container">
                        ${question.options && question.options.length > 0 ? question.options.map((option, optIndex) => `
                            <div class="option" onclick="selectOption('${question.id}', ${optIndex})">
                                <input type="radio" name="question_${question.id}" value="${optIndex}" id="opt_${question.id}_${optIndex}">
                                <label class="option-label" for="opt_${question.id}_${optIndex}">
                                    ${String.fromCharCode(65 + optIndex)}. ${option}
                                </label>
                            </div>
                        `).join('') : '<p style="color: red;">No options available for this question</p>'}
                    </div>
                `;
                
                // Append to grid - CSS handles the 2-column layout
                questionsGrid.appendChild(questionCard);
            });
            
            // Show submit button, hide results
            const submitSection = document.getElementById('submitSection');
            const resultsSection = document.getElementById('resultsSection');
            if (submitSection) submitSection.style.display = 'block';
            if (resultsSection) resultsSection.style.display = 'none';
        }
        
        async function displayMathSection(mathSection, questions) {
            // Hide all category content containers (which contain the list sections)
            document.querySelectorAll('.category-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Hide all list sections individually as well
            const passagesListSection = document.getElementById('passagesListSection');
            const readingLessonsListSection = document.getElementById('readingLessonsListSection');
            const writingSectionsListSection = document.getElementById('writingSectionsListSection');
            const writingLessonsListSection = document.getElementById('writingLessonsListSection');
            const mathSectionsListSection = document.getElementById('mathSectionsListSection');
            const mathLessonsListSection = document.getElementById('mathLessonsListSection');
            const passageDetailSection = document.getElementById('passageDetailSection');
            
            if (passagesListSection) passagesListSection.style.display = 'none';
            if (readingLessonsListSection) readingLessonsListSection.style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // if (writingSectionsListSection) writingSectionsListSection.style.display = 'none';
            if (writingLessonsListSection) writingLessonsListSection.style.display = 'none';
            if (mathSectionsListSection) mathSectionsListSection.style.display = 'none';
            if (mathLessonsListSection) mathLessonsListSection.style.display = 'none';
            if (passageDetailSection) passageDetailSection.style.display = 'block';
            
            // Hide word of the day, show explanation container
            const wordOfDay = document.getElementById('wordOfDay');
            const questionExplanation = document.getElementById('questionExplanation');
            if (wordOfDay) wordOfDay.style.display = 'none';
            if (questionExplanation) {
                questionExplanation.style.display = 'block';
                questionExplanation.classList.remove('hidden');
            }
            
            // Show attempt history button if user is logged in
            const attemptHistoryContainer = document.getElementById('attemptHistoryButtonContainer');
            if (authToken && mathSection.id) {
                try {
                    const attemptsResponse = await fetch(`${API_BASE}/progress/math-sections/${mathSection.id}/attempts`, {
                        headers: {'Authorization': `Bearer ${authToken}`}
                    });
                    if (attemptsResponse.ok) {
                        const attempts = await attemptsResponse.json();
                        if (attempts.length > 0) {
                            attemptHistoryContainer.innerHTML = `
                                <button class="btn btn-secondary" onclick="showMathSectionAttemptHistory('${mathSection.id}')" style="font-size: 12px; padding: 6px 12px;">
                                    View Attempts (${attempts.length})
                                </button>
                            `;
                        } else {
                            attemptHistoryContainer.innerHTML = '';
                        }
                    }
                } catch (error) {
                    console.error('Failed to load attempt history:', error);
                }
            } else {
                attemptHistoryContainer.innerHTML = '';
            }
            
            // Display math section content
            const passageContent = document.getElementById('passageContent');
            if (!passageContent) {
                console.error('passageContent element not found!');
                return;
            }
            passageContent.innerHTML = `
                <h2 style="color: #3498DB; margin-bottom: 15px;">${escapeHtml(mathSection.title)}</h2>
            `;
            
            // Display questions in two columns
            const questionsContainer = document.getElementById('questionsContainer');
            if (!questionsContainer) {
                console.error('questionsContainer element not found!');
                return;
            }
            questionsContainer.innerHTML = '<div class="questions-grid"></div>';
            
            const questionsGrid = questionsContainer.querySelector('.questions-grid');
            
            const questionsList = questions.results || questions.questions || [];
            
            // Sort questions by order field to ensure correct display order
            const sortedMathQuestions = [...questionsList].sort((a, b) => {
                const orderA = a.order !== undefined ? a.order : 999;
                const orderB = b.order !== undefined ? b.order : 999;
                return orderA - orderB;
            });
            
            // Store questions in map for explanation access
            currentQuestionsMap = {};
            sortedMathQuestions.forEach(question => {
                currentQuestionsMap[question.id] = question;
            });
            
            sortedMathQuestions.forEach((question, index) => {
                const questionNumber = question.order !== undefined ? question.order : (index + 1);
                const questionCard = document.createElement('div');
                questionCard.className = 'question-card';
                
                // Process question prompt - handle both JSON blocks and plain text (for backwards compatibility)
                let questionPrompt = '';
                const mathAssets = (mathSection && mathSection.assets) || (currentMathSectionData && currentMathSectionData.assets) || [];
                const mathSectionId = (mathSection && (mathSection.section_id || mathSection.id)) || (currentMathSectionData && (currentMathSectionData.section_id || currentMathSectionData.id)) || 'unknown';
                
                if (Array.isArray(question.prompt)) {
                    // New format: array of blocks
                    questionPrompt = formatMathPrompt(question.prompt, mathAssets, mathSectionId);
                } else if (typeof question.prompt === 'string' && question.prompt) {
                    // Old format: plain text (backwards compatibility)
                    questionPrompt = replaceDiagramSentinels(question.prompt, mathAssets, mathSectionId);
                    questionPrompt = replaceUnderlineSentinels(questionPrompt);
                    questionPrompt = `<p style="margin-bottom: 15px; font-size: 16px; color: #000;">${questionPrompt}</p>`;
                } else {
                    // Fallback
                    questionPrompt = `<p style="margin-bottom: 15px; font-size: 16px; color: #000;">${escapeHtml(question.text || '')}</p>`;
                }
                
                // Process choices for diagrams (math sections - we're in displayMathSection function)
                let processedChoices = question.choices || [];
                if (processedChoices.length > 0) {
                    processedChoices = processedChoices.map(choice => {
                        const choiceText = typeof choice === 'string' ? choice : (choice.text || choice);
                        if (typeof choiceText === 'string' && choiceText.includes('[[Diagram')) {
                            // Process diagram sentinels in choice text
                            const processed = replaceDiagramSentinels(choiceText, mathAssets, mathSectionId);
                            // Return object format if original was object, otherwise return processed string
                            if (typeof choice === 'object' && choice !== null) {
                                return { ...choice, text: processed };
                            }
                            return processed;
                        }
                        return choice;
                    });
                }
                
                questionCard.innerHTML = `
                    <h4>Question ${questionNumber}</h4>
                    <div style="margin-bottom: 15px; font-size: 16px; color: #000;">${questionPrompt}</div>
                    <div class="options-container">
                        ${processedChoices && processedChoices.length > 0 ? processedChoices.map((choice, optIndex) => {
                            const choiceText = typeof choice === 'string' ? choice : (choice.text || choice);
                            // If choiceText contains HTML (from diagram processing), don't escape it
                            const displayText = typeof choiceText === 'string' && choiceText.includes('<img') 
                                ? choiceText 
                                : escapeHtml(choiceText);
                            return `
                            <div class="option" onclick="selectOption('${question.id}', ${optIndex})">
                                <input type="radio" name="question_${question.id}" value="${optIndex}" id="opt_${question.id}_${optIndex}">
                                <label class="option-label" for="opt_${question.id}_${optIndex}">
                                    ${String.fromCharCode(65 + optIndex)}. ${displayText}
                                </label>
                            </div>
                        `;
                        }).join('') : '<p style="color: red;">No options available for this question</p>'}
                    </div>
                `;
                
                // Append to grid - CSS handles the 2-column layout
                questionsGrid.appendChild(questionCard);
            });
            
            // Show submit section
            const submitSection = document.getElementById('submitSection');
            const resultsSection = document.getElementById('resultsSection');
            if (submitSection) submitSection.style.display = 'block';
            if (resultsSection) resultsSection.style.display = 'none';
        }
        
        function displayMathSectionPreview(mathSection) {
            // Hide all list sections, show detail view
            document.getElementById('passagesListSection').style.display = 'none';
            document.getElementById('lessonsListSection').style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // document.getElementById('writingSectionsListSection').style.display = 'none';
            document.getElementById('mathSectionsListSection').style.display = 'none';
            document.getElementById('passageDetailSection').style.display = 'block';
            
            let contentHTML = `<h2 style="color: #3498DB; margin-bottom: 15px;">${escapeHtml(mathSection.title)} <span class="premium-badge">PREMIUM</span> <span class="premium-lock"></span></h2>`;
            contentHTML += '<div class="lesson-content premium-preview-overlay" style="max-width: 800px; margin: 0 auto;">';
            contentHTML += '<p style="margin-bottom: 15px; color: #000; line-height: 1.6;">This is a premium math section. Upgrade to access the full content with detailed explanations and diagrams.</p>';
            contentHTML += '</div>';
            
            // Add upgrade prompt
            contentHTML += `
                <div style="text-align: center; margin-top: 30px; padding: 30px; background: #f9f9f9; border-radius: 8px;">
                    <h3 style="color: #3498DB; margin-bottom: 15px;">Upgrade to Premium</h3>
                    <p style="color: #666; margin-bottom: 20px;">Get access to all premium math sections with detailed explanations and diagrams.</p>
                    <button class="btn btn-primary" onclick="showUpgradeModal()" style="font-size: 16px; padding: 12px 30px;">
                        Upgrade Now ($5/month)
                    </button>
                </div>
            `;
            
            document.getElementById('passageContent').innerHTML = contentHTML;
            document.getElementById('questionsContainer').innerHTML = '';
            document.getElementById('submitSection').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('attemptHistoryButtonContainer').innerHTML = '';
        }
        
        function selectOption(questionId, optionIndex) {
            userAnswers[questionId] = optionIndex;
            
            // Update visual selection
            const questionCard = document.querySelector(`input[name="question_${questionId}"]`)?.closest('.question-card');
            if (questionCard) {
                // Find the question to check correct answer
                const question = currentLessonData?.questions?.find(q => String(q.id) === String(questionId));
                const correctAnswerIndex = question?.correct_answer_index;
                const isCorrect = optionIndex === correctAnswerIndex;
                
                // Update all options with correct/incorrect styling
                questionCard.querySelectorAll('.option').forEach((opt, idx) => {
                    opt.classList.remove('selected', 'correct', 'incorrect');
                    if (idx === optionIndex) {
                        opt.classList.add('selected');
                        if (currentLessonId && currentLessonData && correctAnswerIndex !== undefined) {
                            opt.classList.add(isCorrect ? 'correct' : 'incorrect');
                        }
                    } else if (currentLessonId && currentLessonData && idx === correctAnswerIndex) {
                        // Mark correct answer even if not selected
                        opt.classList.add('correct');
                    }
                });
                
                const selectedOption = questionCard.querySelector(`#opt_${questionId}_${optionIndex}`);
                if (selectedOption) {
                    selectedOption.checked = true;
                }
            }
            
            // For lessons: show explanation inline with correct/incorrect feedback
            // For passages/sections: don't show explanation until after submit
            if (currentLessonId && currentLessonData) {
                const explanationDiv = document.getElementById(`explanation_${questionId}`);
                if (explanationDiv) {
                    // Find the question to check if answer is correct
                    const question = currentLessonData.questions?.find(q => String(q.id) === String(questionId));
                    if (question) {
                        const isCorrect = optionIndex === question.correct_answer_index;
                        const correctAnswerIndex = question.correct_answer_index;
                        
                        // Get the question card to find the choices
                        const questionCard = document.querySelector(`input[name="question_${questionId}"]`)?.closest('.question-card');
                        const choices = questionCard?.querySelectorAll('.option-label') || [];
                        const correctChoiceText = choices[correctAnswerIndex]?.textContent?.trim() || `Option ${String.fromCharCode(65 + correctAnswerIndex)}`;
                        
                        // Update explanation div to show feedback
                        const correctColor = '#28a745';
                        const incorrectColor = '#dc3545';
                        const feedbackColor = isCorrect ? correctColor : incorrectColor;
                        const feedbackIcon = isCorrect ? '' : '';
                        const feedbackText = isCorrect ? 'Correct!' : 'Incorrect';
                        
                        // Get existing explanation content (everything after "Explanation:")
                        const existingContent = explanationDiv.innerHTML;
                        const explanationMatch = existingContent.match(/<strong>Explanation:<\/strong>(.*)/s);
                        const explanationContent = explanationMatch ? explanationMatch[1] : '';
                        
                        // Update with feedback
                        explanationDiv.innerHTML = `
                            <div style="margin-bottom: 10px; padding: 8px; border-radius: 4px; background: ${isCorrect ? '#d4edda' : '#f8d7da'}; border-left: 3px solid ${feedbackColor};">
                                <strong style="color: ${feedbackColor}; font-size: 16px;">${feedbackIcon} ${feedbackText}</strong>
                                ${!isCorrect ? `<div style="margin-top: 6px; color: #333; font-size: 14px;">Correct answer: <strong>${correctChoiceText}</strong></div>` : ''}
                            </div>
                            <div>
                                <strong>Explanation:</strong>${explanationContent}
                            </div>
                        `;
                    }
                    explanationDiv.style.display = 'block';
                }
            }
            // Removed: Sidebar explanation for passages/sections - explanations now only show after submit
        }
        
        async function submitAnswers() {
            // Check if we're on a passage, writing section, math section, or lesson
            if (!currentPassageId && !currentWritingSectionId && !currentMathSectionId && !currentLessonId) return;
            
            // Handle lessons separately
            if (currentLessonId && currentLessonData) {
                try {
                    await displayLessonResults(currentLessonData);
                } catch (error) {
                    console.error('Error displaying lesson results:', error);
                }
                return;
            }
            
            // Determine what type of section we're on
            const isWritingSection = !!currentWritingSectionId;
            const isMathSection = !!currentMathSectionId;
            const currentId = isWritingSection ? currentWritingSectionId : 
                            isMathSection ? currentMathSectionId : 
                            currentPassageId;
            const currentData = isWritingSection ? currentWritingSectionData : 
                              isMathSection ? currentMathSectionData : 
                              currentPassageData;
            
            if (!currentId || !currentData) return;
            
            // Check if all questions are answered
            // For math sections, questions might be in a different structure
            const questionsList = currentData.questions || (currentData.results || []);
            const totalQuestions = Array.isArray(questionsList) ? questionsList.length : 0;
            if (Object.keys(userAnswers).length < totalQuestions) {
                if (!confirm(`You have only answered ${Object.keys(userAnswers).length} out of ${totalQuestions} questions. Submit anyway?`)) {
                    return;
                }
            }
            
            try {
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                // Convert answers to API format
                const answers = Object.entries(userAnswers).map(([questionId, selectedIndex]) => ({
                    question_id: questionId,
                    selected_option_index: selectedIndex
                }));
                
                // Submit answers - use appropriate endpoint
                const submitEndpoint = isWritingSection
                    ? `${API_BASE}/progress/writing-sections/${currentId}/submit`
                    : isMathSection
                    ? `${API_BASE}/progress/math-sections/${currentId}/submit`
                    : `${API_BASE}/progress/passages/${currentId}/submit`;
                
                const submitResponse = await fetch(submitEndpoint, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        answers: answers,
                        time_spent_seconds: 0 // Could track this if needed
                    })
                });
                
                if (!submitResponse.ok) {
                    const error = await submitResponse.json();
                    alert(error.error?.message || 'Failed to submit answers. Please try again.');
                    return;
                }
                
                // Get submit response data (includes correct_count and total_questions)
                const submitData = await submitResponse.json();
                
                // Get review data for detailed answer breakdown
                const reviewEndpoint = isWritingSection
                    ? `${API_BASE}/progress/writing-sections/${currentId}/review`
                    : isMathSection
                    ? `${API_BASE}/progress/math-sections/${currentId}/review`
                    : `${API_BASE}/progress/passages/${currentId}/review`;
                
                const reviewResponse = await fetch(reviewEndpoint, {
                    headers: authToken ? {'Authorization': `Bearer ${authToken}`} : {}
                });
                
                if (reviewResponse.ok) {
                    const reviewData = await reviewResponse.json();
                    // Use correct_count and total_questions from submit response (more reliable)
                    reviewData.correct_count = submitData.correct_count || reviewData.correct_count || 0;
                    const questionsListForTotal = currentData.questions || (currentData.results || []);
                    reviewData.total_questions = submitData.total_questions || reviewData.total_questions || (Array.isArray(questionsListForTotal) ? questionsListForTotal.length : 0);
                    displayResults(reviewData, isWritingSection, isMathSection);
                } else {
                    // Fallback: use submit response data directly
                    if (submitData.correct_count !== undefined && submitData.total_questions !== undefined) {
                        displayResults({
                            correct_count: submitData.correct_count,
                            total_questions: submitData.total_questions,
                            answers: submitData.answers || []
                        }, isWritingSection, isMathSection);
                    } else {
                        // Final fallback: show results from data
                        if (isWritingSection) {
                            displayResultsFromWritingSection(currentData);
                        } else {
                            displayResultsFromPassage(currentData);
                        }
                    }
                }
                
                // If this is a diagnostic passage, also submit to diagnostic endpoint
                if (!isWritingSection && !isMathSection && currentPassageData && currentPassageData.is_diagnostic && authToken) {
                    try {
                        // Build answers with is_correct flag for diagnostic
                        const diagnosticAnswers = answers.map(answer => {
                            const question = questionsList.find(q => String(q.id) === String(answer.question_id));
                            return {
                                question_id: answer.question_id,
                                selected_option_index: answer.selected_option_index,
                                is_correct: question ? answer.selected_option_index === question.correct_answer_index : false
                            };
                        });
                        
                        await fetch(`${API_BASE}/diagnostic/submit`, {
                            method: 'POST',
                            headers: headers,
                            body: JSON.stringify({
                                passage_id: currentPassageId,
                                answers: diagnosticAnswers
                            })
                        });
                        
                        // Show diagnostic completion message
                        const resultsSection = document.getElementById('resultsSection');
                        const diagnosticBanner = document.createElement('div');
                        diagnosticBanner.style.cssText = 'background: var(--bg-secondary); padding: 20px; border-radius: 8px; margin-top: 20px; text-align: center; border: 1px solid var(--border-color);';
                        diagnosticBanner.innerHTML = `
                            <h3 style="color: var(--text-primary); margin-bottom: 12px;">Reading Diagnostic Complete!</h3>
                            <p style="color: var(--text-secondary); margin-bottom: 16px;">Your study plan has been updated with personalized recommendations.</p>
                            <button class="btn btn-primary" onclick="showProfile()">View Your Study Plan</button>
                        `;
                        resultsSection.appendChild(diagnosticBanner);
                    } catch (diagnosticError) {
                        console.error('Failed to submit diagnostic:', diagnosticError);
                    }
                }
                
            } catch (error) {
                console.error('Failed to submit answers:', error);
                alert('Network error. Please try again.');
            }
        }
        
        let lastAttemptData = null; // Store attempt data for anonymous users to save on registration
        
        function displayResults(reviewData, isWritingSection = false, isMathSection = false) {
            const resultsSection = document.getElementById('resultsSection');
            resultsSection.style.display = 'block';
            document.getElementById('submitSection').style.display = 'none';
            
            const currentId = isMathSection ? currentMathSectionId : 
                            isWritingSection ? currentWritingSectionId : 
                            currentPassageId;
            const currentData = isMathSection ? currentMathSectionData : 
                              isWritingSection ? currentWritingSectionData : 
                              currentPassageData;
            
            const correctCount = reviewData.correct_count || 0;
            // For math sections, questions might be in results array
            const questionsList = currentData ? (currentData.questions || currentData.results || []) : [];
            const totalQuestions = reviewData.total_questions || (Array.isArray(questionsList) ? questionsList.length : 0);
            const percentage = Math.round((correctCount / totalQuestions) * 100);
            
            // Store attempt data for anonymous users (to save on registration)
            if (!authToken && reviewData.attempt_id) {
                lastAttemptData = {
                    [isMathSection ? 'math_section_id' : (isWritingSection ? 'writing_section_id' : 'passage_id')]: currentId,
                    attempt_id: reviewData.attempt_id,
                    answers: reviewData.answers || [],
                    score: reviewData.score,
                    correct_count: correctCount,
                    total_questions: totalQuestions,
                    is_writing_section: isWritingSection,
                    is_math_section: isMathSection
                };
            }
            
            let resultsHTML = '';
            
            // Show attempt history button for logged-in users
            if (authToken && currentId) {
                if (isMathSection) {
                    resultsHTML += `
                        <div style="margin: 20px 0; text-align: center;">
                            <button class="btn btn-secondary" onclick="setTimeout(() => showMathSectionAttemptHistory('${currentId}'), 500)" style="font-size: 14px; padding: 10px 20px;">
                                View All Attempts
                            </button>
                        </div>
                    `;
                } else if (isWritingSection) {
                    resultsHTML += `
                        <div style="margin: 20px 0; text-align: center;">
                            <button class="btn btn-secondary" onclick="setTimeout(() => showWritingSectionAttemptHistory('${currentId}'), 500)" style="font-size: 14px; padding: 10px 20px;">
                                View All Attempts
                            </button>
                        </div>
                    `;
                } else {
                    resultsHTML += `
                        <div style="margin: 20px 0; text-align: center;">
                            <button class="btn btn-secondary" onclick="setTimeout(() => showAttemptHistory('${currentId}'), 500)" style="font-size: 14px; padding: 10px 20px;">
                                View All Attempts
                            </button>
                        </div>
                    `;
                }
            }
            
            // Show registration prompt for anonymous users
            if (!authToken) {
                resultsHTML += `
                    <div style="background: #e3f2fd; border: 2px solid #3498DB; border-radius: 8px; padding: 20px; margin: 20px 0; text-align: center;">
                        <h4 style="color: #3498DB; margin-bottom: 10px;"> Want to track your progress?</h4>
                        <p style="color: #333; margin-bottom: 15px;">Register now to save this attempt and track your improvement over time!</p>
                        <button class="btn btn-primary" onclick="showRegisterModalAndSaveAttempt()" style="font-size: 16px; padding: 12px 24px;">
                            Register & Save This Attempt
                        </button>
                        <p style="color: #666; font-size: 12px; margin-top: 10px;">Free to register  No credit card required</p>
                    </div>
                `;
            }
            
            // Show each question with correct/incorrect status
            // For math sections, get questions from currentQuestionsMap (they're stored there)
            let questions = [];
            if (isMathSection) {
                // Try multiple sources for questions
                // 1. currentQuestionsMap (populated when section was displayed)
                questions = Object.values(currentQuestionsMap);
                
                // 2. If empty, try currentData
                if (questions.length === 0 && currentData) {
                    questions = currentData.questions || currentData.results || [];
                }
                
                // Sort by order if available
                questions.sort((a, b) => {
                    const orderA = a.order !== undefined ? a.order : 999;
                    const orderB = b.order !== undefined ? b.order : 999;
                    return orderA - orderB;
                });
            } else {
                // For passages and writing sections, get from currentData
                questions = currentData ? (currentData.questions || currentData.results || []) : [];
            }
            
            console.log('Displaying results - questions found:', questions.length, 'isMathSection:', isMathSection, 'currentQuestionsMap size:', Object.keys(currentQuestionsMap).length, 'currentData has questions:', currentData ? !!(currentData.questions || currentData.results) : false);
            
            if (questions.length === 0) {
                console.error('No questions found for results display!', {
                    isMathSection,
                    currentData: currentData ? Object.keys(currentData) : null,
                    currentQuestionsMapSize: Object.keys(currentQuestionsMap).length
                });
                resultsSection.innerHTML = resultsHTML + '<p style="color: red; padding: 20px;">Error: Could not load questions for results display.</p>';
                return;
            }
            
            // Sort questions by order field to ensure correct display order
            const sortedResultQuestions = [...questions].sort((a, b) => {
                const orderA = a.order !== undefined ? a.order : 999;
                const orderB = b.order !== undefined ? b.order : 999;
                return orderA - orderB;
            });
            
            sortedResultQuestions.forEach((question, index) => {
                // Ensure question ID is a string for comparison
                const questionIdStr = String(question.id);
                const userAnswer = userAnswers[questionIdStr] !== undefined ? userAnswers[questionIdStr] : userAnswers[question.id];
                const reviewAnswer = reviewData.answers && reviewData.answers.find(a => String(a.question_id) === questionIdStr);
                const isCorrect = reviewAnswer ? reviewAnswer.is_correct : (userAnswer === question.correct_answer_index);
                
                // Get options - handle both array of strings and array of objects
                let options = question.options || question.choices || [];
                
                // Process options for diagrams in math sections
                if (isMathSection && options.length > 0) {
                    const mathAssets = currentMathSectionData?.assets || [];
                    const mathSectionId = currentMathSectionData?.section_id || currentMathSectionData?.id || '';
                    options = options.map(option => {
                        const optionText = typeof option === 'string' ? option : (option.text || option);
                        if (typeof optionText === 'string' && optionText.includes('[[Diagram')) {
                            // Process diagram sentinels in option text
                            const processed = replaceDiagramSentinels(optionText, mathAssets, mathSectionId);
                            // Return object format if original was object, otherwise return processed string
                            if (typeof option === 'object' && option !== null) {
                                return { ...option, text: processed };
                            }
                            return processed;
                        }
                        return option;
                    });
                }
                
                const userOption = options[userAnswer];
                const correctOption = options[question.correct_answer_index];
                
                // Get question text - math sections use 'prompt', others use 'text'
                const questionText = question.prompt || question.text || '';
                
                // Use question.order if available, otherwise use index + 1
                const questionNumber = question.order !== undefined ? question.order : (index + 1);
                
                // Format explanation - math sections use arrays, others use strings
                let explanationText = '';
                if ((reviewAnswer && reviewAnswer.explanation) || question.explanation) {
                    const rawExplanation = (reviewAnswer && reviewAnswer.explanation) || question.explanation;
                    console.log('Raw explanation before formatting:', rawExplanation, 'type:', typeof rawExplanation, 'isArray:', Array.isArray(rawExplanation));
                    
                    explanationText = formatMathExplanation(rawExplanation, isMathSection);
                    console.log('After formatMathExplanation:', explanationText, 'type:', typeof explanationText);
                    
                    // CRITICAL: Ensure it's a string - if formatMathExplanation failed, convert it
                    if (typeof explanationText !== 'string') {
                        console.error('formatMathExplanation did not return a string!', explanationText);
                        // If it's still an array/object, try to format it manually
                        if (Array.isArray(explanationText) || (explanationText && typeof explanationText === 'object')) {
                            explanationText = formatMathExplanation(explanationText, isMathSection);
                        }
                        // Final fallback - convert to string
                        if (typeof explanationText !== 'string') {
                            explanationText = JSON.stringify(explanationText);
                        }
                    }
                    
                    // Apply sentinel replacement for math sections
                    if (isMathSection && currentMathSectionData && typeof explanationText === 'string') {
                        explanationText = replaceDiagramSentinels(explanationText, currentMathSectionData.assets || [], currentMathSectionData.section_id || currentMathSectionData.id);
                    }
                    // Replace underline sentinels
                    if (typeof explanationText === 'string') {
                        explanationText = replaceUnderlineSentinels(explanationText);
                    }
                    
                    console.log('Final explanationText:', explanationText, 'type:', typeof explanationText);
                }
                
                resultsHTML += `
                    <div class="question-card">
                        <h4>Question ${questionNumber} ${isCorrect ? '' : ''}</h4>
                        <p style="margin-bottom: 15px; font-size: 16px; color: #000;">${questionText}</p>
                        <div class="options-container">
                            ${options.map((option, optIndex) => {
                                let optionClass = 'option';
                                if (optIndex === question.correct_answer_index) {
                                    optionClass += ' correct';
                                } else if (optIndex === userAnswer && !isCorrect) {
                                    optionClass += ' incorrect';
                                }
                                
                                // Handle both object format (from passage detail) and string format (from questions endpoint)
                                let optionText = typeof option === 'string' ? option : option.text;
                                // If optionText contains HTML (from diagram processing), don't escape it
                                if (isMathSection && typeof optionText === 'string' && (optionText.includes('<img') || optionText.includes('[[Diagram'))) {
                                    // Already processed with diagrams, use as-is (or process if still has sentinel)
                                    if (optionText.includes('[[Diagram')) {
                                        const mathAssets = currentMathSectionData?.assets || [];
                                        const mathSectionId = currentMathSectionData?.section_id || currentMathSectionData?.id || '';
                                        optionText = replaceDiagramSentinels(optionText, mathAssets, mathSectionId);
                                    }
                                } else {
                                    optionText = escapeHtml(optionText);
                                }
                                
                                return `
                                    <div class="${optionClass}">
                                        <input type="radio" disabled ${optIndex === userAnswer ? 'checked' : ''}>
                                        <label class="option-label">
                                            ${String.fromCharCode(65 + optIndex)}. ${optionText}
                                            ${optIndex === question.correct_answer_index ? ' (Correct)' : ''}
                                            ${optIndex === userAnswer && !isCorrect ? ' (Your Answer)' : ''}
                                        </label>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        ${explanationText ? `
                            <div class="explanation" style="white-space: pre-wrap; margin-top: 12px; padding: 12px 16px; background: var(--bg-secondary); border-left: 3px solid var(--accent-color); border-radius: 4px;">
                                <strong style="color: var(--accent-color); display: block; margin-bottom: 8px;">Explanation:</strong>
                                <div style="line-height: 1.6; color: var(--text-primary);">${explanationText}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            // Add penguin message after questions
            if (totalQuestions > 0) {
                const penguinMessage = getPenguinMessage(correctCount, totalQuestions, !currentData?.is_diagnostic);
                resultsHTML += `
                    <div style="background: #f0f8ff; border: 2px solid var(--accent-color); border-radius: 12px; padding: 24px; margin-top: 32px; text-align: center;">
                        <img src="/static/web/images/penguin.png" alt="Penguin" style="width: 80px; height: auto; margin-bottom: 16px;" />
                        <div style="font-size: 24px; font-weight: 700; color: var(--text-primary); margin-bottom: 12px;">${correctCount} / ${totalQuestions} (${percentage}%)</div>
                        <p style="font-size: 18px; font-weight: 600; color: var(--text-primary); margin: 0;">${penguinMessage}</p>
                    </div>
                `;
            }
            
            resultsSection.innerHTML = resultsHTML;
            
            // Scroll to results
            resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        async function displayLessonResults(lessonData) {
            // Display results for lesson questions
            const resultsSection = document.getElementById('resultsSection');
            const submitSection = document.getElementById('submitSection');
            
            console.log('displayLessonResults called', { lessonData, resultsSection, submitSection });
            
            if (!resultsSection) {
                console.error('resultsSection element not found!');
                return;
            }
            
            resultsSection.style.display = 'block';
            if (submitSection) submitSection.style.display = 'none';
            
            if (!lessonData.questions || lessonData.questions.length === 0) {
                resultsSection.innerHTML = '<p>No questions in this lesson.</p>';
                return;
            }
            
            // For diagnostic lessons, we want ALL questions, not just current page
            const isDiagnostic = lessonData.is_diagnostic || false;
            
            // Get current page index and find questions on current page only (for non-diagnostics)
            const currentPageIndex = lessonData.currentPageIndex || 0;
            const pages = lessonData.pages || [];
            
            // Get chunk indices from current page
            const currentPageChunkIndices = new Set();
            if (currentPageIndex >= 0 && currentPageIndex < pages.length) {
                const currentPage = pages[currentPageIndex];
                currentPage.forEach(({chunkIdx}) => {
                    currentPageChunkIndices.add(chunkIdx);
                });
            }
            
            // Filter questions to only those on current page (match by chunk_index)
            // For diagnostics, use ALL questions
            let currentPageQuestions;
            if (isDiagnostic) {
                currentPageQuestions = lessonData.questions;
            } else {
                currentPageQuestions = lessonData.questions.filter(q => {
                // Check if question's chunk_index is in the current page
                return q.chunk_index !== undefined && currentPageChunkIndices.has(q.chunk_index);
            });
            }
            
            if (currentPageQuestions.length === 0) {
                resultsSection.innerHTML = '<p style="padding: 20px; color: #666;">No questions on this page. Navigate to a page with questions to submit answers.</p>';
                return;
            }
            
            // Build answers array for backend submission - include ALL questions in the lesson
            // This aggregates all answers across all pages into a single submission
            const allLessonQuestions = lessonData.questions || [];
            const answersForBackend = [];
            let allQuestionsAnswered = true;
            
            allLessonQuestions.forEach(question => {
                const userAnswer = userAnswers[question.id];
                const hasAnswer = userAnswer !== undefined && userAnswer !== null;
                
                if (!hasAnswer) {
                    allQuestionsAnswered = false;
                }
                
                // Include all questions, even if not answered (use -1 for unanswered)
                answersForBackend.push({
                    question_id: question.id,
                    selected_option_index: hasAnswer ? userAnswer : -1
                });
            });
            
            // Variables to store overall lesson results from backend
            let overallCorrectCount = 0;
            let overallTotalQuestions = allLessonQuestions.length;
            let overallScore = 0;
            let overallPercentage = 0;
            let isComplete = false;
            
            // Submit to backend for ALL lessons (logged in or not - track progress)
            // This aggregates all answers from all pages into a single attempt
            if (currentLessonId) {
                try {
                    const headers = {
                        'Content-Type': 'application/json'
                    };
                    if (authToken) {
                        headers['Authorization'] = `Bearer ${authToken}`;
                    }
                    
                    // Determine if this is a complete submission (all questions answered)
                    isComplete = allQuestionsAnswered && answersForBackend.length === allLessonQuestions.length;
                    
                    const submitResponse = await fetch(`${API_BASE}/progress/lessons/${currentLessonId}/submit`, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({
                            answers: answersForBackend,
                            time_spent_seconds: null, // Could track this with a timer
                            is_complete: isComplete  // Tell backend if this is the final submission
                        })
                    });
                    
                    if (submitResponse.ok) {
                        const submitResult = await submitResponse.json();
                        console.log('Lesson submitted successfully:', submitResult);
                        
                        // Use backend response for overall lesson results
                        if (submitResult.correct_count !== undefined) {
                            overallCorrectCount = submitResult.correct_count;
                        }
                        if (submitResult.total_questions !== undefined) {
                            overallTotalQuestions = submitResult.total_questions;
                        }
                        if (submitResult.score !== undefined) {
                            overallScore = submitResult.score;
                            overallPercentage = overallScore;
                        }
                        if (submitResult.is_complete !== undefined) {
                            isComplete = submitResult.is_complete;
                        }
                    } else {
                        console.error('Failed to submit lesson:', await submitResponse.text());
                        // Fallback: calculate from submitted answers
                        overallCorrectCount = answersForBackend.filter(a => {
                            const question = allLessonQuestions.find(q => String(q.id) === String(a.question_id));
                            return question && a.selected_option_index === question.correct_answer_index;
                        }).length;
                        overallPercentage = Math.round((overallCorrectCount / overallTotalQuestions) * 100);
                    }
                    
                } catch (error) {
                    console.error('Error submitting lesson answers:', error);
                    // Fallback: calculate from submitted answers
                    overallCorrectCount = answersForBackend.filter(a => {
                        const question = allLessonQuestions.find(q => String(q.id) === String(a.question_id));
                        return question && a.selected_option_index === question.correct_answer_index;
                    }).length;
                    overallPercentage = Math.round((overallCorrectCount / overallTotalQuestions) * 100);
                }
            } else {
                // Not logged in - calculate locally
                overallCorrectCount = answersForBackend.filter(a => {
                    const question = allLessonQuestions.find(q => String(q.id) === String(a.question_id));
                    return question && a.selected_option_index === question.correct_answer_index;
                }).length;
                overallPercentage = Math.round((overallCorrectCount / overallTotalQuestions) * 100);
            }
            
            // Calculate current page results for display (if showing page-specific questions)
            let pageCorrectCount = 0;
            const pageTotalQuestions = currentPageQuestions.length;
            
            currentPageQuestions.forEach(question => {
                const userAnswer = userAnswers[question.id];
                const isCorrect = userAnswer === question.correct_answer_index;
                if (isCorrect) {
                    pageCorrectCount++;
                }
            });
            
            const pagePercentage = Math.round((pageCorrectCount / pageTotalQuestions) * 100);
            
            // Start with empty results HTML - score will be shown in penguin message box
            let resultsHTML = '';
            
            // For diagnostics, add a note about study plan update
            if (isDiagnostic) {
                resultsHTML += `
                    <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); padding: 20px; border-radius: 8px; margin-bottom: 24px; text-align: center;">
                        <p style="color: var(--text-primary); font-size: 16px; margin-bottom: 16px;">Your study plan has been updated.</p>
                        <button class="btn btn-primary" onclick="showProfile()" style="padding: 10px 20px; font-size: 14px;">
                            View Study Plan
                        </button>
                    </div>
                `;
            }
            
            // Show each question from current page with correct answer and explanation
            currentPageQuestions.forEach((question, index) => {
                const userAnswer = userAnswers[question.id];
                const isCorrect = userAnswer === question.correct_answer_index;
                const questionNumber = question.order !== undefined ? question.order : (index + 1);
                
                // Get options from question object
                let options = question.options || [];
                
                // Process options for diagrams in lessons
                const lessonAssets = lessonData?.assets || currentLessonData?.assets || [];
                const lessonId = lessonData?.lesson_id || currentLessonData?.lesson_id || '';
                if (options.length > 0 && lessonAssets.length > 0) {
                    options = options.map(option => {
                        const optionText = typeof option === 'string' ? option : (option.text || option);
                        if (typeof optionText === 'string' && optionText.includes('[[Diagram')) {
                            // Process diagram sentinels in option text
                            const processed = replaceDiagramSentinels(optionText, lessonAssets, lessonId);
                            // Return object format if original was object, otherwise return processed string
                            if (typeof option === 'object' && option !== null) {
                                return { ...option, text: processed };
                            }
                            return processed;
                        }
                        return option;
                    });
                }
                
                // Process question prompt - handle both JSON blocks and plain text
                let questionPrompt = '';
                if (Array.isArray(question.text)) {
                    // New format: array of blocks
                    questionPrompt = formatLessonPrompt(question.text, lessonAssets, lessonId);
                } else if (typeof question.text === 'string' && question.text) {
                    // Old format: plain text (backwards compatibility)
                    questionPrompt = `<p style="margin-bottom: 15px; font-size: 16px; color: #000;">${escapeHtml(question.text)}</p>`;
                } else {
                    questionPrompt = `<p style="margin-bottom: 15px; font-size: 16px; color: #000;">[No question text]</p>`;
                }
                
                resultsHTML += `
                    <div class="question-card">
                        <h4>Question ${questionNumber} ${isCorrect ? '' : ''}</h4>
                        <div style="margin-bottom: 15px; font-size: 16px; color: #000;">${questionPrompt}</div>
                        <div class="options-container">
                            ${options.map((option, optIndex) => {
                                let optionClass = 'option';
                                if (optIndex === question.correct_answer_index) {
                                    optionClass += ' correct';
                                } else if (optIndex === userAnswer && !isCorrect) {
                                    optionClass += ' incorrect';
                                }
                                
                                let optionText = typeof option === 'string' ? option : (option.text || option);
                                // If optionText contains HTML (from diagram processing), don't escape it
                                let displayText = optionText;
                                if (typeof optionText === 'string' && (optionText.includes('<img') || optionText.includes('[[Diagram'))) {
                                    // Already processed with diagrams, use as-is (or process if still has sentinel)
                                    if (optionText.includes('[[Diagram')) {
                                        displayText = replaceDiagramSentinels(optionText, lessonAssets, lessonId);
                                    }
                                } else if (typeof optionText === 'string') {
                                    displayText = escapeHtml(optionText);
                                }
                                
                                return `
                                    <div class="${optionClass}">
                                        <input type="radio" disabled ${optIndex === userAnswer ? 'checked' : ''}>
                                        <label class="option-label">
                                            ${String.fromCharCode(65 + optIndex)}. ${displayText}
                                            ${optIndex === question.correct_answer_index ? ' (Correct)' : ''}
                                            ${optIndex === userAnswer && !isCorrect ? ' (Your Answer)' : ''}
                                        </label>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        ${question.explanation ? `
                            <div class="explanation" style="margin-top: 15px; padding: 12px; border-left: 4px solid var(--accent-color); border-radius: 4px;">
                                <strong>Explanation:</strong> ${formatExplanation(question.explanation, lessonData.assets || [], lessonData.lesson_id)}
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            // Add penguin message after questions
            const penguinMessage = getPenguinMessage(overallCorrectCount, overallTotalQuestions, !isDiagnostic);
            resultsHTML += `
                <div style="background: #f0f8ff; border: 2px solid var(--accent-color); border-radius: 12px; padding: 24px; margin-top: 32px; text-align: center;">
                    <img src="/static/web/images/penguin.png" alt="Penguin" style="width: 80px; height: auto; margin-bottom: 16px;" />
                    <div style="font-size: 24px; font-weight: 700; color: var(--text-primary); margin-bottom: 12px;">${overallCorrectCount} / ${overallTotalQuestions} (${overallPercentage}%)</div>
                    <p style="font-size: 18px; font-weight: 600; color: var(--text-primary); margin: 0;">${penguinMessage}</p>
                </div>
            `;
            
            console.log('Setting resultsSection innerHTML, length:', resultsHTML.length);
            resultsSection.innerHTML = resultsHTML;
            
            // Scroll to results
            resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        function displayResultsFromPassage(passageData) {
            // Fallback if review endpoint fails - use passage data directly
            const resultsSection = document.getElementById('resultsSection');
            resultsSection.style.display = 'block';
            document.getElementById('submitSection').style.display = 'none';
            
            // Sort questions by order field to ensure correct display order
            const sortedQuestions = [...(passageData.questions || [])].sort((a, b) => {
                const orderA = a.order !== undefined ? a.order : 999;
                const orderB = b.order !== undefined ? b.order : 999;
                return orderA - orderB;
            });
            
            let correctCount = 0;
            sortedQuestions.forEach(q => {
                if (userAnswers[q.id] === q.correct_answer_index) {
                    correctCount++;
                }
            });
            
            const totalQuestions = sortedQuestions.length;
            const percentage = Math.round((correctCount / totalQuestions) * 100);
            
            let resultsHTML = '';
            
            sortedQuestions.forEach((question, index) => {
                const userAnswer = userAnswers[question.id];
                const isCorrect = userAnswer === question.correct_answer_index;
                
                // Use question.order if available, otherwise use index + 1
                const questionNumber = question.order !== undefined ? question.order : (index + 1);
                
                resultsHTML += `
                    <div class="question-card">
                        <h4>Question ${questionNumber} ${isCorrect ? '' : ''}</h4>
                        <p style="margin-bottom: 15px; font-size: 16px; color: #000;">${question.text}</p>
                        <div class="options-container">
                            ${question.options.map((option, optIndex) => {
                                let optionClass = 'option';
                                if (optIndex === question.correct_answer_index) {
                                    optionClass += ' correct';
                                } else if (optIndex === userAnswer && !isCorrect) {
                                    optionClass += ' incorrect';
                                }
                                
                                // Handle both object format (from passage detail) and string format (from questions endpoint)
                                let optionText = typeof option === 'string' ? option : option.text;
                                // Process diagrams for math sections
                                if (isMathSection && typeof optionText === 'string' && optionText.includes('[[Diagram')) {
                                    const mathAssets = currentMathSectionData?.assets || [];
                                    const mathSectionId = currentMathSectionData?.section_id || currentMathSectionData?.id || '';
                                    optionText = replaceDiagramSentinels(optionText, mathAssets, mathSectionId);
                                } else if (typeof optionText === 'string') {
                                    optionText = escapeHtml(optionText);
                                }
                                
                                return `
                                    <div class="${optionClass}">
                                        <input type="radio" disabled ${optIndex === userAnswer ? 'checked' : ''}>
                                        <label class="option-label">
                                            ${String.fromCharCode(65 + optIndex)}. ${optionText}
                                            ${optIndex === question.correct_answer_index ? ' (Correct)' : ''}
                                            ${optIndex === userAnswer && !isCorrect ? ' (Your Answer)' : ''}
                                        </label>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        ${question.explanation ? `
                            <div class="explanation">
                                <strong>Explanation:</strong> ${formatExplanation(question.explanation, lessonData.assets || [], lessonData.lesson_id)}
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            // Add penguin message after questions
            if (totalQuestions > 0) {
                const penguinMessage = getPenguinMessage(correctCount, totalQuestions, !passageData?.is_diagnostic);
                resultsHTML += `
                    <div style="background: #f0f8ff; border: 2px solid var(--accent-color); border-radius: 12px; padding: 24px; margin-top: 32px; text-align: center;">
                        <img src="/static/web/images/penguin.png" alt="Penguin" style="width: 80px; height: auto; margin-bottom: 16px;" />
                        <div style="font-size: 24px; font-weight: 700; color: var(--text-primary); margin-bottom: 12px;">${correctCount} / ${totalQuestions} (${percentage}%)</div>
                        <p style="font-size: 18px; font-weight: 600; color: var(--text-primary); margin: 0;">${penguinMessage}</p>
                    </div>
                `;
            }
            
            resultsSection.innerHTML = resultsHTML;
            resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        function backToPassagesList() {
            // Show category content for current category
            document.querySelectorAll('.category-content').forEach(content => {
                if (content.id === `category-${currentCategory}`) {
                    content.style.display = 'block';
                } else {
                    content.style.display = 'none';
                }
            });
            
            // Explicitly show list sections for current category
            if (currentCategory === 'reading') {
                const readingLessonsListSection = document.getElementById('readingLessonsListSection');
                const passagesListSection = document.getElementById('passagesListSection');
                if (readingLessonsListSection) readingLessonsListSection.style.display = 'block';
                if (passagesListSection) passagesListSection.style.display = 'block';
            } else if (currentCategory === 'writing') {
                const writingLessonsListSection = document.getElementById('writingLessonsListSection');
                // COMMENTED OUT: Writing sections removed, only showing lessons
                // const writingSectionsListSection = document.getElementById('writingSectionsListSection');
                if (writingLessonsListSection) writingLessonsListSection.style.display = 'block';
                // if (writingSectionsListSection) writingSectionsListSection.style.display = 'block';
            } else if (currentCategory === 'math') {
                const mathLessonsListSection = document.getElementById('mathLessonsListSection');
                const mathSectionsListSection = document.getElementById('mathSectionsListSection');
                if (mathLessonsListSection) mathLessonsListSection.style.display = 'block';
                if (mathSectionsListSection) mathSectionsListSection.style.display = 'block';
            }
            
            // Hide detail section
            const passageDetailSection = document.getElementById('passageDetailSection');
            if (passageDetailSection) passageDetailSection.style.display = 'none';
            currentPassageId = null;
            currentPassageData = null;
            currentLessonId = null;
            currentLessonData = null;
            currentWritingSectionId = null;
            currentWritingSectionData = null;
            currentMathSectionId = null;
            currentMathSectionData = null;
            userAnswers = {};
            lastAttemptData = null;
            currentQuestionsMap = {}; // Clear questions map
            
            // Show word of the day, hide explanation container
            const wordOfDay = document.getElementById('wordOfDay');
            const questionExplanation = document.getElementById('questionExplanation');
            if (wordOfDay) wordOfDay.style.display = 'block';
            if (questionExplanation) {
                questionExplanation.style.display = 'none';
                questionExplanation.classList.add('hidden');
                const content = document.getElementById('questionExplanationContent');
                if (content) content.innerHTML = '';
            }
            
            // Update URL hash
            window.history.replaceState(null, '', window.location.pathname + '#passages');
        }
        
        function showRegisterModalAndSaveAttempt() {
            // Store that we should save the attempt after registration
            showRegisterModal();
        }
        
        async function saveAnonymousAttempt(attemptData) {
            // This will be called after user registers to save their anonymous attempt
            // For now, we'll just show a message - the attempt was already submitted
            // In the future, we could create a new attempt record with the user's ID
            console.log('Saving anonymous attempt after registration:', attemptData);
            // Note: The attempt was already created on the server, we just need to associate it with the user
            // This would require a backend endpoint to update the attempt's user field
            // For now, we'll just show a success message
            if (currentPassageId) {
                // Reload passages to show attempt count
                loadPassages();
            }
        }
        
        async function showAttemptHistory(passageId) {
            if (!authToken) {
                alert('Please log in to view your attempt history.');
                return;
            }
            
            try {
                const url = `${API_BASE}/progress/passages/${passageId}/attempts`;
                console.log('Fetching attempt history from:', url);
                
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    let errorMessage = 'Please try again.';
                    try {
                        const errorData = await response.json();
                        console.error('Error response:', errorData);
                        errorMessage = errorData.error?.message || errorMessage;
                    } catch (e) {
                        console.error('Failed to parse error response:', e);
                        errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    alert(`Failed to load attempt history. ${errorMessage}`);
                    return;
                }
                
                const attempts = await response.json();
                
                if (attempts.length === 0) {
                    alert('No attempts found for this passage. Try refreshing the page.');
                    return;
                }
                
                // Show attempts in a modal
                let attemptsHTML = '<div style="max-height: 70vh; overflow-y: auto;">';
                attemptsHTML += `<h3 style="margin-bottom: 20px; color: #3498DB;">Attempt History</h3>`;
                
                attempts.forEach((attempt, index) => {
                    const date = new Date(attempt.completed_at);
                    const dateStr = date.toLocaleString();
                    const percentage = Math.round((attempt.correct_count / attempt.total_questions) * 100);
                    
                    attemptsHTML += `
                        <div style="border: 1px solid #d0d0d0; border-radius: 8px; padding: 15px; margin-bottom: 15px; background: white;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <strong style="color: #000;">Attempt #${attempts.length - index}</strong>
                                <span style="color: #666; font-size: 12px;">${dateStr}</span>
                            </div>
                            <div style="color: #000; margin-bottom: 8px;">
                                Score: <strong style="color: #3498DB;">${attempt.correct_count} / ${attempt.total_questions} (${percentage}%)</strong>
                            </div>
                            ${attempt.time_spent_seconds ? `<div style="color: #666; font-size: 12px;">Time: ${Math.floor(attempt.time_spent_seconds / 60)}m ${attempt.time_spent_seconds % 60}s</div>` : ''}
                            <button class="btn btn-secondary" onclick="viewAttemptDetails('${attempt.id}', '${passageId}', false)" style="margin-top: 10px; font-size: 12px; padding: 6px 12px;">
                                View Details
                            </button>
                        </div>
                    `;
                });
                
                attemptsHTML += '</div>';
                
                // Create and show modal
                const modal = document.createElement('div');
                modal.className = 'modal active';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px;">
                        <h2>Attempt History</h2>
                        ${attemptsHTML}
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()" style="margin-top: 20px; width: 100%;">Close</button>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Close on outside click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
            } catch (error) {
                console.error('Failed to load attempt history:', error);
                alert('Network error. Please try again.');
            }
        }
        
        async function showWritingSectionAttemptHistory(writingSectionId) {
            if (!authToken) {
                alert('Please log in to view your attempt history.');
                return;
            }
            
            try {
                const url = `${API_BASE}/progress/writing-sections/${writingSectionId}/attempts`;
                console.log('Fetching writing section attempt history from:', url);
                
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    let errorMessage = 'Please try again.';
                    try {
                        const errorData = await response.json();
                        console.error('Error response:', errorData);
                        errorMessage = errorData.error?.message || errorMessage;
                    } catch (e) {
                        console.error('Failed to parse error response:', e);
                        errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    alert(`Failed to load attempt history. ${errorMessage}`);
                    return;
                }
                
                const attempts = await response.json();
                
                if (attempts.length === 0) {
                    alert('No attempts found for this writing section. Try refreshing the page.');
                    return;
                }
                
                // Show attempts in a modal
                let attemptsHTML = '<div style="max-height: 70vh; overflow-y: auto;">';
                attemptsHTML += `<h3 style="margin-bottom: 20px; color: #3498DB;">Attempt History</h3>`;
                
                attempts.forEach((attempt, index) => {
                    const date = new Date(attempt.completed_at);
                    const dateStr = date.toLocaleString();
                    const percentage = Math.round((attempt.correct_count / attempt.total_questions) * 100);
                    
                    attemptsHTML += `
                        <div style="border: 1px solid #d0d0d0; border-radius: 8px; padding: 15px; margin-bottom: 15px; background: white;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <strong style="color: #000;">Attempt #${attempts.length - index}</strong>
                                <span style="color: #666; font-size: 12px;">${dateStr}</span>
                            </div>
                            <div style="color: #000; margin-bottom: 8px;">
                                Score: <strong style="color: #3498DB;">${attempt.correct_count} / ${attempt.total_questions} (${percentage}%)</strong>
                            </div>
                            ${attempt.time_spent_seconds ? `<div style="color: #666; font-size: 12px;">Time: ${Math.floor(attempt.time_spent_seconds / 60)}m ${attempt.time_spent_seconds % 60}s</div>` : ''}
                            <button class="btn btn-secondary" onclick="viewAttemptDetails('${attempt.id}', '${writingSectionId}', true)" style="margin-top: 10px; font-size: 12px; padding: 6px 12px;">
                                View Details
                            </button>
                        </div>
                    `;
                });
                
                attemptsHTML += '</div>';
                
                // Create and show modal
                const modal = document.createElement('div');
                modal.className = 'modal active';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px;">
                        <h2>Attempt History</h2>
                        ${attemptsHTML}
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()" style="margin-top: 20px; width: 100%;">Close</button>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Close on outside click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
            } catch (error) {
                console.error('Failed to load attempt history:', error);
                alert('Network error. Please try again.');
            }
        }
        
        async function viewAttemptDetails(attemptId, sectionId, isWritingSection = false, isMathSection = false) {
            // Load section and attempt data to show full details
            try {
                let endpoint, attemptsEndpoint;
                if (isMathSection) {
                    endpoint = `${API_BASE}/math-sections/${sectionId}`;
                    attemptsEndpoint = `${API_BASE}/progress/math-sections/${sectionId}/attempts`;
                } else if (isWritingSection) {
                    endpoint = `${API_BASE}/writing-sections/${sectionId}`;
                    attemptsEndpoint = `${API_BASE}/progress/writing-sections/${sectionId}/attempts`;
                } else {
                    endpoint = `${API_BASE}/passages/${sectionId}`;
                    attemptsEndpoint = `${API_BASE}/progress/passages/${sectionId}/attempts`;
                }
                
                const [sectionResponse, attemptsResponse] = await Promise.all([
                    fetch(endpoint, {
                        headers: authToken ? {'Authorization': `Bearer ${authToken}`} : {}
                    }),
                    fetch(attemptsEndpoint, {
                        headers: {'Authorization': `Bearer ${authToken}`}
                    })
                ]);
                
                if (!sectionResponse.ok || !attemptsResponse.ok) {
                    alert('Failed to load attempt details.');
                    return;
                }
                
                const sectionData = await sectionResponse.json();
                const attempts = await attemptsResponse.json();
                const attempt = attempts.find(a => a.id === attemptId);
                
                if (!attempt) {
                    alert('Attempt not found.');
                    return;
                }
                
                // Show attempt details in a modal
                const date = new Date(attempt.completed_at);
                const dateStr = date.toLocaleString();
                const percentage = Math.round((attempt.correct_count / attempt.total_questions) * 100);
                
                let detailsHTML = `
                    <div style="max-height: 80vh; overflow-y: auto;">
                        <h3 style="margin-bottom: 15px; color: #3498DB;">Attempt Details</h3>
                        <div style="background: #f9f9f9; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <div style="margin-bottom: 8px;"><strong>Date:</strong> ${dateStr}</div>
                            <div style="margin-bottom: 8px;"><strong>Score:</strong> ${attempt.correct_count} / ${attempt.total_questions} (${percentage}%)</div>
                            ${attempt.time_spent_seconds ? `<div><strong>Time:</strong> ${Math.floor(attempt.time_spent_seconds / 60)}m ${attempt.time_spent_seconds % 60}s</div>` : ''}
                        </div>
                        <h4 style="margin-bottom: 15px; color: #000;">Your Answers:</h4>
                `;
                
                // Match attempt answers with section questions
                // For math sections, questions might be in results array
                const questions = sectionData.questions || sectionData.results || [];
                
                // Sort questions by order field to ensure correct display order
                const sortedAttemptQuestions = [...questions].sort((a, b) => {
                    const orderA = a.order !== undefined ? a.order : 999;
                    const orderB = b.order !== undefined ? b.order : 999;
                    return orderA - orderB;
                });
                
                sortedAttemptQuestions.forEach((question, index) => {
                    const attemptAnswer = attempt.answers.find(a => a.question_id === question.id);
                    if (!attemptAnswer) return;
                    
                    const isCorrect = attemptAnswer.is_correct;
                    const questionNumber = question.order !== undefined ? question.order : (index + 1);
                    
                    // Get options - handle both array of strings and array of objects
                    let options = question.options || question.choices || [];
                    
                    // Process options for diagrams in math sections
                    const mathAssets = currentMathSectionData?.assets || sectionData.assets || [];
                    const mathSectionId = currentMathSectionData?.section_id || currentMathSectionData?.id || sectionData.section_id || sectionData.id || '';
                    
                    if (options.length > 0 && mathAssets.length > 0) {
                        options = options.map(option => {
                            const optionText = typeof option === 'string' ? option : (option.text || option);
                            if (typeof optionText === 'string' && optionText.includes('[[Diagram')) {
                                // Process diagram sentinels in option text
                                const processed = replaceDiagramSentinels(optionText, mathAssets, mathSectionId);
                                // Return object format if original was object, otherwise return processed string
                                if (typeof option === 'object' && option !== null) {
                                    return { ...option, text: processed };
                                }
                                return processed;
                            }
                            return option;
                        });
                    }
                    
                    // Get question text - math sections use 'prompt' (can be array or string), others use 'text'
                    let questionText = '';
                    
                    if (Array.isArray(question.prompt)) {
                        // New format: array of blocks
                        questionText = formatMathPrompt(question.prompt, mathAssets, mathSectionId);
                    } else if (typeof question.prompt === 'string' && question.prompt) {
                        // Old format: plain text (backwards compatibility)
                        questionText = replaceDiagramSentinels(question.prompt, mathAssets, mathSectionId);
                        questionText = replaceUnderlineSentinels(questionText);
                        questionText = `<p style="margin-bottom: 10px; font-size: 14px; color: #000;">${questionText}</p>`;
                    } else {
                        questionText = `<p style="margin-bottom: 10px; font-size: 14px; color: #000;">${escapeHtml(question.text || '')}</p>`;
                    }
                    
                    detailsHTML += `
                        <div class="question-card" style="margin-bottom: 15px;">
                            <h4>Question ${questionNumber} ${isCorrect ? '' : ''}</h4>
                            <div style="margin-bottom: 10px; font-size: 14px; color: #000;">${questionText}</div>
                            <div class="options-container">
                                ${options.map((option, optIndex) => {
                                    let optionClass = 'option';
                                    if (optIndex === question.correct_answer_index) {
                                        optionClass += ' correct';
                                    } else if (optIndex === attemptAnswer.selected_option_index && !isCorrect) {
                                        optionClass += ' incorrect';
                                    }
                                    
                                    let optionText = typeof option === 'string' ? option : option.text;
                                    // If optionText contains HTML (from diagram processing), don't escape it
                                    if (typeof optionText === 'string' && (optionText.includes('<img') || optionText.includes('[[Diagram'))) {
                                        // Already processed with diagrams, use as-is (or process if still has sentinel)
                                        if (optionText.includes('[[Diagram')) {
                                            optionText = replaceDiagramSentinels(optionText, mathAssets, mathSectionId);
                                        }
                                    } else {
                                        optionText = escapeHtml(optionText);
                                    }
                                    
                                    return `
                                        <div class="${optionClass}" style="pointer-events: none;">
                                            <input type="radio" disabled ${optIndex === attemptAnswer.selected_option_index ? 'checked' : ''}>
                                            <label class="option-label">
                                                ${String.fromCharCode(65 + optIndex)}. ${optionText}
                                                ${optIndex === question.correct_answer_index ? ' (Correct)' : ''}
                                                ${optIndex === attemptAnswer.selected_option_index && !isCorrect ? ' (Your Answer)' : ''}
                                            </label>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                            ${attemptAnswer.explanation ? `
                                <div class="explanation" style="margin-top: 10px;">
                                    <strong>Explanation:</strong> ${formatMathExplanation(attemptAnswer.explanation, isMathSection)}
                                </div>
                            ` : ''}
                        </div>
                    `;
                });
                
                detailsHTML += '</div>';
                
                // Create and show modal
                const modal = document.createElement('div');
                modal.className = 'modal active';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 700px;">
                        ${detailsHTML}
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()" style="margin-top: 20px; width: 100%;">Close</button>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Close on outside click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
            } catch (error) {
                console.error('Failed to load attempt details:', error);
                alert('Network error. Please try again.');
            }
        }
        
        async function showMathSectionAttemptHistory(mathSectionId) {
            if (!authToken) {
                alert('Please log in to view your attempt history.');
                return;
            }
            
            try {
                const url = `${API_BASE}/progress/math-sections/${mathSectionId}/attempts`;
                console.log('Fetching math section attempt history from:', url);
                
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    let errorMessage = 'Please try again.';
                    try {
                        const errorData = await response.json();
                        console.error('Error response:', errorData);
                        errorMessage = errorData.error?.message || errorMessage;
                    } catch (e) {
                        console.error('Failed to parse error response:', e);
                        errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    alert(`Failed to load attempt history. ${errorMessage}`);
                    return;
                }
                
                const attempts = await response.json();
                
                if (attempts.length === 0) {
                    alert('No attempts found for this math section. Try refreshing the page.');
                    return;
                }
                
                // Show attempts in a modal
                let attemptsHTML = '<div style="max-height: 70vh; overflow-y: auto;">';
                attemptsHTML += `<h3 style="margin-bottom: 20px; color: #3498DB;">Attempt History</h3>`;
                
                attempts.forEach((attempt, index) => {
                    const date = new Date(attempt.completed_at);
                    const dateStr = date.toLocaleString();
                    const percentage = Math.round((attempt.correct_count / attempt.total_questions) * 100);
                    
                    attemptsHTML += `
                        <div style="border: 1px solid #d0d0d0; border-radius: 8px; padding: 15px; margin-bottom: 15px; background: white;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <strong style="color: #000;">Attempt #${attempts.length - index}</strong>
                                <span style="color: #666; font-size: 12px;">${dateStr}</span>
                            </div>
                            <div style="color: #000; margin-bottom: 8px;">
                                Score: <strong style="color: #3498DB;">${attempt.correct_count} / ${attempt.total_questions} (${percentage}%)</strong>
                            </div>
                            ${attempt.time_spent_seconds ? `<div style="color: #666; font-size: 12px;">Time: ${Math.floor(attempt.time_spent_seconds / 60)}m ${attempt.time_spent_seconds % 60}s</div>` : ''}
                            <button class="btn btn-secondary" onclick="viewAttemptDetails('${attempt.id}', '${mathSectionId}', true, true)" style="margin-top: 10px; font-size: 12px; padding: 6px 12px;">
                                View Details
                            </button>
                        </div>
                    `;
                });
                
                attemptsHTML += '</div>';
                
                // Create and show modal
                const modal = document.createElement('div');
                modal.className = 'modal active';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px;">
                        <h2>Attempt History</h2>
                        ${attemptsHTML}
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()" style="margin-top: 20px; width: 100%;">Close</button>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Close on outside click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
            } catch (error) {
                console.error('Failed to load attempt history:', error);
                alert('Network error. Please try again.');
            }
        }
        
        function showUpgradeModal(contentType = 'content') {
            // Create and show upgrade modal
            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <h2> Premium Content</h2>
                    <p style="margin-bottom: 20px; color: #666;">
                        This is part of our premium content. Upgrade to Keuvi Premium for $5/month to get:                    </p>
                    <div style="background: #083242; color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <ul style="text-align: left; margin: 0; padding-left: 20px;">
                            <li>Twice the practice questions</li>
                            <li>New material (that's exclusive to Premium) added every week</li>
                        </ul>
                    </div>
                    ${authToken ? 
                        `<button class="btn btn-primary" onclick="upgradeToPremium(); this.closest('.modal').remove();" style="width: 100%; font-size: 16px; padding: 12px;">
                            Upgrade to Premium - $5/month
                        </button>` :
                        `<button class="btn btn-primary" onclick="showRegisterModal(); this.closest('.modal').remove();" style="width: 100%; font-size: 16px; padding: 12px; margin-bottom: 10px;">
                            Sign Up to Upgrade
                        </button>
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove();" style="width: 100%; font-size: 14px; padding: 10px;">
                            Maybe Later
                        </button>`
                    }
                </div>
            `;
            document.body.appendChild(modal);
            
            // Close on outside click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        async function upgradeToPremium() {
            if (!authToken) {
                showRegisterModal();
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/payments/checkout`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (response.ok && data.url) {
                    // Store that we're going to checkout so we can refresh on return
                    localStorage.setItem('pendingSubscription', 'true');
                    window.location.href = data.url;
                } else {
                    // Show more detailed error message
                    const errorMessage = data.error?.message || 'Failed to create checkout session. Please try again.';
                    console.error('Checkout error:', data);
                    alert(errorMessage);
                }
            } catch (error) {
                console.error('Failed to create checkout:', error);
                alert('Network error. Please try again.');
            }
        }

        function togglePromoCodeInput(event) {
            event.preventDefault();
            const inputSection = document.getElementById('promoCodeInputSection');
            const isVisible = inputSection.style.display !== 'none';
            inputSection.style.display = isVisible ? 'none' : 'block';
            if (!isVisible) {
                document.getElementById('promoCodeInput').focus();
            }
        }

        async function redeemPromoCode() {
            if (!authToken) {
                showRegisterModal();
                return;
            }

            const codeInput = document.getElementById('promoCodeInput');
            const messageEl = document.getElementById('promoCodeMessage');
            const redeemBtn = document.getElementById('redeemPromoBtn');
            const code = codeInput.value.trim();

            if (!code) {
                messageEl.style.display = 'block';
                messageEl.style.color = 'var(--error-color, #dc3545)';
                messageEl.textContent = 'Please enter a promo code.';
                return;
            }

            // Disable button while processing
            redeemBtn.disabled = true;
            redeemBtn.textContent = 'Redeeming...';
            messageEl.style.display = 'none';

            try {
                const response = await fetch(`${API_BASE}/payments/redeem-code`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ code: code })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    // Show success message
                    messageEl.style.display = 'block';
                    messageEl.style.color = 'var(--success-color, #28a745)';
                    messageEl.textContent = data.message || 'Promo code redeemed successfully!';

                    // Clear input
                    codeInput.value = '';

                    // Refresh user data to update premium status
                    await refreshUserData();

                    // Hide promo code section after success (user is now premium)
                    setTimeout(() => {
                        const promoSection = document.getElementById('promoCodeSection');
                        if (promoSection) {
                            promoSection.style.display = 'none';
                        }
                    }, 2000);
                } else {
                    // Show error message
                    const errorMessage = data.error?.message || data.message || 'Failed to redeem code. Please try again.';
                    messageEl.style.display = 'block';
                    messageEl.style.color = 'var(--error-color, #dc3545)';
                    messageEl.textContent = errorMessage;
                }
            } catch (error) {
                console.error('Failed to redeem promo code:', error);
                messageEl.style.display = 'block';
                messageEl.style.color = 'var(--error-color, #dc3545)';
                messageEl.textContent = 'Network error. Please try again.';
            } finally {
                // Re-enable button
                redeemBtn.disabled = false;
                redeemBtn.textContent = 'Redeem';
            }
        }

        async function refreshUserData() {
            /**Refresh user data from server to get latest premium status*/
            if (!authToken) {
                console.log('No auth token, cannot refresh user data');
                return Promise.resolve(false);
            }
            
            try {
                // First, try to sync subscription from Stripe (in case webhook didn't fire)
                try {
                    const syncResponse = await fetch(`${API_BASE}/payments/sync`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${authToken}`,
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (syncResponse.ok) {
                        const syncData = await syncResponse.json();
                        console.log('Subscription synced from Stripe:', syncData);
                    }
                } catch (syncError) {
                    console.log('Sync failed (may not have subscription yet):', syncError);
                }
                
                // Then refresh user data
                const response = await fetch(`${API_BASE}/auth/me`, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });
                
                if (response.ok) {
                    currentUser = await response.json();
                    console.log('User data refreshed:', currentUser);
                    updateUI();
                    return true;
                }
            } catch (error) {
                console.error('Failed to refresh user data:', error);
            }
            return false;
        }
        
        function updateUI() {
            console.log('updateUI called, currentUser:', currentUser, 'authToken:', authToken ? 'SET' : 'NOT SET');
            if (currentUser) {
                console.log('User is logged in, updating UI to show user info');
                const authSection = document.getElementById('authSection');
                const userInfo = document.getElementById('userInfo');
                if (authSection) authSection.classList.add('hidden');
                if (userInfo) {
                    userInfo.classList.remove('hidden');
                    const emailEl = document.getElementById('userEmail');
                    if (emailEl) emailEl.textContent = currentUser.email;
                    
                    // Check both is_premium flag and has_active_subscription
                    const isPremium = currentUser.is_premium || currentUser.has_active_subscription;
                    
                    if (isPremium) {
                        const statusEl = document.getElementById('subscriptionStatus');
                        if (statusEl) statusEl.textContent = 'Premium Active';
                        const btn = document.getElementById('subscriptionButton');
                        if (btn) {
                            btn.textContent = 'Manage Subscription';
                            btn.onclick = manageSubscription;
                            btn.classList.remove('btn-success');
                            btn.classList.add('btn-secondary');
                        }
                        // Hide promo code section for premium users
                        const promoSection = document.getElementById('promoCodeSection');
                        if (promoSection) promoSection.style.display = 'none';
                    } else {
                        const statusEl = document.getElementById('subscriptionStatus');
                        if (statusEl) statusEl.textContent = 'Free';
                        const btn = document.getElementById('subscriptionButton');
                        if (btn) {
                            btn.textContent = 'Upgrade to Premium ($5/month)';
                            btn.onclick = upgradeToPremium;
                            btn.classList.remove('btn-secondary');
                            btn.classList.add('btn-success');
                        }
                        // Show promo code section for free users
                        const promoSection = document.getElementById('promoCodeSection');
                        if (promoSection) promoSection.style.display = 'block';
                    }
                }
                // Update landing nav for logged-in user
                const landingLoginBtn = document.getElementById('landingLoginBtn');
                const landingCtaBtn = document.getElementById('landingCtaBtn');
                if (landingLoginBtn) {
                    landingLoginBtn.textContent = currentUser.email.split('@')[0];
                    landingLoginBtn.onclick = function() { showPassages(); };
                }
                if (landingCtaBtn) {
                    landingCtaBtn.textContent = 'Continue';
                }
            } else {
                console.log('No user, showing login/register buttons');
                const authSection = document.getElementById('authSection');
                const userInfo = document.getElementById('userInfo');
                if (authSection) authSection.classList.remove('hidden');
                if (userInfo) userInfo.classList.add('hidden');

                // Reset landing nav for logged-out user
                const landingLoginBtn = document.getElementById('landingLoginBtn');
                const landingCtaBtn = document.getElementById('landingCtaBtn');
                if (landingLoginBtn) {
                    landingLoginBtn.textContent = 'Log In';
                    landingLoginBtn.onclick = showLoginModal;
                }
                if (landingCtaBtn) {
                    landingCtaBtn.textContent = 'Get Started';
                }
            }
        }
        
        async function manageSubscription() {
            if (!authToken) return;
            
            try {
                const response = await fetch(`${API_BASE}/payments/portal`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (response.ok && data.url) {
                    window.location.href = data.url;
                }
            } catch (error) {
                console.error('Failed to open portal:', error);
            }
        }
        
        function logout() {
            localStorage.removeItem('authToken');
            authToken = null;
            currentUser = null;
            currentOnboardingData = null;
            hidePenguinCoach();
            updateUI();
            loadPassages();
        }
        
        // Study Plan Helper Functions
        function hasStudyPlanData(studyPlan) {
            if (!studyPlan) return false;
            return (studyPlan.reading && studyPlan.reading.diagnostic_completed) || 
                   (studyPlan.writing && studyPlan.writing.diagnostic_completed) || 
                   (studyPlan.math && studyPlan.math.diagnostic_completed);
        }
        
        function hasDiagnosticsAvailable(studyPlan) {
            if (!studyPlan) return false;
            return (studyPlan.reading && studyPlan.reading.diagnostic_passage_id) || 
                   (studyPlan.writing && studyPlan.writing.diagnostic_lesson_id) || 
                   (studyPlan.math && studyPlan.math.diagnostic_lesson_id);
        }
        
        function getAllStrengths(data) {
            const strengths = [...(data.strengths || [])];
            if (data.study_plan) {
                ['reading', 'writing', 'math'].forEach(cat => {
                    const catData = data.study_plan[cat];
                    if (catData && catData.strengths) {
                        catData.strengths.forEach(s => {
                            s.category = cat;
                            strengths.push(s);
                        });
                    }
                });
            }
            return strengths.slice(0, 10);
        }
        
        function getAllWeaknesses(data) {
            const weaknesses = [...(data.weaknesses || [])];
            if (data.study_plan) {
                ['reading', 'writing', 'math'].forEach(cat => {
                    const catData = data.study_plan[cat];
                    if (catData && catData.weaknesses) {
                        catData.weaknesses.forEach(w => {
                            w.category = cat;
                            weaknesses.push(w);
                        });
                    }
                });
            }
            return weaknesses.slice(0, 10);
        }
        
        function populateStudyPlan(studyPlan) {
            // Helper to render diagnostic status
            // diagnosticType can be 'lesson' or 'passage'
            function renderDiagnosticStatus(catData, elementId, diagnosticId, diagnosticType) {
                const el = document.getElementById(elementId);
                if (catData && catData.diagnostic_completed) {
                    const strengths = catData.strengths || [];
                    const weaknesses = catData.weaknesses || [];
                    el.innerHTML = `
                        <div style="color: var(--text-primary); font-size: 13px; margin-bottom: 4px;">Complete</div>
                        <div style="font-size: 12px; color: var(--text-secondary);">
                            ${strengths.length} strong  ${weaknesses.length} needs work
                        </div>
                    `;
                } else if (diagnosticId) {
                    el.innerHTML = `
                        <div style="color: var(--text-secondary); font-size: 13px; margin-bottom: 8px;">Not started</div>
                        <button class="btn btn-secondary" onclick="startDiagnostic('${diagnosticId}', '${diagnosticType}')" style="font-size: 12px; padding: 6px 12px;">
                            Start
                        </button>
                    `;
                } else {
                    el.innerHTML = `<div style="color: var(--text-secondary); font-size: 13px;">Not available</div>`;
                }
            }
            
            renderDiagnosticStatus(studyPlan.reading, 'readingDiagnosticStatus', studyPlan.reading?.diagnostic_passage_id, 'passage');
            renderDiagnosticStatus(studyPlan.writing, 'writingDiagnosticStatus', studyPlan.writing?.diagnostic_lesson_id, 'lesson');
            renderDiagnosticStatus(studyPlan.math, 'mathDiagnosticStatus', studyPlan.math?.diagnostic_lesson_id, 'lesson');
            
            // Recommended Lessons
            const recommendedContainer = document.getElementById('recommendedLessons');
            const recommendedList = document.getElementById('recommendedLessonsList');
            if (studyPlan.recommended_lessons && studyPlan.recommended_lessons.length > 0) {
                recommendedContainer.style.display = 'block';
                recommendedList.innerHTML = studyPlan.recommended_lessons.map(lesson => {
                    const typeColors = {
                        'reading': '#3498db',
                        'writing': '#9b59b6',
                        'math': '#e67e22'
                    };
                    const color = typeColors[lesson.lesson_type] || '#3498db';
                    return `
                        <button onclick="goToLesson('${lesson.id}')" style="background: ${color}; color: white; border: none; padding: 10px 16px; border-radius: 6px; cursor: pointer; font-size: 13px;">
                            ${escapeHtml(lesson.title)}
                        </button>
                    `;
                }).join('');
            } else {
                recommendedContainer.style.display = 'none';
            }
        }
        
        function startDiagnostic(diagnosticId, diagnosticType) {
            // Navigate to the diagnostic (passage for reading, lesson for writing/math)
            if (diagnosticType === 'passage') {
                window.location.hash = `#passage/${diagnosticId}`;
            } else {
                window.location.hash = `#lesson/${diagnosticId}`;
            }
        }
        
        function goToLesson(lessonId) {
            window.location.hash = `#lesson/${lessonId}`;
        }
        
        function populateDefaultStudyPlan() {
            // Show default "not started" state for all diagnostics
            const readingStatus = document.getElementById('readingDiagnosticStatus');
            const writingStatus = document.getElementById('writingDiagnosticStatus');
            const mathStatus = document.getElementById('mathDiagnosticStatus');
            
            readingStatus.innerHTML = `
                <div style="color: var(--text-secondary);">No diagnostic set up yet</div>
            `;
            writingStatus.innerHTML = `
                <div style="color: var(--text-secondary);">No diagnostic set up yet</div>
            `;
            mathStatus.innerHTML = `
                <div style="color: var(--text-secondary);">No diagnostic set up yet</div>
            `;
            
            document.getElementById('recommendedLessons').style.display = 'none';
        }
        
        async function showProfile() {
            if (!authToken) {
                showLoginModal();
                return;
            }
            
            // Hide other views, show profile
            document.getElementById('landingPage').style.display = 'none';
            document.getElementById('passagesView').style.display = 'none';
            document.getElementById('profileView').style.display = 'block';
            
            // Show loading state
            document.getElementById('profileLoading').style.display = 'block';
            document.getElementById('profileData').style.display = 'none';
            document.getElementById('profileEmpty').style.display = 'none';
            
            try {
                const response = await fetch(`${API_BASE}/profile`, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to load profile');
                }
                
                const data = await response.json();
                
                // Hide loading
                document.getElementById('profileLoading').style.display = 'none';
                
                // Populate user info
                document.getElementById('profileEmail').textContent = data.user.email;
                document.getElementById('profileStatus').textContent = data.user.is_premium ? 'Premium' : 'Free';
                
                // Always show profile data section - study plan should always be visible
                document.getElementById('profileData').style.display = 'block';
                document.getElementById('profileEmpty').style.display = 'none';
                
                // Populate Study Plan (always show, even if diagnostics not complete)
                if (data.study_plan) {
                    populateStudyPlan(data.study_plan);
                } else {
                    // No study plan from API - show default diagnostic prompts
                    populateDefaultStudyPlan();
                }
                
                if (data.performance.length > 0 || hasStudyPlanData(data.study_plan)) {
                    // Populate strengths (combine from performance and study plan)
                    const strengthsList = document.getElementById('strengthsList');
                    const allStrengths = getAllStrengths(data);
                    if (allStrengths.length > 0) {
                        strengthsList.innerHTML = allStrengths.map(s => {
                            const correct = s.correct !== undefined ? s.correct : s.correct_answers;
                            const total = s.total !== undefined ? s.total : s.total_questions;
                            const pct = s.percentage !== undefined ? s.percentage : s.accuracy;
                            return `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid var(--border-color);">
                                <div>
                                    <span style="color: var(--text-primary); font-size: 14px;">${escapeHtml(s.name || s.classification_name || 'Unknown')}</span>
                                    <span style="color: var(--text-secondary); font-size: 12px; margin-left: 8px;">${s.category || ''}</span>
                                </div>
                                <div style="color: var(--text-secondary); font-size: 13px;">
                                    ${correct}/${total}  ${pct}%
                                </div>
                            </div>
                        `}).join('');
                    } else {
                        strengthsList.innerHTML = '<p style="color: var(--text-secondary); font-size: 14px;">Complete a diagnostic to see your strengths.</p>';
                    }
                    
                    // Populate weaknesses (combine from performance and study plan)
                    const weaknessesList = document.getElementById('weaknessesList');
                    const allWeaknesses = getAllWeaknesses(data);
                    if (allWeaknesses.length > 0) {
                        weaknessesList.innerHTML = allWeaknesses.map(w => {
                            const correct = w.correct !== undefined ? w.correct : w.correct_answers;
                            const total = w.total !== undefined ? w.total : w.total_questions;
                            const pct = w.percentage !== undefined ? w.percentage : w.accuracy;
                            return `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid var(--border-color);">
                                <div>
                                    <span style="color: var(--text-primary); font-size: 14px;">${escapeHtml(w.name || w.classification_name || 'Unknown')}</span>
                                    <span style="color: var(--text-secondary); font-size: 12px; margin-left: 8px;">${w.category || ''}</span>
                                </div>
                                <div style="color: var(--text-secondary); font-size: 13px;">
                                    ${correct}/${total}  ${pct}%
                                </div>
                            </div>
                        `}).join('');
                    } else {
                        weaknessesList.innerHTML = '<p style="color: var(--text-secondary); font-size: 14px;">Complete a diagnostic to see areas for improvement.</p>';
                    }
                    
                    // Populate all performance
                    const performanceList = document.getElementById('performanceList');
                    if (data.performance.length > 0) {
                        performanceList.innerHTML = data.performance.map(p => {
                            return `
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid var(--border-color);">
                                    <div>
                                        <span style="color: var(--text-primary); font-size: 14px;">${escapeHtml(p.classification_name)}</span>
                                        <span style="color: var(--text-secondary); font-size: 12px; margin-left: 8px;">${p.category}</span>
                                    </div>
                                    <div style="color: var(--text-secondary); font-size: 13px;">
                                        ${p.correct_answers}/${p.total_questions}  ${p.accuracy}%
                                    </div>
                                </div>
                            `;
                        }).join('');
                    } else {
                        performanceList.innerHTML = '<p style="color: var(--text-secondary); font-size: 14px;">No performance data yet.</p>';
                    }
                }
                
            } catch (error) {
                console.error('Failed to load profile:', error);
                document.getElementById('profileLoading').style.display = 'none';
                document.getElementById('profileEmpty').style.display = 'block';
            }
        }
        
        function showLoginModal() {
            document.getElementById('loginModal').classList.add('active');
            document.getElementById('loginError').textContent = '';
        }
        
        function showRegisterModal() {
            document.getElementById('registerModal').classList.add('active');
            document.getElementById('registerError').textContent = '';
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }
        
        async function loadWordOfDay() {
            try {
                const response = await fetch(`${API_BASE}/word-of-the-day`);
                if (response.ok) {
                    const data = await response.json();
                    displayWordOfDay(data);
                } else {
                    document.getElementById('wordOfDay').innerHTML = `
                        <h3>Word of the Day</h3>
                        <div class="loading">Unable to load word of the day</div>
                    `;
                }
            } catch (error) {
                console.error('Failed to load word of day:', error);
                document.getElementById('wordOfDay').innerHTML = `
                    <h3>Word of the Day</h3>
                    <div class="loading">Unable to load word of the day</div>
                `;
            }
        }
        
        function displayWordOfDay(data) {
            const synonyms = data.synonyms || [];
            const synonymTags = synonyms.map(syn => 
                `<span class="synonym-tag">${syn}</span>`
            ).join('');
            
            document.getElementById('wordOfDay').innerHTML = `
                <h3>Word of the Day</h3>
                <div class="word">${data.word}</div>
                <div class="definition">${data.definition}</div>
                ${synonyms.length > 0 ? `
                    <div class="synonyms">
                        <div class="synonyms-label">Synonyms:</div>
                        <div class="synonym-tags">${synonymTags}</div>
                    </div>
                ` : ''}
                <div class="example">
                    <div class="example-label">Example:</div>
                    <div class="example-sentence">"${data.example_sentence}"</div>
                </div>
            `;
        }
        
        // Close modal on outside click
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            });
        });
        
        // Deterministic font scaling based on container width
        function adjustReaderFont() {
            const readers = document.querySelectorAll('.passage-content-sat, .passage-content');
            readers.forEach(reader => {
                if (!reader) return;
                
                const containerWidth = reader.clientWidth;
                
                // Target readable line length
                const TARGET_CHARS = 66;
                
                // Avg serif glyph width  0.52em
                const CHAR_WIDTH_EM = 0.52;
                
                let fontSize = containerWidth / (TARGET_CHARS * CHAR_WIDTH_EM);
                
                // Adaptive minimum based on container width
                // Very narrow devices (like TCL 30Z ~300px container) can go to 10px
                // Normal devices (400px+) should have higher minimum
                // Desktop devices need smaller max to prevent overflow
                const isDesktop = window.innerWidth >= 769;
                let minFontSize;
                let maxFontSize;
                
                if (containerWidth < 350) {
                    // Very narrow devices - allow smaller font (TCL 30Z fix)
                    minFontSize = 10;
                    maxFontSize = 20;
                } else if (containerWidth < 450) {
                    // Narrow devices - slightly higher minimum
                    minFontSize = 14;
                    maxFontSize = 20;
                } else if (isDesktop) {
                    // Desktop devices - prevent overflow with lower max
                    minFontSize = 15;
                    maxFontSize = 16;
                } else {
                    // Normal mobile devices (most iPhones) - larger minimum for readability
                    minFontSize = 19;
                    maxFontSize = 20;
                }
                
                fontSize = Math.max(minFontSize, Math.min(fontSize, maxFontSize));
                
                reader.style.fontSize = `${fontSize}px`;
                
                // Also apply to line-text and passage-line within this container
                const lineTexts = reader.querySelectorAll('.line-text, .passage-line');
                lineTexts.forEach(el => {
                    el.style.fontSize = `${fontSize}px`;
                });
            });
        }
        
        // Run on resize, orientation change, and DOM ready
        window.addEventListener('resize', adjustReaderFont);
        window.addEventListener('orientationchange', () => {
            setTimeout(adjustReaderFont, 100);
        });
        
        // Run after DOM is ready and after passage content is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', adjustReaderFont);
        } else {
            adjustReaderFont();
        }
        
        // Also run after a short delay to catch dynamically loaded content
        setTimeout(adjustReaderFont, 500);
    </script>
    
    <!-- Footer -->
    <footer style="background: var(--bg-secondary); border-top: 1px solid var(--border-color); padding: 20px 0; margin-top: auto; text-align: center; color: var(--text-secondary); font-size: 14px;">
        <div style="max-width: 1200px; margin: 0 auto; padding: 0 20px;">
            <p style="margin: 0 0 8px 0;"> 2026 Argos Ventures LLC. All rights reserved.</p>
            <p style="margin: 0;">
                <a href="/terms/" style="color: var(--accent-color); text-decoration: none;">Terms of Service</a>
                <span style="margin: 0 8px;"></span>
                <a href="/privacy/" style="color: var(--accent-color); text-decoration: none;">Privacy Policy</a>
                <span style="margin: 0 8px;"></span>
                <a href="/support/" style="color: var(--accent-color); text-decoration: none;">Support</a>
                <span style="margin: 0 8px;"></span>
                <a href="mailto:admin@argosventures.pro" style="color: var(--accent-color); text-decoration: none;">admin@argosventures.pro</a>
            </p>
        </div>
    </footer>

    <!-- Penguin Coach Speech Bubble -->
    <div id="penguinCoachContainer" class="penguin-coach-container" aria-live="polite" role="complementary" aria-label="Penguin coach guidance">
        <div class="penguin-coach-bubble">
            <div class="penguin-coach-header">
                <div class="penguin-coach-avatar">
                    <img src="{% static 'web/images/penguin.png' %}" alt="Keuvi Penguin Coach">
                </div>
                <div class="penguin-coach-message">
                    <div id="penguinCoachMessagePrimary" class="penguin-coach-message-primary"></div>
                    <div id="penguinCoachMessageSecondary" class="penguin-coach-message-secondary"></div>
                </div>
            </div>
            <div class="penguin-coach-actions">
                <button id="penguinCoachActionBtn" class="penguin-coach-action-btn" aria-label="Take action"></button>
                <button id="penguinCoachDismissBtn" class="penguin-coach-dismiss-btn" aria-label="Dismiss" title="Dismiss">&times;</button>
            </div>
        </div>
    </div>
</body>
</html>



