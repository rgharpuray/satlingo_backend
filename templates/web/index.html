{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keuvi</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* CSS Variables for theming */
        :root {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e0e0e0;
            --text-primary: #000000;
            --text-secondary: #666666;
            --border-color: #e0e0e0;
            --accent-color: #3498DB;
            --accent-hover: #2980B9;
            --shadow: rgba(0,0,0,0.08);
        }
        
        body.dark-mode {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3d3d3d;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --border-color: #404040;
            --accent-color: #5dade2;
            --accent-hover: #3498DB;
            --shadow: rgba(0,0,0,0.3);
        }
        
        /* Override inline black text colors in dark mode */
        body.dark-mode [style*="color: #000"],
        body.dark-mode [style*="color:#000"],
        body.dark-mode [style*="color: #333"],
        body.dark-mode [style*="color:#333"],
        body.dark-mode [style*="color: #222"],
        body.dark-mode [style*="color:#222"],
        body.dark-mode [style*="color: black"],
        body.dark-mode [style*="color:black"] {
            color: var(--text-primary) !important;
        }
        
        /* Override inline dark gray text in dark mode */
        body.dark-mode [style*="color: #666"],
        body.dark-mode [style*="color:#666"],
        body.dark-mode [style*="color: #555"],
        body.dark-mode [style*="color:#555"] {
            color: var(--text-secondary) !important;
        }
        
        /* Override white/light backgrounds in dark mode */
        body.dark-mode [style*="background: white"],
        body.dark-mode [style*="background:white"],
        body.dark-mode [style*="background: #fff"],
        body.dark-mode [style*="background:#fff"],
        body.dark-mode [style*="background: #ffffff"],
        body.dark-mode [style*="background:#ffffff"],
        body.dark-mode [style*="background: #f9f9f9"],
        body.dark-mode [style*="background:#f9f9f9"],
        body.dark-mode [style*="background: #f0f8ff"],
        body.dark-mode [style*="background:#f0f8ff"],
        body.dark-mode [style*="background: #f0fff0"],
        body.dark-mode [style*="background:#f0fff0"],
        body.dark-mode [style*="background: #fff0f0"],
        body.dark-mode [style*="background:#fff0f0"],
        body.dark-mode [style*="background: #fff9e6"],
        body.dark-mode [style*="background:#fff9e6"],
        body.dark-mode [style*="background: #fffacd"],
        body.dark-mode [style*="background:#fffacd"],
        body.dark-mode [style*="background: #fff3cd"],
        body.dark-mode [style*="background:#fff3cd"],
        body.dark-mode [style*="background: #e3f2fd"],
        body.dark-mode [style*="background:#e3f2fd"],
        body.dark-mode [style*="background: #f0f0f0"],
        body.dark-mode [style*="background:#f0f0f0"],
        body.dark-mode [style*="background: #f5f5f5"],
        body.dark-mode [style*="background:#f5f5f5"] {
            background: var(--bg-secondary) !important;
        }
        
        /* Override light blue backgrounds with darker version */
        body.dark-mode [style*="background: #f0f8ff"],
        body.dark-mode [style*="background:#f0f8ff"],
        body.dark-mode [style*="background: #e3f2fd"],
        body.dark-mode [style*="background:#e3f2fd"] {
            background: rgba(52, 152, 219, 0.15) !important;
        }
        
        /* Override light green backgrounds */
        body.dark-mode [style*="background: #f0fff0"],
        body.dark-mode [style*="background:#f0fff0"],
        body.dark-mode [style*="background: #d4edda"],
        body.dark-mode [style*="background:#d4edda"] {
            background: rgba(40, 167, 69, 0.15) !important;
        }
        
        /* Override light red backgrounds */
        body.dark-mode [style*="background: #fff0f0"],
        body.dark-mode [style*="background:#fff0f0"],
        body.dark-mode [style*="background: #f8d7da"],
        body.dark-mode [style*="background:#f8d7da"] {
            background: rgba(220, 53, 69, 0.15) !important;
        }
        
        /* Override light yellow backgrounds */
        body.dark-mode [style*="background: #fff9e6"],
        body.dark-mode [style*="background:#fff9e6"],
        body.dark-mode [style*="background: #fffacd"],
        body.dark-mode [style*="background:#fffacd"],
        body.dark-mode [style*="background: #fff3cd"],
        body.dark-mode [style*="background:#fff3cd"] {
            background: rgba(255, 193, 7, 0.15) !important;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            padding: 20px;
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 24px 30px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px var(--shadow);
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .logo {
            text-decoration: none;
            color: var(--accent-color);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            transition: transform 0.2s ease, color 0.3s ease;
        }
        
        /* Dark Mode Toggle Button */
        .dark-mode-toggle {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            width: 50px;
            height: 28px;
            cursor: pointer;
            padding: 2px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
        }
        
        .dark-mode-toggle:hover {
            border-color: var(--accent-color);
        }
        
        .dark-mode-toggle-slider {
            width: 24px;
            height: 24px;
            background: var(--bg-secondary);
            border-radius: 50%;
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px var(--shadow);
        }
        
        body.dark-mode .dark-mode-toggle-slider {
            transform: translateX(22px);
        }
        
        .dark-mode-toggle-icon {
            font-size: 14px;
            transition: opacity 0.3s ease;
        }
        
        .dark-mode-toggle-icon.sun {
            opacity: 1;
        }
        
        .dark-mode-toggle-icon.moon {
            opacity: 0;
            position: absolute;
        }
        
        body.dark-mode .dark-mode-toggle-icon.sun {
            opacity: 0;
        }
        
        body.dark-mode .dark-mode-toggle-icon.moon {
            opacity: 1;
        }
        
        .logo:hover {
            transform: scale(1.02);
        }
        
        .logo img {
            height: 60px;
            width: auto;
            display: block;
        }
        
        .logo span {
            font-size: 32px;
            font-weight: 700;
            margin-left: 0;
            letter-spacing: -0.5px;
        }
        
        .auth-section {
            display: flex;
            gap: 10px;
            align-items: center;
            position: absolute;
            right: 30px;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: var(--accent-color);
            color: #fff;
            font-weight: 500;
        }
        
        .btn-primary:hover {
            background: var(--accent-hover);
        }
        
        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-weight: 500;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .btn-secondary:hover {
            background: var(--border-color);
        }
        
        .btn-success {
            background: var(--accent-color);
            color: #fff;
            font-weight: 500;
        }
        
        .btn-success:hover {
            background: var(--accent-hover);
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }
        
        .passages-section {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 8px var(--shadow);
            border: 1px solid var(--border-color);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .passages-section h2 {
            color: var(--accent-color);
            font-size: 28px;
            font-weight: 600;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--accent-color);
        }
        
        .category-picker {
            display: flex;
            gap: 0;
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 4px;
            box-shadow: 0 2px 8px var(--shadow);
            border: 1px solid var(--border-color);
            margin-bottom: 30px;
            overflow: hidden;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .category-picker button {
            flex: 1;
            padding: 12px 24px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 6px;
        }
        
        .category-picker button.active {
            background: var(--accent-color);
            color: white;
        }
        
        .category-picker button:hover:not(.active) {
            background: var(--bg-primary);
        }
        
        .category-content {
            display: none;
        }
        
        .category-content.active {
            display: block;
        }
        
        .sidebar {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 8px var(--shadow);
            border: 1px solid var(--border-color);
            height: fit-content;
            position: sticky;
            top: 20px;
            align-self: flex-start;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .passage-card {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--bg-secondary);
        }
        
        .passage-card:hover {
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
            transform: translateY(-2px);
            border-color: var(--accent-color);
        }
        
        .passage-card h3 {
            color: var(--text-primary);
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .passage-card p {
            color: var(--text-secondary);
            font-size: 14px;
            margin: 0;
        }
        
        .passage-card.premium {
            border-left: 4px solid #3498DB;
        }
        
        .premium-badge {
            display: inline-block;
            background: #FFD700;
            color: #000;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .premium-lock {
            display: inline-block;
            margin-left: 8px;
            color: #FFD700;
            font-size: 18px;
            font-weight: bold;
            vertical-align: middle;
        }
        
        .premium-preview-overlay {
            position: relative;
            max-height: 400px;
            overflow: hidden;
        }
        
        .premium-preview-overlay::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.8) 50%, rgba(255, 255, 255, 1) 100%);
            pointer-events: none;
        }
        
        .premium-upgrade-prompt {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            margin: 30px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .premium-upgrade-prompt h3 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 24px;
        }
        
        .premium-upgrade-prompt p {
            margin-bottom: 20px;
            font-size: 16px;
            opacity: 0.95;
        }
        
        .premium-upgrade-prompt .btn {
            background: white;
            color: #667eea;
            font-weight: bold;
            padding: 12px 30px;
            font-size: 16px;
        }
        
        .premium-upgrade-prompt .btn:hover {
            background: #f0f0f0;
        }
        
        .passage-detail-section {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 8px var(--shadow);
            border: 1px solid var(--border-color);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .passage-content {
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 30px;
            line-height: 1.8;
            font-size: 16px;
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            white-space: pre-wrap;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        
        .passage-content-sat {
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 30px;
            border: 1px solid var(--border-color);
            font-family: "Minion Pro", "Minion", "Times New Roman", "Times", serif;
            font-size: 16px;
            line-height: 1.6;
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        
        .passage-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            column-gap: 40px;
        }
        
        .passage-column {
            width: 100%;
        }
        
        .passage-line {
            font-family: "Minion Pro", "Minion", "Times New Roman", "Times", serif;
            font-size: 15px;
            line-height: 1.5;
            white-space: pre;
            margin: 0;
            padding: 0;
        }
        
        .passage-line-numbered {
            display: flex;
            align-items: flex-start;
            margin: 0;
            padding: 0;
        }
        
        .line-number {
            color: var(--text-secondary);
            font-size: 11px;
            font-weight: bold;
            margin-right: 8px;
            min-width: 25px;
            text-align: right;
            padding-top: 2px;
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
        }
        
        .line-text {
            flex: 1;
            font-family: "Minion Pro", "Minion", "Times New Roman", "Times", serif;
            font-size: 15px;
            line-height: 1.5;
            white-space: pre;
            color: var(--text-primary);
        }
        
        .questions-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 1024px) {
            .passage-columns,
            .questions-columns {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
        
        @media (max-width: 768px) {
            .passage-columns,
            .questions-columns {
                gap: 15px;
            }
        }
        
        .question-card {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            background: var(--bg-secondary);
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .question-card h4 {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
        }
        
        .question-card p {
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
            color: var(--text-primary);
        }
        
        .option {
            display: flex;
            align-items: flex-start;
            padding: 12px;
            margin-bottom: 10px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
        }
        
        .option:hover {
            border-color: var(--accent-color);
            background: var(--bg-primary);
        }
        
        .option.selected {
            border-color: var(--accent-color);
            background: var(--bg-primary);
        }
        
        .option.correct {
            border-color: #27ae60;
            background: #d4edda;
        }
        
        .option.incorrect {
            border-color: #e74c3c;
            background: #f8d7da;
        }
        
        .option input[type="radio"] {
            margin-right: 12px;
            margin-top: 2px;
            cursor: pointer;
        }
        
        .option-label {
            flex: 1;
            color: #000;
            font-size: 15px;
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
        }
        
        .explanation {
            margin-top: 15px;
            padding: 15px;
            background: #f0f8ff;
            border-left: 4px solid #3498DB;
            border-radius: 4px;
            color: #000;
            font-size: 14px;
            line-height: 1.6;
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        body.dark-mode .explanation {
            background: rgba(52, 152, 219, 0.15);
            color: var(--text-primary);
        }
        
        .results-summary {
            background: #f9f9f9;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #e0e0e0;
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
        }
        
        .results-summary h3 {
            color: #000;
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 15px;
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
        }
        
        .score {
            font-size: 32px;
            font-weight: 700;
            color: #3498DB;
            margin: 10px 0;
            font-family: "Myriad Pro", "Myriad", "Arial", sans-serif;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        body.dark-mode .modal {
            background: rgba(0,0,0,0.7);
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .modal-content h2 {
            color: var(--accent-color);
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--accent-color);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 14px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        
        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        
        .error {
            color: #dc3545;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .user-info {
            padding: 16px;
            background: var(--bg-primary);
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .user-info strong {
            color: #000;
            font-weight: 600;
        }
        
        .subscription-info {
            padding: 16px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }
        
        .subscription-info strong {
            color: #000;
            font-weight: 600;
        }
        
        .word-of-day {
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
            box-shadow: 0 2px 8px var(--shadow);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .word-of-day h3 {
            color: var(--accent-color);
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--accent-color);
        }
        
        .word-of-day .word {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-color);
            margin-bottom: 12px;
        }
        
        .word-of-day .definition {
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 12px;
        }
        
        .word-of-day .synonyms {
            margin-bottom: 12px;
        }
        
        .word-of-day .synonyms-label {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 13px;
            margin-bottom: 6px;
        }
        
        .word-of-day .synonym-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .word-of-day .synonym-tag {
            background: rgba(52, 152, 219, 0.1);
            color: var(--accent-color);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }
        
        .word-of-day .example {
            margin-top: 12px;
            padding: 12px;
            background: var(--bg-primary);
            border-radius: 6px;
            border-left: 3px solid var(--accent-color);
            transition: background-color 0.3s ease;
        }
        
        .word-of-day .example-label {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 13px;
            margin-bottom: 6px;
        }
        
        .word-of-day .example-sentence {
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.6;
            font-style: italic;
        }
        
        .word-of-day .loading {
            text-align: center;
            color: var(--text-secondary);
            padding: 20px;
        }
        
        .hidden {
            display: none;
        }
        
        /* Landing Page Styles */
        .landing-page {
            display: block;
            animation: fadeIn 0.6s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .landing-page ~ header,
        .landing-page header {
            display: none;
        }
        
        body:has(.landing-page:not([style*="display: none"])) header {
            display: none;
        }
        
        /* Brand Colors */
        :root {
            --navy: #1B2A4A;
            --gold: #F4C441;
            --blue: #3498DB;
        }
        
        .landing-hero {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 100px 40px;
            text-align: center;
            max-width: 800px;
            margin: 0 auto 60px;
            box-shadow: 0 4px 20px var(--shadow);
            border: 1px solid var(--border-color);
            animation: fadeIn 0.8s ease-in;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .hero-logo {
            margin-bottom: 24px;
        }
        
        .hero-logo img {
            height: 100px;
            width: auto;
            display: block;
            margin: 0 auto;
        }
        
        .hero-title {
            font-size: 56px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 20px;
            line-height: 1.2;
        }
        
        .hero-tagline {
            font-size: 22px;
            color: var(--text-primary);
            margin-bottom: 32px;
            font-weight: 700;
        }
        
        .hero-features {
            margin-bottom: 40px;
        }
        
        .hero-features p {
            font-size: 18px;
            color: var(--text-primary);
            margin-bottom: 12px;
            line-height: 1.6;
            font-weight: 400;
        }
        
        .hero-features p:last-child {
            margin-bottom: 0;
        }
        
        .btn-large {
            padding: 18px 40px;
            font-size: 18px;
            font-weight: 600;
            border-radius: 12px;
            background: var(--navy);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(27, 42, 74, 0.2);
        }
        
        .btn-large:hover {
            transform: scale(1.03) translateY(-2px);
            box-shadow: 0 6px 20px rgba(27, 42, 74, 0.3);
            background: #152238;
        }
        
        /* Product Preview Section */
        .preview-section {
            margin-bottom: 80px;
        }
        
        .preview-section h3 {
            text-align: center;
            font-size: 36px;
            font-weight: 700;
            color: var(--navy);
            margin-bottom: 50px;
        }
        
        .preview-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-bottom: 60px;
        }
        
        .preview-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 4px 16px var(--shadow);
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .preview-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 8px 24px var(--shadow);
        }
        
        .preview-card-icon {
            font-size: 56px;
            margin-bottom: 20px;
        }
        
        .preview-card h4 {
            color: var(--text-primary);
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 12px;
        }
        
        .preview-card p {
            color: var(--text-secondary);
            font-size: 15px;
            line-height: 1.6;
        }
        
        /* Why Keuvi Section */
        .why-keuvi {
            background: linear-gradient(135deg, rgba(27, 42, 74, 0.03) 0%, rgba(52, 152, 219, 0.03) 100%);
            border-radius: 16px;
            padding: 50px 40px;
            margin-bottom: 80px;
        }
        
        .why-keuvi h3 {
            text-align: center;
            font-size: 32px;
            font-weight: 700;
            color: var(--navy);
            margin-bottom: 40px;
        }
        
        .differentiators {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 16px;
        }
        
        .differentiator-pill {
            background: white;
            color: var(--navy);
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 15px;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 2px solid #e8e8e8;
            transition: all 0.2s ease;
        }
        
        .differentiator-pill:hover {
            border-color: var(--gold);
            background: rgba(244, 196, 65, 0.1);
            transform: translateY(-2px);
        }
        
        .differentiator-pill .pill-icon {
            margin-right: 8px;
            color: var(--gold);
        }
        
        /* Feature Cards - Enhanced */
        .landing-features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-bottom: 80px;
        }
        
        .feature-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: 0 4px 16px var(--shadow);
            border: 1px solid var(--border-color);
            text-align: center;
            transition: all 0.3s ease;
        }
        
        body.dark-mode .feature-card {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.05) 0%, var(--bg-secondary) 100%);
        }
        
        .feature-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 8px 24px var(--shadow);
        }
        
        .feature-card h3 {
            color: var(--text-primary);
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 16px;
        }
        
        .feature-card p {
            color: var(--text-secondary);
            font-size: 16px;
            line-height: 1.7;
        }
        
        .feature-icon {
            font-size: 64px;
            margin-bottom: 24px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
        }
        
        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            /* Body and container adjustments */
            body {
                padding: 16px;
            }
            
            .container {
                max-width: 100%;
            }
            
            /* Header adjustments */
            header {
                padding: 20px 16px;
                flex-wrap: wrap;
                justify-content: space-between;
                margin-bottom: 16px;
            }
            
            .logo {
                gap: 8px;
            }
            
            .logo img {
                height: 40px;
            }
            
            .logo span {
                font-size: 24px;
            }
            
            header .auth-section {
                position: static;
                right: auto;
                margin-top: 12px;
                width: 100%;
                justify-content: center;
                order: 2;
            }
            
            header {
                flex-direction: column;
            }
            
            header .logo {
                order: 1;
            }
            
            /* Dark mode toggle on mobile */
            .dark-mode-toggle {
                position: static;
                transform: none;
                margin-bottom: 12px;
                order: 0;
            }
            
            /* Main content - stack vertically on mobile */
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .sidebar {
                position: static;
                max-height: none;
                order: 2;
                padding: 20px;
            }
            
            .content-column {
                order: 1;
            }
            
            /* Category picker - make buttons more touch-friendly */
            .category-picker {
                padding: 4px;
                margin-bottom: 24px;
            }
            
            .category-picker button {
                padding: 14px 12px;
                font-size: 14px;
            }
            
            /* View toggle buttons */
            .view-toggle {
                flex-wrap: wrap;
                gap: 10px;
                margin-bottom: 20px;
            }
            
            .view-toggle button {
                flex: 1;
                min-width: 120px;
                padding: 12px 16px;
                font-size: 14px;
            }
            
            /* Passage sections */
            .passages-section {
                padding: 24px 20px;
                margin-bottom: 24px;
            }
            
            .passages-section h2 {
                font-size: 22px;
                margin-bottom: 20px;
            }
            
            /* Passage cards */
            .passage-card {
                padding: 20px;
                margin-bottom: 16px;
            }
            
            .passage-card h3 {
                font-size: 18px;
            }
            
            .passage-card p {
                font-size: 14px;
            }
            
            /* Question cards */
            .question-card {
                padding: 20px;
                margin-bottom: 20px;
            }
            
            .question-card h4 {
                font-size: 16px;
                margin-bottom: 16px;
            }
            
            .option {
                padding: 16px;
                margin-bottom: 12px;
                font-size: 14px;
            }
            
            /* Passage detail section */
            .passage-detail-section {
                padding: 20px 16px;
            }
            
            /* Back button container - ensure it has proper spacing */
            .passage-detail-section > div:first-child {
                flex-wrap: wrap;
                gap: 12px;
                margin-bottom: 24px;
                padding-left: 0;
                padding-right: 0;
                margin-left: 0;
                margin-right: 0;
            }
            
            .passage-detail-section button {
                padding: 12px 16px;
                font-size: 14px;
            }
            
            /* Passage content container - ensure proper padding */
            #passageContent {
                padding-left: 0;
                padding-right: 0;
            }
            
            /* Passage content header/title - ensure it respects container padding */
            .passage-detail-section h2,
            .passage-detail-section h1,
            #passageContent h2,
            #passageContent h1 {
                padding-left: 0;
                padding-right: 0;
                margin-left: 0;
                margin-right: 0;
            }
            
            /* Questions container */
            #questionsContainer {
                padding-left: 0;
                padding-right: 0;
            }
            
            /* Submit section */
            #submitSection {
                padding-left: 0;
                padding-right: 0;
            }
            
            /* Passage content */
            .passage-content {
                padding: 20px;
            }
            
            .passage-content-sat {
                padding: 20px !important;
            }
            
            .passage-content h2 {
                font-size: 20px;
            }
            
            /* Lesson content container - add horizontal padding */
            .lesson-content {
                padding-left: 12px;
                padding-right: 12px;
            }
            
            /* Add more padding to example boxes and highlighted text containers on mobile */
            /* Override padding for boxes with background colors */
            .lesson-content div[style*="background: #f0f8ff"],
            .lesson-content div[style*="background:#f0f8ff"],
            .lesson-content div[style*="background: rgba(52, 152, 219, 0.15)"],
            .lesson-content div[style*="background: #f0fff0"],
            .lesson-content div[style*="background:#f0fff0"],
            .lesson-content div[style*="background: #fff0f0"],
            .lesson-content div[style*="background:#fff0f0"],
            .lesson-content div[style*="background: #fff9e6"],
            .lesson-content div[style*="background:#fff9e6"],
            .lesson-content div[style*="background: #e3f2fd"],
            .lesson-content div[style*="background:#e3f2fd"] {
                padding-left: 20px !important;
                padding-right: 20px !important;
            }
            
            /* Explanation boxes - ensure good padding */
            .explanation {
                padding-left: 20px !important;
                padding-right: 20px !important;
            }
            
            /* Boxes with left border (example boxes) - increase padding */
            .lesson-content div[style*="border-left: 4px solid"],
            .lesson-content div[style*="border-left: 3px solid"] {
                padding-left: 20px !important;
                padding-right: 20px !important;
            }
            
            /* All divs with padding in lesson content - ensure minimum horizontal padding */
            .lesson-content div[style*="padding: 10px"],
            .lesson-content div[style*="padding: 12px"],
            .lesson-content div[style*="padding: 15px"] {
                padding-left: 20px !important;
                padding-right: 20px !important;
            }
            
            /* Paragraphs and text blocks in lesson content */
            .lesson-content p {
                padding-left: 4px;
                padding-right: 4px;
            }
            
            /* Line numbers and text */
            .line-number {
                font-size: 10px;
                min-width: 20px;
                margin-right: 6px;
            }
            
            .line-text {
                font-size: 14px;
            }
            
            /* Buttons - make more touch-friendly */
            .btn {
                padding: 12px 20px;
                font-size: 15px;
                min-height: 44px; /* iOS touch target minimum */
            }
            
            .btn-primary,
            .btn-secondary,
            .btn-success {
                min-height: 44px;
            }
            
            /* Submit section */
            #submitSection {
                margin-top: 20px;
            }
            
            #submitSection button {
                width: 100%;
                padding: 14px;
                font-size: 16px;
            }
            
            /* Word of day */
            .word-of-day {
                padding: 20px;
            }
            
            .word-of-day h3 {
                font-size: 18px;
                margin-bottom: 16px;
            }
            
            /* Question explanation */
            #questionExplanation {
                padding: 20px !important;
                margin-bottom: 24px !important;
            }
            
            #questionExplanation h3 {
                margin-bottom: 16px !important;
            }
            
            /* Landing page adjustments */
            .landing-hero {
                padding: 60px 20px;
            }
            
            .hero-title {
                font-size: 36px;
            }
            
            .hero-tagline {
                font-size: 18px;
            }
            
            .hero-features p {
                font-size: 15px;
            }
            
            .btn-large {
                padding: 16px 32px;
                font-size: 16px;
                width: 100%;
                max-width: 300px;
            }
            
            .preview-cards {
                grid-template-columns: 1fr;
            }
            
            .differentiators {
                overflow-x: auto;
                flex-wrap: nowrap;
                justify-content: flex-start;
                padding-bottom: 10px;
                -webkit-overflow-scrolling: touch;
            }
            
            .differentiator-pill {
                flex-shrink: 0;
            }
            
            .landing-features {
                grid-template-columns: 1fr;
            }
            
            .preview-section h3,
            .why-keuvi h3 {
                font-size: 24px;
            }
            
            /* Side-by-side content - stack on mobile */
            .side-by-side-content,
            div[style*="flex-direction: row"] {
                flex-direction: column !important;
                gap: 15px !important;
            }
            
            .side-by-side-content > div,
            div[style*="flex-direction: row"] > div {
                width: 100% !important;
                flex: 1 1 100% !important;
                min-width: 0 !important;
                max-width: 100% !important;
            }
            
            /* Override inline min-width that might cause horizontal scroll */
            div[style*="min-width: 250px"] {
                min-width: 0 !important;
            }
            
            /* User info section */
            #userInfo {
                padding: 20px;
            }
            
            #userInfo h3 {
                font-size: 18px;
                margin-bottom: 16px;
            }
            
            /* Results section */
            #resultsSection {
                padding: 20px;
            }
            
            /* Ensure images don't overflow */
            img {
                max-width: 100%;
                height: auto;
            }
            
            /* Fix any inline styles that might cause issues */
            .passage-content img,
            .question-card img {
                max-width: 100%;
                height: auto;
            }
            
            /* Modal adjustments */
            .modal-content {
                padding: 20px 16px;
                width: 95%;
                max-height: 95vh;
            }
            
            .modal-content h2 {
                font-size: 20px;
                margin-bottom: 16px;
            }
            
            .form-group {
                margin-bottom: 12px;
            }
            
            .form-group input,
            .form-group textarea {
                font-size: 16px; /* Prevents zoom on iOS */
                padding: 12px;
            }
        }
        
        /* Extra small devices */
        @media (max-width: 480px) {
            body {
                padding: 12px;
            }
            
            header {
                padding: 16px 12px;
            }
            
            .passages-section {
                padding: 20px 16px;
            }
            
            .passage-card {
                padding: 16px;
            }
            
            .question-card {
                padding: 16px;
            }
            
            .logo span {
                font-size: 20px;
            }
            
            .logo img {
                height: 32px;
            }
            
            .category-picker button {
                padding: 12px 8px;
                font-size: 12px;
            }
            
            .passages-section {
                padding: 16px 12px;
            }
            
            .passages-section h2 {
                font-size: 20px;
            }
            
            .hero-title {
                font-size: 32px;
            }
            
            .hero-tagline {
                font-size: 16px;
            }
        }
        
        .passages-view {
            display: none;
        }
        
        .view-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .view-toggle button {
            padding: 8px 16px;
            font-size: 14px;
        }
        
        .view-toggle button.active {
            background: #3498DB;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <button class="dark-mode-toggle" onclick="toggleDarkMode()" aria-label="Toggle dark mode" title="Toggle dark mode">
                <div class="dark-mode-toggle-slider">
                    <span class="dark-mode-toggle-icon sun">‚òÄÔ∏è</span>
                    <span class="dark-mode-toggle-icon moon">üåô</span>
                </div>
            </button>
            <a href="#" class="logo" onclick="showLanding(); return false;">
                <img src="{% static 'web/images/keuvi.png' %}" alt="Keuvi Logo">
                
            </a>
            <div class="auth-section" id="authSection">
                <button class="btn btn-primary" onclick="showLoginModal()">Login</button>
                <button class="btn btn-secondary" onclick="showRegisterModal()">Register</button>
            </div>
        </header>
        
        <!-- Landing Page -->
        <div class="landing-page" id="landingPage">
            <div class="landing-hero">
                <div class="hero-logo">
                    <img src="{% static 'web/images/keuvi.png' %}" alt="Keuvi Logo">
                </div>
                <p class="hero-tagline">An SAT tutor in your pocket</p>
                <div class="hero-features">
                    <p>Lessons covering everything on the test</p>
                    <p>Hundreds of practice questions</p>
                    <p>All of it written by people</p>
                </div>
                <button class="btn-large" onclick="showPassages()">Get Started</button>
            </div>
            
            <!-- Premium Section -->
            <div class="why-keuvi" style="text-align: center; padding: 30px 20px;">
                <p style="font-size: 18px; color: var(--text-primary); line-height: 1.6; margin: 0;">
                    Sign up for premium to get double the practice questions and new additions every week for $5 a month.
                </p>
            </div>
        </div>
        
        <!-- Passages View -->
        <div class="passages-view" id="passagesView">
            <div class="view-toggle">
                <button class="btn btn-secondary active" onclick="showPassages()">Passages</button>
                <button class="btn btn-secondary" onclick="showLanding()">Home</button>
            </div>
            
            <div class="main-content">
                <div class="content-column">
                    <!-- Category Picker -->
                    <div class="category-picker">
                        <button class="active" onclick="switchCategory('reading')" id="category-reading-btn">üìö Reading</button>
                        <button onclick="switchCategory('writing')" id="category-writing-btn">‚úçÔ∏è Writing</button>
                        <button onclick="switchCategory('math')" id="category-math-btn">üî¢ Math</button>
                    </div>
                    
                    <!-- Reading Category Content -->
                    <div class="category-content active" id="category-reading">
                        <!-- Reading Lessons List View -->
                        <div class="passages-section" id="readingLessonsListSection" style="margin-bottom: 40px;">
                            <h2>Reading Lessons</h2>
                            <div id="readingLessonsList"></div>
                        </div>
                        
                        <!-- Reading Passages List View -->
                        <div class="passages-section" id="passagesListSection">
                            <h2>Reading Passages</h2>
                            <div id="passagesList"></div>
                        </div>
                    </div>
                    
                    <!-- Writing Category Content -->
                    <div class="category-content" id="category-writing">
                        <!-- Writing Lessons List View -->
                        <div class="passages-section" id="writingLessonsListSection" style="margin-bottom: 40px;">
                            <h2>Writing Lessons</h2>
                            <div id="writingLessonsList"></div>
                        </div>
                        
                        <!-- Writing Sections List View - COMMENTED OUT: Writing sections removed, only showing lessons -->
                        <!--
                        <div class="passages-section" id="writingSectionsListSection">
                            <h2>Writing Sections</h2>
                            <div id="writingSectionsList"></div>
                        </div>
                        -->
                    </div>
                    
                    <!-- Math Category Content -->
                    <div class="category-content" id="category-math">
                        <!-- Math Lessons List View -->
                        <div class="passages-section" id="mathLessonsListSection" style="margin-bottom: 40px;">
                            <h2>Math Lessons</h2>
                            <div id="mathLessonsList"></div>
                        </div>
                        
                        <!-- Math Sections List View - COMMENTED OUT: Math sections removed, only showing lessons -->
                        <!--
                        <div class="passages-section" id="mathSectionsListSection">
                            <h2>Math Sections</h2>
                            <div id="mathSectionsList"></div>
                        </div>
                        -->
                    </div>
                    
                    <!-- Passage/Lesson Detail View -->
                    <div class="passage-detail-section" id="passageDetailSection" style="display: none;">
                        <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center;">
                            <button class="btn btn-secondary" onclick="backToPassagesList()">‚Üê Back</button>
                            <span id="attemptHistoryButtonContainer"></span>
                        </div>
                        <div id="passageContent"></div>
                        <div id="questionsContainer"></div>
                        <div id="submitSection" style="margin-top: 30px;">
                            <button class="btn btn-primary" onclick="submitAnswers()" id="submitBtn">Submit Answers</button>
                        </div>
                        <div id="resultsSection" style="display: none; margin-top: 30px;"></div>
                    </div>
                </div>
                
                <div class="sidebar">
                    <div class="word-of-day" id="wordOfDay">
                        <h3>Word of the Day</h3>
                        <div class="loading">Loading...</div>
                    </div>
                    
                    <div id="questionExplanation" class="hidden" style="display: none; background: var(--bg-secondary); border-radius: 8px; padding: 12px 16px; margin-bottom: 20px; box-shadow: 0 2px 4px var(--shadow); border-left: 3px solid var(--accent-color);">
                        <h3 style="color: var(--accent-color); margin-bottom: 8px; font-size: 16px; margin-left: 0;">Explanation</h3>
                        <div id="questionExplanationContent" style="color: var(--text-primary); line-height: 1.6;">
                            <!-- Explanation will be inserted here -->
                        </div>
                    </div>
                    
                    <div id="userInfo" class="hidden">
                        <div class="user-info">
                            <strong>Logged in as:</strong><br>
                            <span id="userEmail"></span>
                        </div>
                        <div class="subscription-info" id="subscriptionInfo">
                            <strong>Subscription:</strong><br>
                            <span id="subscriptionStatus">Free</span><br>
                            <button class="btn btn-success" id="subscriptionButton" onclick="upgradeToPremium()" style="margin-top: 10px; width: 100%;">
                                Upgrade to Premium ($5/month)
                            </button>
                            <button class="btn btn-secondary" onclick="refreshUserData()" style="margin-top: 5px; width: 100%; font-size: 12px; padding: 6px;">
                                üîÑ Refresh Status
                            </button>
                        </div>
                        <button class="btn btn-secondary" onclick="logout()" style="margin-top: 10px; width: 100%;">
                            Logout
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Login Modal -->
    <div id="loginModal" class="modal">
        <div class="modal-content">
            <h2>Login</h2>
            <form id="loginForm" onsubmit="handleLogin(event)">
                <div class="form-group">
                    <label>Email</label>
                    <input type="email" name="email" required>
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" name="password" required>
                </div>
                <div id="loginError" class="error"></div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">Login</button>
                <div style="text-align: center; margin: 15px 0; color: #666;">or</div>
                <button type="button" class="btn" onclick="handleGoogleLogin()" style="width: 100%; background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color); display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <svg width="18" height="18" viewBox="0 0 18 18">
                        <path fill="#4285F4" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z"/>
                        <path fill="#34A853" d="M9 18c2.43 0 4.467-.806 5.956-2.184l-2.908-2.258c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z"/>
                        <path fill="#FBBC05" d="M3.964 10.712c-.18-.54-.282-1.117-.282-1.712s.102-1.172.282-1.712V4.956H.957C.347 6.175 0 7.55 0 9s.348 2.825.957 4.044l3.007-2.332z"/>
                        <path fill="#EA4335" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.956L3.964 7.288C4.672 5.163 6.656 3.58 9 3.58z"/>
                    </svg>
                    Sign in with Google
                </button>
                <button type="button" class="btn btn-secondary" onclick="closeModal('loginModal')" style="width: 100%; margin-top: 10px;">Cancel</button>
            </form>
        </div>
    </div>
    
    <!-- Register Modal -->
    <div id="registerModal" class="modal">
        <div class="modal-content">
            <h2>Register</h2>
            <form id="registerForm" onsubmit="handleRegister(event)">
                <div class="form-group">
                    <label>Email</label>
                    <input type="email" name="email" required>
                </div>
                <div class="form-group">
                    <label>Password</label>
                    <input type="password" name="password" required minlength="8">
                </div>
                <div id="registerError" class="error"></div>
                <button type="submit" class="btn btn-primary" style="width: 100%;">Register</button>
                <div style="text-align: center; margin: 15px 0; color: #666;">or</div>
                <button type="button" class="btn" onclick="handleGoogleLogin()" style="width: 100%; background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color); display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <svg width="18" height="18" viewBox="0 0 18 18">
                        <path fill="#4285F4" d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z"/>
                        <path fill="#34A853" d="M9 18c2.43 0 4.467-.806 5.956-2.184l-2.908-2.258c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332C2.438 15.983 5.482 18 9 18z"/>
                        <path fill="#FBBC05" d="M3.964 10.712c-.18-.54-.282-1.117-.282-1.712s.102-1.172.282-1.712V4.956H.957C.347 6.175 0 7.55 0 9s.348 2.825.957 4.044l3.007-2.332z"/>
                        <path fill="#EA4335" d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0 5.482 0 2.438 2.017.957 4.956L3.964 7.288C4.672 5.163 6.656 3.58 9 3.58z"/>
                    </svg>
                    Sign in with Google
                </button>
                <button type="button" class="btn btn-secondary" onclick="closeModal('registerModal')" style="width: 100%; margin-top: 10px;">Cancel</button>
            </form>
        </div>
    </div>
    
    <script>
        // Dark Mode Toggle Functionality
        function initDarkMode() {
            const darkMode = localStorage.getItem('darkMode') === 'true';
            if (darkMode) {
                document.body.classList.add('dark-mode');
            }
        }
        
        function toggleDarkMode() {
            const isDark = document.body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', isDark);
            // Force update of all dynamically generated content
            updateDarkModeTextColors();
        }
        
        // Helper function to get current text color based on mode
        function getTextColor() {
            return document.body.classList.contains('dark-mode') ? '#ffffff' : '#000000';
        }
        
        function getTextSecondaryColor() {
            return document.body.classList.contains('dark-mode') ? '#b0b0b0' : '#666666';
        }
        
        // Helper function to get background color for example boxes
        function getExampleBgColor(type) {
            const isDark = document.body.classList.contains('dark-mode');
            if (type === 'example') {
                return isDark ? 'rgba(52, 152, 219, 0.15)' : '#f0f8ff';
            } else if (type === 'correct') {
                return isDark ? 'rgba(40, 167, 69, 0.15)' : '#f0fff0';
            } else if (type === 'incorrect') {
                return isDark ? 'rgba(220, 53, 69, 0.15)' : '#fff0f0';
            } else if (type === 'rule') {
                return isDark ? 'rgba(255, 193, 7, 0.15)' : '#fff9e6';
            }
            return isDark ? 'var(--bg-secondary)' : '#f9f9f9';
        }
        
        // Update all inline styles with black text to use current mode
        function updateDarkModeTextColors() {
            const isDark = document.body.classList.contains('dark-mode');
            const textColor = isDark ? '#ffffff' : '#000000';
            const textSecondary = isDark ? '#b0b0b0' : '#666666';
            
            // Update all elements with inline color styles
            document.querySelectorAll('[style*="color: #000"], [style*="color:#000"], [style*="color: #333"], [style*="color:#333"]').forEach(el => {
                const style = el.getAttribute('style') || '';
                el.setAttribute('style', style.replace(/color:\s*#(000|333|222|666|555|000000|333333)/gi, `color: ${textColor}`));
            });
        }
        
        // Initialize dark mode on page load
        initDarkMode();
        
        const API_BASE = '/api/v1';
        let authToken = localStorage.getItem('authToken');
        let currentUser = null;
        
        // If we have a token on page load, check auth immediately
        if (authToken) {
            console.log('Found authToken in localStorage on page load');
        }
        
        // Check URL hash to determine initial view
        function handleHashRoute() {
            const hash = window.location.hash.substring(1); // Remove #
            console.log('Hash route handler called with hash:', hash);
            
            if (hash.startsWith('passage/')) {
                const passageId = hash.split('/')[1];
                // Only open if we're not already opening this passage and it's different from current (prevent loop)
                if (!isOpeningPassage && currentPassageId !== passageId) {
                    showPassages(true);
                    setTimeout(() => {
                        console.log('Opening passage from hash:', passageId);
                        openPassage(passageId);
                    }, 100);
                }
            } else if (hash.startsWith('lesson/')) {
                const lessonId = hash.split('/')[1];
                // Only open if it's different from current lesson (prevent loop)
                if (currentLessonId !== lessonId) {
                showPassages(true);
                setTimeout(() => {
                    console.log('Opening lesson from hash:', lessonId);
                    openLesson(lessonId);
                }, 100);
                }
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // } else if (hash.startsWith('writing-section/')) {
            //     const sectionId = hash.split('/')[1];
            //     showPassages(true);
            //     setTimeout(() => {
            //         console.log('Opening writing section from hash:', sectionId);
            //         openWritingSection(sectionId);
            //     }, 100);
            } else if (hash.startsWith('math-section/')) {
                const sectionId = hash.split('/')[1];
                // Only open if we're not already opening this section and it's different from current (prevent loop)
                if (!isOpeningMathSection && currentMathSectionId !== sectionId) {
                    // Show passages view but don't reload content (we're opening a detail view)
                    document.getElementById('landingPage').style.display = 'none';
                    document.getElementById('passagesView').style.display = 'block';
                    document.querySelector('header').style.display = 'flex';
                    // Don't call showPassages(true) as it will show the list - we want to show the detail
                    setTimeout(() => {
                        console.log('Opening math section from hash:', sectionId);
                        openMathSection(sectionId);
                    }, 100);
                }
            } else if (hash === 'passages' || hash === 'lessons' || hash === 'math-sections' || hash === '') {
                // COMMENTED OUT: 'writing-sections' removed from hash check
                console.log('Showing passages view from hash');
                // Only show passages if we're not currently viewing a detail (prevent loop)
                if (!currentPassageId && !currentLessonId && !currentMathSectionId) {
                showPassages(true);
                } else {
                    // We're navigating away from a detail view, clear state and show list
                    currentPassageId = null;
                    currentLessonId = null;
                    currentMathSectionId = null;
                    showPassages(true);
                }
            } else {
                showLanding();
            }
        }
        
        // Listen for hash changes
        window.addEventListener('hashchange', handleHashRoute);
        
        // Initial route handling - wait for DOM to be ready
        // Check if we're returning from Stripe checkout
        const urlParams = new URLSearchParams(window.location.search);
        const fromSubscription = urlParams.get('from') === 'subscription' || localStorage.getItem('pendingSubscription') === 'true';
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                // Check for Google OAuth callback first (before hash route)
                handleGoogleCallback();
                // If we have a token but no user, check auth
                if (authToken && !currentUser) {
                    checkAuth();
                } else if (authToken && fromSubscription) {
                    // Refresh user data after returning from subscription
                    // Delay to ensure all functions are defined
                    setTimeout(() => {
                        if (typeof refreshUserData === 'function') {
                            refreshUserData().then(() => {
                                localStorage.removeItem('pendingSubscription');
                                showPassages();
                            }).catch(err => {
                                console.error('Error refreshing user data:', err);
                                showPassages();
                            });
                        } else {
                            // Fallback: just check auth
                            checkAuth();
                            showPassages();
                        }
                    }, 500);
                } else {
                    handleHashRoute();
                }
            });
        } else {
            // DOM is already ready, but add small delay to ensure all elements are accessible
            setTimeout(() => {
                // Check for Google OAuth callback first (before hash route)
                handleGoogleCallback();
                // If we have a token but no user, check auth
                if (authToken && !currentUser) {
                    checkAuth();
                } else if (authToken && fromSubscription) {
                    // Refresh user data after returning from subscription
                    // Delay to ensure all functions are defined
                    setTimeout(() => {
                        if (typeof refreshUserData === 'function') {
                            refreshUserData().then(() => {
                                localStorage.removeItem('pendingSubscription');
                                showPassages();
                            }).catch(err => {
                                console.error('Error refreshing user data:', err);
                                showPassages();
                            });
                        } else {
                            // Fallback: just check auth
                            checkAuth();
                            showPassages();
                        }
                    }, 500);
                } else {
                    handleHashRoute();
                }
            }, 50);
        }
        
        // Check if user is logged in on load
        if (authToken) {
            checkAuth();
        }
        
        // Load word of the day
        loadWordOfDay();
        
        function showLanding() {
            document.getElementById('landingPage').style.display = 'block';
            document.getElementById('passagesView').style.display = 'none';
            // Hide header on landing page
            document.querySelector('header').style.display = 'none';
            // Update toggle buttons
            document.querySelectorAll('.view-toggle button').forEach(btn => {
                btn.classList.remove('active');
            });
            // Clear any detail view state
            currentPassageId = null;
            currentLessonId = null;
            currentMathSectionId = null;
            // Clear URL hash completely when going to landing page
            if (window.location.hash !== '') {
                window.history.replaceState(null, '', window.location.pathname);
            }
        }
        
        function showPassages(forceReload = false) {
            document.getElementById('landingPage').style.display = 'none';
            document.getElementById('passagesView').style.display = 'block';
            // Show header on passages view
            document.querySelector('header').style.display = 'flex';
            // Update toggle buttons
            document.querySelectorAll('.view-toggle button').forEach(btn => {
                if (btn.textContent === 'Passages') {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            // Reset to list view - make sure all list sections are visible
            document.getElementById('passageDetailSection').style.display = 'none';
            // Make sure list sections are visible
            const passagesListSection = document.getElementById('passagesListSection');
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // const writingSectionsListSection = document.getElementById('writingSectionsListSection');
            // COMMENTED OUT: Math sections removed, only showing lessons
            // const mathSectionsListSection = document.getElementById('mathSectionsListSection');
            if (passagesListSection) passagesListSection.style.display = 'block';
            // if (writingSectionsListSection) writingSectionsListSection.style.display = 'block';
            // if (mathSectionsListSection) mathSectionsListSection.style.display = 'block';
            // Clear any detail view state
            currentPassageId = null;
            currentLessonId = null;
            currentMathSectionId = null;
            // Always update URL to #passages when showing list view (this prevents hashchange from re-opening detail views)
            const currentHash = window.location.hash.substring(1);
            if (currentHash !== 'passages') {
                // Use replaceState to avoid triggering hashchange event
                window.history.replaceState(null, '', window.location.pathname + '#passages');
            }
            // Load content for the current category
            switchCategory(currentCategory, forceReload);
        }
        
        async function checkAuth() {
            if (!authToken) {
                console.log('checkAuth: No authToken, skipping');
                return;
            }
            console.log('checkAuth: Checking auth with token');
            try {
                const response = await fetch(`${API_BASE}/auth/me`, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });
                
                if (response.ok) {
                    currentUser = await response.json();
                    console.log('checkAuth: User authenticated:', currentUser.email);
                    updateUI();
                    // Keep landing page visible - user can navigate to passages when ready
                } else {
                    console.log('checkAuth: Auth failed, removing token');
                    localStorage.removeItem('authToken');
                    authToken = null;
                    currentUser = null;
                    updateUI();
                    loadPassages();
                }
            } catch (error) {
                console.error('Auth check failed:', error);
                localStorage.removeItem('authToken');
                authToken = null;
                currentUser = null;
                updateUI();
                loadPassages();
            }
        }
        
        async function handleLogin(e) {
            e.preventDefault();
            const formData = new FormData(e.target);
            const data = {
                email: formData.get('email'),
                password: formData.get('password')
            };
            
            try {
                const response = await fetch(`${API_BASE}/auth/login`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    authToken = result.tokens.access;
                    localStorage.setItem('authToken', authToken);
                    currentUser = result.user;
                    closeModal('loginModal');
                    updateUI();
                    // Stay on landing page - user can navigate to passages when ready
                } else {
                    document.getElementById('loginError').textContent = result.error?.message || 'Login failed';
                }
            } catch (error) {
                document.getElementById('loginError').textContent = 'Network error. Please try again.';
            }
        }
        
        async function handleGoogleLogin() {
            try {
                // Get the Google OAuth URL from backend
                const response = await fetch(`${API_BASE}/auth/google/url`);
                const result = await response.json();
                
                if (response.ok && result.auth_url) {
                    // Close modals
                    closeModal('loginModal');
                    closeModal('registerModal');
                    // Redirect to Google OAuth
                    window.location.href = result.auth_url;
                } else {
                    alert('Failed to initiate Google login. Please try again.');
                }
            } catch (error) {
                console.error('Google login error:', error);
                alert('Network error. Please try again.');
            }
        }
        
        // Handle Google OAuth callback
        async function handleGoogleCallback() {
            console.log('handleGoogleCallback called, hash:', window.location.hash);
            // Check for tokens in URL fragment (from backend redirect)
            const hash = window.location.hash;
            if (hash.includes('google_oauth=')) {
                console.log('Found google_oauth in hash');
                // Parse hash - could be #passages?google_oauth=... or just #google_oauth=...
                let hashPart = hash.substring(1); // Remove #
                let tokenData = null;
                
                // Check if it has query params
                if (hashPart.includes('?')) {
                    const parts = hashPart.split('?');
                    const params = new URLSearchParams(parts[1]);
                    tokenData = params.get('google_oauth');
                } else {
                    // Direct parameter in hash
                    const params = new URLSearchParams(hashPart);
                    tokenData = params.get('google_oauth');
                }
                
                if (tokenData) {
                    console.log('Found token data, decoding...');
                    try {
                        // Decode base64 token data
                        let padded = tokenData;
                        while (padded.length % 4) {
                            padded += '=';
                        }
                        const decoded = atob(padded);
                        const result = JSON.parse(decoded);
                        console.log('Decoded tokens, full result:', result);
                        
                        // Backend sends: { access, refresh, user }
                        // Validate result structure
                        if (!result.access) {
                            throw new Error('Invalid token structure: missing access token');
                        }
                        if (!result.user) {
                            throw new Error('Invalid token structure: missing user');
                        }
                        
                        // Store tokens and user info
                        try {
                            authToken = result.access;
                            // Also store refresh token for future use
                            if (result.refresh) {
                                localStorage.setItem('refreshToken', result.refresh);
                            }
                            localStorage.setItem('authToken', authToken);
                            currentUser = result.user;
                            console.log('Stored authToken and currentUser:', authToken ? 'YES' : 'NO', currentUser ? 'YES' : 'NO');
                            
                            // Clean up URL - remove google_oauth param but keep navigation
                            const cleanHash = hashPart.split('?')[0] || '#passages';
                            window.history.replaceState({}, document.title, window.location.pathname + cleanHash);
                            
                            // Update UI and navigate - wait a bit for DOM to be ready
                            console.log('Calling updateUI()');
                            try {
                                // Ensure DOM is ready
                                if (document.readyState === 'loading') {
                                    await new Promise(resolve => {
                                        if (document.readyState === 'complete') {
                                            resolve();
                                        } else {
                                            document.addEventListener('DOMContentLoaded', resolve);
                                        }
                                    });
                                }
                                // Small delay to ensure all elements are rendered
                                await new Promise(resolve => setTimeout(resolve, 100));
                                updateUI();
                                console.log('updateUI() completed');
                            } catch (uiError) {
                                console.error('Error in updateUI():', uiError);
                                // Don't throw - try to continue anyway
                            }
                            
                            // Navigate to passages view if not already there
                            if (!hashPart.includes('passages') && !hashPart.includes('writing') && !hashPart.includes('math')) {
                                console.log('Navigating to passages');
                                try {
                                    showPassages();
                                    console.log('showPassages() completed');
                                } catch (navError) {
                                    console.error('Error in showPassages():', navError);
                                    throw navError;
                                }
                            } else {
                                // Already on a view, just trigger the hash change handler
                                console.log('Already on view, calling handleHashRoute');
                                try {
                                    handleHashRoute();
                                    console.log('handleHashRoute() completed');
                                } catch (routeError) {
                                    console.error('Error in handleHashRoute():', routeError);
                                    throw routeError;
                                }
                            }
                            return;
                        } catch (storageError) {
                            console.error('Error storing tokens or updating UI:', storageError);
                            throw storageError;
                        }
                    } catch (error) {
                        console.error('Error in Google OAuth callback:', error);
                        console.error('Error stack:', error.stack);
                        // Try to continue anyway if we have the data
                        if (currentUser && authToken) {
                            console.log('Have user and token, continuing despite error');
                            try {
                                updateUI();
                                showPassages();
                            } catch (recoveryError) {
                                console.error('Recovery also failed:', recoveryError);
                                alert('Login successful but UI update failed. Please refresh the page.');
                            }
                        } else {
                            alert('Failed to complete Google login: ' + (error.message || 'Unknown error'));
                            window.history.replaceState({}, document.title, window.location.pathname);
                        }
                        return;
                    }
                }
            }
            console.log('No google_oauth found in hash');
            
            // Fallback: Check for code in query string (direct API call)
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const error = urlParams.get('error');
            
            if (error) {
                alert(`Google login failed: ${error}`);
                window.history.replaceState({}, document.title, window.location.pathname);
                return;
            }
            
            if (code) {
                try {
                    // Exchange code for tokens
                    const response = await fetch(`${API_BASE}/auth/google/callback?code=${encodeURIComponent(code)}`);
                    const result = await response.json();
                    
                    if (response.ok) {
                        authToken = result.tokens.access;
                        localStorage.setItem('authToken', authToken);
                        currentUser = result.user;
                        window.history.replaceState({}, document.title, window.location.pathname);
                        updateUI();
                        // Navigate to passages after login
                        showPassages();
                    } else {
                        alert(result.error?.message || 'Google login failed');
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }
                } catch (error) {
                    console.error('Google callback error:', error);
                    alert('Failed to complete Google login. Please try again.');
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            }
        }
        
        async function handleRegister(e) {
            e.preventDefault();
            const formData = new FormData(e.target);
            const data = {
                email: formData.get('email'),
                password: formData.get('password')
            };
            
            try {
                const response = await fetch(`${API_BASE}/auth/register`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    authToken = result.tokens.access;
                    localStorage.setItem('authToken', authToken);
                    currentUser = result.user;
                    closeModal('registerModal');
                    updateUI();
                    
                    // If there's a saved attempt from before registration, save it now
                    if (lastAttemptData) {
                        const savedPassageId = lastAttemptData.passage_id;
                        await saveAnonymousAttempt(lastAttemptData);
                        lastAttemptData = null; // Clear after saving
                        
                        // Navigate to passages view
                        showPassages();
                        await loadPassages();
                        
                        // Show attempt history for the passage that was attempted
                        if (savedPassageId) {
                            setTimeout(() => {
                                showAttemptHistory(savedPassageId);
                            }, 500);
                        }
                    } else {
                        // Navigate to passages view
                        showPassages();
                        await loadPassages();
                    }
                } else {
                    document.getElementById('registerError').textContent = result.error?.message || 'Registration failed';
                }
            } catch (error) {
                document.getElementById('registerError').textContent = 'Network error. Please try again.';
            }
        }
        
        let currentCategory = 'reading';
        
        function switchCategory(category, forceReload = false) {
            console.log('switchCategory called with:', category);
            currentCategory = category;
            
            // Hide detail section when switching categories
            const passageDetailSection = document.getElementById('passageDetailSection');
            if (passageDetailSection) {
                passageDetailSection.style.display = 'none';
            }
            
            // Clear current detail view state
            currentPassageId = null;
            currentLessonId = null;
            currentMathSectionId = null;
            
            // Update button states
            document.querySelectorAll('.category-picker button').forEach(btn => {
                btn.classList.remove('active');
            });
            const categoryBtn = document.getElementById(`category-${category}-btn`);
            if (categoryBtn) {
                categoryBtn.classList.add('active');
                console.log('Category button activated:', category);
            } else {
                console.error('Category button not found:', `category-${category}-btn`);
            }
            
            // Update content visibility - hide all category content first
            document.querySelectorAll('.category-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none'; // Explicitly hide
            });
            
            // Show the selected category content
            const categoryContent = document.getElementById(`category-${category}`);
            if (categoryContent) {
                categoryContent.classList.add('active');
                categoryContent.style.display = 'block'; // Explicitly show
                console.log('Category content activated:', category);
            } else {
                console.error('Category content not found:', `category-${category}`);
            }
            
            // Show list sections for the selected category and hide others
            const allListSections = [
                'readingLessonsListSection',
                'passagesListSection',
                'writingLessonsListSection',
                'mathLessonsListSection'
                // COMMENTED OUT: Math sections removed, only showing lessons
                // 'mathSectionsListSection'
            ];
            
            // Hide all list sections first
            allListSections.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.style.display = 'none';
                }
            });
            
            // Show list sections for the selected category
            if (category === 'reading') {
                const readingLessonsListSection = document.getElementById('readingLessonsListSection');
                const passagesListSection = document.getElementById('passagesListSection');
                if (readingLessonsListSection) {
                    readingLessonsListSection.style.display = 'block';
                    console.log('Reading lessons section shown');
                }
                if (passagesListSection) {
                    passagesListSection.style.display = 'block';
                    console.log('Passages section shown');
                }
            } else if (category === 'writing') {
                const writingLessonsListSection = document.getElementById('writingLessonsListSection');
                if (writingLessonsListSection) {
                    writingLessonsListSection.style.display = 'block';
                    console.log('Writing lessons section shown');
                }
            } else if (category === 'math') {
                const mathLessonsListSection = document.getElementById('mathLessonsListSection');
                // COMMENTED OUT: Math sections removed, only showing lessons
                // const mathSectionsListSection = document.getElementById('mathSectionsListSection');
                if (mathLessonsListSection) {
                    mathLessonsListSection.style.display = 'block';
                    console.log('Math lessons section shown');
                }
                // if (mathSectionsListSection) {
                //     mathSectionsListSection.style.display = 'block';
                //     console.log('Math sections section shown');
                // }
            }
            
            // Load content for the selected category
            // Use setTimeout to ensure DOM is ready
            setTimeout(() => {
                if (category === 'reading') {
                    const readingLessonsEl = document.getElementById('readingLessonsList');
                    const passagesEl = document.getElementById('passagesList');
                    if (forceReload || !readingLessonsEl || readingLessonsEl.innerHTML === '') {
                        loadLessonsByType('reading', 'readingLessonsList');
                    }
                    if (forceReload || !passagesEl || passagesEl.innerHTML === '') {
                        loadPassages();
                    }
                } else if (category === 'writing') {
                    const writingLessonsEl = document.getElementById('writingLessonsList');
                    // COMMENTED OUT: Writing sections removed, only showing lessons
                    // const writingSectionsEl = document.getElementById('writingSectionsList');
                    if (forceReload || !writingLessonsEl || writingLessonsEl.innerHTML === '') {
                        loadLessonsByType('writing', 'writingLessonsList');
                    }
                    // COMMENTED OUT: Writing sections removed, only showing lessons
                    // if (forceReload || !writingSectionsEl || writingSectionsEl.innerHTML === '') {
                    //     loadWritingSections();
                    // }
                } else if (category === 'math') {
                    const mathLessonsEl = document.getElementById('mathLessonsList');
                    // COMMENTED OUT: Math sections removed, only showing lessons
                    // const mathSectionsEl = document.getElementById('mathSectionsList');
                    if (forceReload || !mathLessonsEl || mathLessonsEl.innerHTML === '') {
                        loadLessonsByType('math', 'mathLessonsList');
                    }
                    // COMMENTED OUT: Math sections removed, only showing lessons
                    // if (forceReload || !mathSectionsEl || mathSectionsEl.innerHTML === '') {
                    //     loadMathSections();
                    // }
                }
            }, 0);
        }
        
        // Make switchCategory globally accessible
        window.switchCategory = switchCategory;
        
        async function loadLessonsByType(lessonType, listElementId) {
            try {
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`${API_BASE}/lessons/?lesson_type=${lessonType}`, {headers});
                const data = await response.json();
                
                console.log(`Loaded ${lessonType} lessons:`, data.results);
                
                const lessonsList = document.getElementById(listElementId);
                lessonsList.innerHTML = '';
                
                if (data.results && data.results.length > 0) {
                    // Group lessons by header
                    const lessonsByHeader = {};
                    const lessonsWithoutHeader = [];
                    
                    data.results.forEach(lesson => {
                        console.log(`Lesson "${lesson.title}" has header:`, lesson.header);
                        if (lesson.header && lesson.header.id) {
                            const headerId = lesson.header.id;
                            if (!lessonsByHeader[headerId]) {
                                lessonsByHeader[headerId] = {
                                    header: lesson.header,
                                    lessons: []
                                };
                            }
                            lessonsByHeader[headerId].lessons.push(lesson);
                        } else {
                            lessonsWithoutHeader.push(lesson);
                        }
                    });
                    
                    // Sort headers by display_order (higher first)
                    const sortedHeaders = Object.values(lessonsByHeader).sort((a, b) => 
                        (b.header.display_order || 0) - (a.header.display_order || 0)
                    );
                    
                    // Sort lessons within each header by order_within_header (higher first)
                    sortedHeaders.forEach(headerGroup => {
                        headerGroup.lessons.sort((a, b) => 
                            (b.order_within_header || 0) - (a.order_within_header || 0)
                        );
                    });
                    
                    // Display headers with their lessons
                    sortedHeaders.forEach(headerGroup => {
                        // Header section
                        const headerDiv = document.createElement('div');
                        headerDiv.style.cssText = 'margin-bottom: 30px;';
                        headerDiv.innerHTML = `
                            <h3 style="color: #3498DB; font-size: 24px; font-weight: 600; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #3498DB;">
                                ${escapeHtml(headerGroup.header.title)}
                            </h3>
                        `;
                        lessonsList.appendChild(headerDiv);
                        
                        // Lessons under this header
                        const lessonsContainer = document.createElement('div');
                        lessonsContainer.style.cssText = 'margin-left: 20px;';
                        headerGroup.lessons.forEach(lesson => {
                            const card = document.createElement('div');
                            card.className = `passage-card ${lesson.tier === 'premium' ? 'premium' : ''}`;
                            card.style.cssText = 'margin-bottom: 15px;';
                            const isPremium = lesson.tier === 'premium';
                            card.innerHTML = `
                                <h4>${escapeHtml(lesson.title)} ${isPremium ? '<span class="premium-badge">PREMIUM</span> <span class="premium-lock">üîí</span>' : ''}</h4>
                            `;
                            card.onclick = () => openLesson(lesson.id);
                            lessonsContainer.appendChild(card);
                        });
                        headerDiv.appendChild(lessonsContainer);
                    });
                    
                    // Display lessons without headers
                    if (lessonsWithoutHeader.length > 0) {
                        const noHeaderDiv = document.createElement('div');
                        noHeaderDiv.style.cssText = 'margin-top: 30px;';
                        noHeaderDiv.innerHTML = '<h3 style="color: #666; font-size: 20px; font-weight: 600; margin-bottom: 15px;">Other Lessons</h3>';
                        lessonsList.appendChild(noHeaderDiv);
                        
                        const lessonsContainer = document.createElement('div');
                        lessonsContainer.style.cssText = 'margin-left: 20px;';
                        lessonsWithoutHeader.forEach(lesson => {
                            const card = document.createElement('div');
                            card.className = `passage-card ${lesson.tier === 'premium' ? 'premium' : ''}`;
                            card.style.cssText = 'margin-bottom: 15px;';
                            const isPremium = lesson.tier === 'premium';
                            card.innerHTML = `
                                <h4>${escapeHtml(lesson.title)} ${isPremium ? '<span class="premium-badge">PREMIUM</span> <span class="premium-lock">üîí</span>' : ''}</h4>
                            `;
                            card.onclick = () => openLesson(lesson.id);
                            lessonsContainer.appendChild(card);
                        });
                        noHeaderDiv.appendChild(lessonsContainer);
                    }
                    
                    if (sortedHeaders.length === 0 && lessonsWithoutHeader.length === 0) {
                        lessonsList.innerHTML = '<p style="color: #666; font-style: italic;">No lessons available yet.</p>';
                    }
                } else {
                    lessonsList.innerHTML = '<p style="color: #666; font-style: italic;">No lessons available yet.</p>';
                }
            } catch (error) {
                console.error(`Failed to load ${lessonType} lessons:`, error);
                const lessonsList = document.getElementById(listElementId);
                lessonsList.innerHTML = '<p style="color: #999;">Unable to load lessons.</p>';
            }
        }
        
        // COMMENTED OUT: Writing sections removed, only showing lessons
        /*
        async function loadWritingSections() {
            try {
                console.log('Loading writing sections...');
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`${API_BASE}/writing-sections/`, {headers});
                if (!response.ok) {
                    console.error('Failed to fetch writing sections:', response.status, response.statusText);
                    const writingSectionsList = document.getElementById('writingSectionsList');
                    if (writingSectionsList) {
                        writingSectionsList.innerHTML = '<p style="color: #999;">Failed to load writing sections. Please try again.</p>';
                    }
                    return;
                }
                
                const data = await response.json();
                console.log('Writing sections data received:', data);
                
                const writingSectionsList = document.getElementById('writingSectionsList');
                if (!writingSectionsList) {
                    console.error('writingSectionsList element not found!');
                    return;
                }
                writingSectionsList.innerHTML = '';
                
                // Handle both paginated (data.results) and non-paginated (data is array) responses
                const writingSections = Array.isArray(data) ? data : (data.results || []);
                console.log('Processing writing sections:', writingSections.length, 'sections');
                
                if (writingSections && writingSections.length > 0) {
                    writingSections.forEach(writingSection => {
                        const card = document.createElement('div');
                        card.className = `passage-card ${writingSection.tier === 'premium' ? 'premium' : ''}`;
                        const attemptCount = writingSection.attempt_count || 0;
                        const attemptText = attemptCount > 0 ? ` | ${attemptCount} attempt${attemptCount !== 1 ? 's' : ''}` : '';
                        
                        let attemptSummaryHTML = '';
                        if (writingSection.attempt_summary && attemptCount > 0) {
                            const summary = writingSection.attempt_summary;
                            attemptSummaryHTML = `
                                <div style="background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-top: 10px; font-size: 13px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                        <span style="color: #666;"><strong>Best Score:</strong></span>
                                        <span style="color: #3498DB; font-weight: bold;">${summary.best_score}%</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                        <span style="color: #666;"><strong>Latest Score:</strong></span>
                                        <span style="color: #000; font-weight: bold;">${summary.latest_score}%</span>
                                    </div>
                                    ${summary.recent_attempts && summary.recent_attempts.length > 0 ? `
                                        <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #e0e0e0;">
                                            <div style="color: #666; margin-bottom: 6px; font-size: 12px;"><strong>Recent Attempts:</strong></div>
                                            ${summary.recent_attempts.map((attempt, idx) => {
                                                const date = new Date(attempt.completed_at);
                                                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                                                return `
                                                    <div style="display: flex; justify-content: space-between; font-size: 11px; color: #666; margin-bottom: 4px;">
                                                        <span>${dateStr}</span>
                                                        <span style="font-weight: bold; color: #000;">${attempt.score}%</span>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    ` : ''}
                                </div>
                            `;
                        }
                        
                        const isPremium = writingSection.tier === 'premium';
                        const hasAccess = !isPremium || (currentUser && (currentUser.is_premium || currentUser.has_active_subscription));
                        card.innerHTML = `
                            <h3>${writingSection.title} ${isPremium ? '<span class="premium-badge">PREMIUM</span> <span class="premium-lock">üîí</span>' : ''}</h3>
                            <p>Selections: ${writingSection.selection_count || 0}${attemptText}</p>
                            ${attemptSummaryHTML}
                            ${attemptCount > 0 && authToken ? `<button class="btn btn-secondary" onclick="event.stopPropagation(); showWritingSectionAttemptHistory('${writingSection.id}')" style="margin-top: 10px; font-size: 12px; padding: 6px 12px; width: 100%;">View Full Attempt History</button>` : ''}
                        `;
                        card.addEventListener('click', (e) => {
                            // Don't trigger if clicking on a button
                            if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                                return;
                            }
                            console.log('Writing section card clicked:', writingSection.id, writingSection.title);
                            e.preventDefault();
                            e.stopPropagation();
                            openWritingSection(writingSection.id);
                        });
                        card.style.cursor = 'pointer';
                        writingSectionsList.appendChild(card);
                    });
                } else {
                    console.log('No writing sections found in response');
                    writingSectionsList.innerHTML = '<p style="color: #666; font-style: italic;">No writing sections available yet.</p>';
                }
            } catch (error) {
                console.error('Failed to load writing sections:', error);
                console.error('Error details:', error.message, error.stack);
                const writingSectionsList = document.getElementById('writingSectionsList');
                if (writingSectionsList) {
                    writingSectionsList.innerHTML = `<p style="color: #999;">Error loading writing sections: ${error.message}. Please refresh the page.</p>`;
                }
            }
        }
        */
        
        async function loadMathSections() {
            try {
                console.log('Loading math sections...');
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`${API_BASE}/math-sections/`, {headers});
                if (!response.ok) {
                    console.error('Failed to fetch math sections:', response.status, response.statusText);
                    const mathSectionsList = document.getElementById('mathSectionsList');
                    if (mathSectionsList) {
                        mathSectionsList.innerHTML = '<p style="color: #999;">Failed to load math sections. Please try again.</p>';
                    }
                    return;
                }
                
                const data = await response.json();
                console.log('Math sections data received:', data);
                
                const mathSectionsList = document.getElementById('mathSectionsList');
                if (!mathSectionsList) {
                    console.error('mathSectionsList element not found!');
                    return;
                }
                mathSectionsList.innerHTML = '';
                
                // Handle both paginated (data.results) and non-paginated (data is array) responses
                const mathSections = Array.isArray(data) ? data : (data.results || []);
                console.log('Processing math sections:', mathSections.length, 'sections');
                console.log('First math section sample:', mathSections[0]);
                
                if (mathSections && mathSections.length > 0) {
                    // Group math sections by header
                    const sectionsByHeader = {};
                    const sectionsWithoutHeader = [];
                    
                    mathSections.forEach(mathSection => {
                        if (mathSection.header && mathSection.header.id) {
                            const headerId = mathSection.header.id;
                            if (!sectionsByHeader[headerId]) {
                                sectionsByHeader[headerId] = {
                                    header: mathSection.header,
                                    sections: []
                                };
                            }
                            sectionsByHeader[headerId].sections.push(mathSection);
                        } else {
                            sectionsWithoutHeader.push(mathSection);
                        }
                    });
                    
                    // Sort headers by display_order (higher first)
                    const sortedHeaders = Object.values(sectionsByHeader).sort((a, b) => 
                        (b.header.display_order || 0) - (a.header.display_order || 0)
                    );
                    
                    // Sort sections within each header by order_within_header (higher first)
                    sortedHeaders.forEach(headerGroup => {
                        headerGroup.sections.sort((a, b) => 
                            (b.order_within_header || 0) - (a.order_within_header || 0)
                        );
                    });
                    
                    // Display headers with their sections
                    sortedHeaders.forEach(headerGroup => {
                        // Header section
                        const headerDiv = document.createElement('div');
                        headerDiv.style.cssText = 'margin-bottom: 30px;';
                        headerDiv.innerHTML = `
                            <h3 style="color: #3498DB; font-size: 24px; font-weight: 600; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #3498DB;">
                                ${escapeHtml(headerGroup.header.title)}
                            </h3>
                        `;
                        mathSectionsList.appendChild(headerDiv);
                        
                        // Sections under this header
                        const sectionsContainer = document.createElement('div');
                        sectionsContainer.style.cssText = 'margin-left: 20px;';
                        headerGroup.sections.forEach(mathSection => {
                        const card = document.createElement('div');
                        card.className = `passage-card ${mathSection.tier === 'premium' ? 'premium' : ''}`;
                        const attemptCount = mathSection.attempt_count || 0;
                        const attemptText = attemptCount > 0 ? ` | ${attemptCount} attempt${attemptCount !== 1 ? 's' : ''}` : '';
                        
                        let attemptSummaryHTML = '';
                        if (mathSection.attempt_summary && attemptCount > 0) {
                            const summary = mathSection.attempt_summary;
                            attemptSummaryHTML = `
                                <div style="background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-top: 10px; font-size: 13px;">
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                        <span style="color: #666;"><strong>Best Score:</strong></span>
                                        <span style="color: #3498DB; font-weight: bold;">${summary.best_score}%</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                        <span style="color: #666;"><strong>Latest Score:</strong></span>
                                        <span style="color: #000; font-weight: bold;">${summary.latest_score}%</span>
                                    </div>
                                    ${summary.recent_attempts && summary.recent_attempts.length > 0 ? `
                                        <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #e0e0e0;">
                                            <div style="color: #666; margin-bottom: 6px; font-size: 12px;"><strong>Recent Attempts:</strong></div>
                                            ${summary.recent_attempts.map((attempt, idx) => {
                                                const date = new Date(attempt.completed_at);
                                                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                                                return `
                                                    <div style="display: flex; justify-content: space-between; font-size: 11px; color: #666; margin-bottom: 4px;">
                                                        <span>${dateStr}</span>
                                                        <span style="font-weight: bold; color: #000;">${attempt.score}%</span>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    ` : ''}
                                </div>
                            `;
                        }
                        
                        const isPremium = mathSection.tier === 'premium';
                        const hasAccess = !isPremium || (currentUser && (currentUser.is_premium || currentUser.has_active_subscription));
                        card.innerHTML = `
                            <h3>${mathSection.title} ${isPremium ? '<span class="premium-badge">PREMIUM</span> <span class="premium-lock">üîí</span>' : ''}</h3>
                            ${attemptText ? `<p>${attemptText}</p>` : ''}
                            ${attemptSummaryHTML}
                            ${attemptCount > 0 && authToken ? `<button class="btn btn-secondary" onclick="event.stopPropagation(); showMathSectionAttemptHistory('${mathSection.id}')" style="margin-top: 10px; font-size: 12px; padding: 6px 12px; width: 100%;">View Full Attempt History</button>` : ''}
                        `;
                        card.addEventListener('click', (e) => {
                            // Don't trigger if clicking on a button
                            if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                                return;
                            }
                            console.log('Math section card clicked:', mathSection.id, mathSection.title);
                            e.preventDefault();
                            e.stopPropagation();
                            openMathSection(mathSection.id);
                        });
                        card.style.cursor = 'pointer';
                        sectionsContainer.appendChild(card);
                        });
                        headerDiv.appendChild(sectionsContainer);
                    });
                    
                    // Display sections without headers
                    if (sectionsWithoutHeader.length > 0) {
                        sectionsWithoutHeader.forEach(mathSection => {
                            const card = document.createElement('div');
                            card.className = `passage-card ${mathSection.tier === 'premium' ? 'premium' : ''}`;
                            const attemptCount = mathSection.attempt_count || 0;
                            const attemptText = attemptCount > 0 ? ` | ${attemptCount} attempt${attemptCount !== 1 ? 's' : ''}` : '';
                            
                            let attemptSummaryHTML = '';
                            if (mathSection.attempt_summary && attemptCount > 0) {
                                const summary = mathSection.attempt_summary;
                                attemptSummaryHTML = `
                                    <div style="background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-top: 10px; font-size: 13px;">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: #666;"><strong>Best Score:</strong></span>
                                            <span style="color: #3498DB; font-weight: bold;">${summary.best_score}%</span>
                                        </div>
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: #666;"><strong>Latest Score:</strong></span>
                                            <span style="color: #000; font-weight: bold;">${summary.latest_score}%</span>
                                        </div>
                                        ${summary.recent_attempts && summary.recent_attempts.length > 0 ? `
                                            <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #e0e0e0;">
                                                <div style="color: #666; margin-bottom: 6px; font-size: 12px;"><strong>Recent Attempts:</strong></div>
                                                ${summary.recent_attempts.map((attempt, idx) => {
                                                    const date = new Date(attempt.completed_at);
                                                    const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                                                    return `
                                                        <div style="display: flex; justify-content: space-between; font-size: 11px; color: #666; margin-bottom: 4px;">
                                                            <span>${dateStr}</span>
                                                            <span style="font-weight: bold; color: #000;">${attempt.score}%</span>
                                                        </div>
                                                    `;
                                                }).join('')}
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            }
                            
                            const isPremium = mathSection.tier === 'premium';
                            card.innerHTML = `
                                <h3>${mathSection.title} ${isPremium ? '<span class="premium-badge">PREMIUM</span> <span class="premium-lock">üîí</span>' : ''}</h3>
                                ${attemptText ? `<p>${attemptText}</p>` : ''}
                                ${attemptSummaryHTML}
                                ${attemptCount > 0 && authToken ? `<button class="btn btn-secondary" onclick="event.stopPropagation(); showMathSectionAttemptHistory('${mathSection.id}')" style="margin-top: 10px; font-size: 12px; padding: 6px 12px; width: 100%;">View Full Attempt History</button>` : ''}
                            `;
                            card.addEventListener('click', (e) => {
                                // Don't trigger if clicking on a button
                                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                                    return;
                                }
                                console.log('Math section card clicked (no header):', mathSection.id, mathSection.title);
                                e.preventDefault();
                                e.stopPropagation();
                                openMathSection(mathSection.id);
                            });
                            card.style.cursor = 'pointer';
                            mathSectionsList.appendChild(card);
                        });
                    }
                } else {
                    console.log('No math sections found in response');
                    mathSectionsList.innerHTML = '<p style="color: #666; font-style: italic;">No math sections available yet.</p>';
                }
            } catch (error) {
                console.error('Failed to load math sections:', error);
                console.error('Error details:', error.message, error.stack);
                const mathSectionsList = document.getElementById('mathSectionsList');
                if (mathSectionsList) {
                    mathSectionsList.innerHTML = `<p style="color: #999;">Error loading math sections: ${error.message}. Please refresh the page.</p>`;
                }
            }
        }
        
        async function loadPassages() {
            try {
                console.log('Loading passages...');
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`${API_BASE}/passages/`, {headers});
                if (!response.ok) {
                    console.error('Failed to fetch passages:', response.status, response.statusText);
                    const passagesList = document.getElementById('passagesList');
                    if (passagesList) {
                        passagesList.innerHTML = '<p style="color: #999;">Failed to load passages. Please try again.</p>';
                    }
                    return;
                }
                
                const data = await response.json();
                console.log('Passages data received:', data);
                
                const passagesList = document.getElementById('passagesList');
                if (!passagesList) {
                    console.error('passagesList element not found!');
                    return;
                }
                passagesList.innerHTML = '';
                
                // Handle both paginated (data.results) and non-paginated (data is array) responses
                const passages = Array.isArray(data) ? data : (data.results || []);
                console.log('Processing passages:', passages.length, 'passages');
                console.log('First passage sample:', passages[0]);
                
                if (passages && passages.length > 0) {
                    // Group passages by header
                    const passagesByHeader = {};
                    const passagesWithoutHeader = [];
                    
                    passages.forEach(passage => {
                        if (passage.header && passage.header.id) {
                            const headerId = passage.header.id;
                            if (!passagesByHeader[headerId]) {
                                passagesByHeader[headerId] = {
                                    header: passage.header,
                                    passages: []
                                };
                            }
                            passagesByHeader[headerId].passages.push(passage);
                        } else {
                            passagesWithoutHeader.push(passage);
                        }
                    });
                    
                    // Sort headers by display_order (higher first)
                    const sortedHeaders = Object.values(passagesByHeader).sort((a, b) => 
                        (b.header.display_order || 0) - (a.header.display_order || 0)
                    );
                    
                    // Sort passages within each header by order_within_header (higher first)
                    sortedHeaders.forEach(headerGroup => {
                        headerGroup.passages.sort((a, b) => 
                            (b.order_within_header || 0) - (a.order_within_header || 0)
                        );
                    });
                    
                    // Display headers with their passages
                    sortedHeaders.forEach(headerGroup => {
                        // Header section
                        const headerDiv = document.createElement('div');
                        headerDiv.style.cssText = 'margin-bottom: 30px;';
                        headerDiv.innerHTML = `
                            <h3 style="color: #3498DB; font-size: 24px; font-weight: 600; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #3498DB;">
                                ${escapeHtml(headerGroup.header.title)}
                            </h3>
                        `;
                        passagesList.appendChild(headerDiv);
                        
                        // Passages under this header
                        const passagesContainer = document.createElement('div');
                        passagesContainer.style.cssText = 'margin-left: 20px;';
                        headerGroup.passages.forEach(passage => {
                            const card = document.createElement('div');
                            card.className = `passage-card ${passage.tier === 'premium' ? 'premium' : ''}`;
                            card.style.cssText = 'margin-bottom: 15px;';
                            const attemptCount = passage.attempt_count || 0;
                            const attemptText = attemptCount > 0 ? ` | ${attemptCount} attempt${attemptCount !== 1 ? 's' : ''}` : '';
                            
                            let attemptSummaryHTML = '';
                            if (passage.attempt_summary && attemptCount > 0) {
                                const summary = passage.attempt_summary;
                                attemptSummaryHTML = `
                                    <div style="background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-top: 10px; font-size: 13px;">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: #666;"><strong>Best Score:</strong></span>
                                            <span style="color: #3498DB; font-weight: bold;">${summary.best_score}%</span>
                                        </div>
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: #666;"><strong>Latest Score:</strong></span>
                                            <span style="color: #000; font-weight: bold;">${summary.latest_score}%</span>
                                        </div>
                                        ${summary.recent_attempts && summary.recent_attempts.length > 0 ? `
                                            <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #e0e0e0;">
                                                <div style="color: #666; margin-bottom: 6px; font-size: 12px;"><strong>Recent Attempts:</strong></div>
                                                ${summary.recent_attempts.map((attempt, idx) => {
                                                    const date = new Date(attempt.completed_at);
                                                    const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                                                    return `
                                                        <div style="display: flex; justify-content: space-between; font-size: 11px; color: #666; margin-bottom: 4px;">
                                                            <span>${dateStr}</span>
                                                            <span style="font-weight: bold; color: #000;">${attempt.score}%</span>
                                                        </div>
                                                    `;
                                                }).join('')}
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            }
                            
                            const isPremium = passage.tier === 'premium';
                            card.setAttribute('data-passage-id', passage.id);
                            card.innerHTML = `
                                <h3>${escapeHtml(passage.title)} ${isPremium ? '<span class="premium-badge">PREMIUM</span> <span class="premium-lock">üîí</span>' : ''}</h3>
                                ${attemptText ? `<p>${attemptText}</p>` : ''}
                                ${attemptSummaryHTML}
                                ${attemptCount > 0 && authToken ? `<button class="btn btn-secondary" onclick="event.stopPropagation(); event.preventDefault(); showAttemptHistory('${passage.id}'); return false;" style="margin-top: 10px; font-size: 12px; padding: 6px 12px; width: 100%;">View Full Attempt History</button>` : ''}
                            `;
                            card.addEventListener('click', (e) => {
                                // Don't trigger if clicking on a button
                                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                                    return;
                                }
                                console.log('Passage card clicked:', passage.id, passage.title);
                                e.preventDefault();
                                e.stopPropagation();
                                openPassage(passage.id);
                            });
                            card.style.cursor = 'pointer';
                            passagesContainer.appendChild(card);
                        });
                        headerDiv.appendChild(passagesContainer);
                    });
                    
                    // Display passages without headers
                    if (passagesWithoutHeader.length > 0) {
                        passagesWithoutHeader.forEach(passage => {
                            const card = document.createElement('div');
                            card.className = `passage-card ${passage.tier === 'premium' ? 'premium' : ''}`;
                            card.style.cssText = 'margin-bottom: 15px;';
                            const attemptCount = passage.attempt_count || 0;
                            const attemptText = attemptCount > 0 ? ` | ${attemptCount} attempt${attemptCount !== 1 ? 's' : ''}` : '';
                            
                            let attemptSummaryHTML = '';
                            if (passage.attempt_summary && attemptCount > 0) {
                                const summary = passage.attempt_summary;
                                attemptSummaryHTML = `
                                    <div style="background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-top: 10px; font-size: 13px;">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: #666;"><strong>Best Score:</strong></span>
                                            <span style="color: #3498DB; font-weight: bold;">${summary.best_score}%</span>
                                        </div>
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="color: #666;"><strong>Latest Score:</strong></span>
                                            <span style="color: #000; font-weight: bold;">${summary.latest_score}%</span>
                                        </div>
                                        ${summary.recent_attempts && summary.recent_attempts.length > 0 ? `
                                            <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid #e0e0e0;">
                                                <div style="color: #666; margin-bottom: 6px; font-size: 12px;"><strong>Recent Attempts:</strong></div>
                                                ${summary.recent_attempts.map((attempt, idx) => {
                                                    const date = new Date(attempt.completed_at);
                                                    const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                                                    return `
                                                        <div style="display: flex; justify-content: space-between; font-size: 11px; color: #666; margin-bottom: 4px;">
                                                            <span>${dateStr}</span>
                                                            <span style="font-weight: bold; color: #000;">${attempt.score}%</span>
                                                        </div>
                                                    `;
                                                }).join('')}
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            }
                            
                            const isPremium = passage.tier === 'premium';
                            card.setAttribute('data-passage-id', passage.id);
                            card.innerHTML = `
                                <h3>${escapeHtml(passage.title)} ${isPremium ? '<span class="premium-badge">PREMIUM</span> <span class="premium-lock">üîí</span>' : ''}</h3>
                                ${attemptText ? `<p>${attemptText}</p>` : ''}
                                ${attemptSummaryHTML}
                                ${attemptCount > 0 && authToken ? `<button class="btn btn-secondary" onclick="event.stopPropagation(); event.preventDefault(); showAttemptHistory('${passage.id}'); return false;" style="margin-top: 10px; font-size: 12px; padding: 6px 12px; width: 100%;">View Full Attempt History</button>` : ''}
                            `;
                            card.addEventListener('click', (e) => {
                                // Don't trigger if clicking on a button
                                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                                    return;
                                }
                                console.log('Passage card clicked (no header):', passage.id, passage.title);
                                e.preventDefault();
                                e.stopPropagation();
                                openPassage(passage.id);
                            });
                            card.style.cursor = 'pointer';
                            passagesList.appendChild(card);
                        });
                    }
                } else {
                    console.log('No passages found in response');
                    passagesList.innerHTML = '<p style="color: #666; font-style: italic;">No passages available yet.</p>';
                }
            } catch (error) {
                console.error('Failed to load passages:', error);
                console.error('Error details:', error.message, error.stack);
                const passagesList = document.getElementById('passagesList');
                if (passagesList) {
                    passagesList.innerHTML = `<p style="color: #999;">Error loading passages: ${error.message}. Please refresh the page.</p>`;
                }
            }
        }
        
        let currentPassageId = null;
        let currentPassageData = null;
        let currentLessonId = null;
        let currentLessonData = null;
        let currentWritingSectionId = null;
        let currentMathSectionId = null;
        let currentMathSectionData = null;
        let currentWritingSectionData = null;
        let userAnswers = {};
        
        async function openLesson(lessonId) {
            try {
                currentLessonId = lessonId;
                // Clear other detail view states
                currentPassageId = null;
                currentPassageData = null;
                currentMathSectionId = null;
                currentMathSectionData = null;
                currentWritingSectionId = null;
                currentWritingSectionData = null;
                userAnswers = {};
                
                // Update URL hash (replaceState doesn't trigger hashchange, which is what we want)
                window.history.replaceState(null, '', window.location.pathname + `#lesson/${lessonId}`);
                
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                // Fetch lesson detail
                const lessonResponse = await fetch(`${API_BASE}/lessons/${lessonId}`, {headers});
                if (lessonResponse.status === 403) {
                    // Try to get lesson data anyway for preview
                    const previewResponse = await fetch(`${API_BASE}/lessons/${lessonId}`, {});
                    if (previewResponse.ok) {
                        const lessonData = await previewResponse.json();
                        displayLessonPreview(lessonData, 'lesson');
                    } else {
                        // Show upgrade modal instead of alert
                        showUpgradeModal('lesson');
                    }
                    return;
                }
                
                if (!lessonResponse.ok) {
                    alert('Failed to load lesson. Please try again.');
                    return;
                }
                
                const lessonData = await lessonResponse.json();
                currentLessonData = lessonData;
                
                // Check if premium and user doesn't have access
                if (lessonData.tier === 'premium' && (!currentUser || (!currentUser.is_premium && !currentUser.has_active_subscription))) {
                    displayLessonPreview(lessonData, 'lesson');
                } else {
                    // Display lesson
                    displayLesson(lessonData);
                }
                
            } catch (error) {
                console.error('Failed to open lesson:', error);
                alert('Network error. Please try again.');
            }
        }
        
        function displayLesson(lesson) {
            // Hide all category content containers (which contain the list sections)
            document.querySelectorAll('.category-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Hide all list sections individually as well
            const passagesListSection = document.getElementById('passagesListSection');
            const readingLessonsListSection = document.getElementById('readingLessonsListSection');
            const writingSectionsListSection = document.getElementById('writingSectionsListSection');
            const writingLessonsListSection = document.getElementById('writingLessonsListSection');
            const mathSectionsListSection = document.getElementById('mathSectionsListSection');
            const mathLessonsListSection = document.getElementById('mathLessonsListSection');
            const passageDetailSection = document.getElementById('passageDetailSection');
            
            if (passagesListSection) passagesListSection.style.display = 'none';
            if (readingLessonsListSection) readingLessonsListSection.style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // if (writingSectionsListSection) writingSectionsListSection.style.display = 'none';
            if (writingLessonsListSection) writingLessonsListSection.style.display = 'none';
            if (mathSectionsListSection) mathSectionsListSection.style.display = 'none';
            if (mathLessonsListSection) mathLessonsListSection.style.display = 'none';
            if (passageDetailSection) passageDetailSection.style.display = 'block';
            
            // Hide word of the day when viewing lessons
            const wordOfDay = document.getElementById('wordOfDay');
            if (wordOfDay) wordOfDay.style.display = 'none';
            
            // Clear attempt history button
            document.getElementById('attemptHistoryButtonContainer').innerHTML = '';
            
            // Build a map of questions by chunk_index to their assets and question objects
            const questionAssetsMap = {};
            const questionMap = {}; // Map chunk_index to question object
            if (lesson.questions) {
                lesson.questions.forEach(question => {
                    questionMap[question.chunk_index] = question;
                    if (question.assets && question.assets.length > 0) {
                        questionAssetsMap[question.chunk_index] = question.assets;
                        console.log(`Question at chunk ${question.chunk_index} has ${question.assets.length} asset(s) from question.assets`);
                    }
                });
            }
            
            // Also check chunks directly for assets (in case they're in the JSON but not linked yet)
            if (lesson.chunks) {
                lesson.chunks.forEach((chunk, chunkIdx) => {
                    if (chunk.type === 'question' && chunk.assets && chunk.assets.length > 0) {
                        // If we don't have assets from question object, use chunk assets
                        if (!questionAssetsMap[chunkIdx]) {
                            // Map asset_ids to full asset objects from lesson.assets
                            const chunkAssetObjects = [];
                            chunk.assets.forEach(assetId => {
                                // Find the asset in lesson.assets by asset_id
                                const asset = lesson.assets?.find(a => a.asset_id === assetId);
                                if (asset) {
                                    chunkAssetObjects.push(asset);
                                } else {
                                    console.warn(`Asset ${assetId} referenced in chunk ${chunkIdx} but not found in lesson.assets`);
                                }
                            });
                            if (chunkAssetObjects.length > 0) {
                                questionAssetsMap[chunkIdx] = chunkAssetObjects;
                                console.log(`Found ${chunkAssetObjects.length} asset(s) for chunk ${chunkIdx} from chunk.assets`);
                            }
                        }
                    }
                });
            }
            
            // If we still don't have assets but lesson.assets exists, try to match by question order
            // This is a fallback for cases where assets exist but aren't linked
            if (lesson.assets && lesson.assets.length > 0 && Object.keys(questionAssetsMap).length === 0) {
                console.warn('No assets linked to questions, but lesson has assets. Attempting to match by question order...');
                // For now, just log - we'd need more context to match properly
                // But at least show that assets exist
                console.log(`Lesson has ${lesson.assets.length} asset(s) available but not linked to questions`);
            }
            
            // Debug logging
            console.log('Lesson assets:', lesson.assets);
            console.log('Lesson lesson_id:', lesson.lesson_id);
            console.log('Question assets map:', questionAssetsMap);
            console.log('Lesson chunks with assets:', lesson.chunks?.filter(c => c.type === 'question' && c.assets));
            
            // Check for sentinels in chunks
            if (lesson.chunks) {
                lesson.chunks.forEach((chunk, idx) => {
                    if (chunk.text && chunk.text.includes('[[Diagram')) {
                        console.log(`Chunk ${idx} (type: ${chunk.type}) contains sentinel:`, chunk.text.substring(0, 200));
                    }
                });
            }
            
            // Log each question's assets
            if (lesson.questions) {
                lesson.questions.forEach(q => {
                    if (q.assets && q.assets.length > 0) {
                        console.log(`Question at chunk ${q.chunk_index} has assets:`, q.assets);
                    }
                });
            }
            
            // Split chunks into pages based on page_break markers
            const pages = [];
            let currentPage = [];
            
            if (lesson.chunks) {
                lesson.chunks.forEach((chunk, chunkIdx) => {
                    if (chunk.type === 'page_break') {
                        // Save current page and start a new one
                        if (currentPage.length > 0) {
                            pages.push(currentPage);
                            currentPage = [];
                        }
                    } else {
                        currentPage.push({chunk, chunkIdx});
                    }
                });
                // Add the last page if it has content
                if (currentPage.length > 0) {
                    pages.push(currentPage);
                }
            }
            
            // If no page breaks, treat entire lesson as one page
            if (pages.length === 0 && lesson.chunks) {
                const allChunks = lesson.chunks.map((chunk, idx) => ({chunk, chunkIdx: idx}));
                pages.push(allChunks);
            }
            
            // Store pages in lesson data for navigation
            lesson.pages = pages;
            lesson.currentPageIndex = 0;
            
            // Render the first page
            renderLessonPage(lesson, 0, questionAssetsMap, questionMap);
        }
        
        function renderLessonPage(lesson, pageIndex, questionAssetsMap, questionMap) {
            const pages = lesson.pages || [];
            if (pageIndex < 0 || pageIndex >= pages.length) {
                console.error('Invalid page index:', pageIndex);
                return;
            }
            
            const currentPage = pages[pageIndex];
            const totalPages = pages.length;
            
            // Render lesson content from chunks for this page
            let contentHTML = `<h2 style="color: #3498DB; margin-bottom: 15px;">${escapeHtml(lesson.title)}</h2>`;
            
            // Add pagination controls
            if (totalPages > 1) {
                const paginationBg = document.body.classList.contains('dark-mode') ? 'var(--bg-secondary)' : '#f5f5f5';
                const paginationText = document.body.classList.contains('dark-mode') ? 'var(--text-primary)' : '#333';
                contentHTML += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding: 10px; background: ${paginationBg}; border-radius: 8px; border: 1px solid var(--border-color);">`;
                contentHTML += `<button id="prevPageBtn" onclick="navigateLessonPage(${pageIndex - 1})" ${pageIndex === 0 ? 'disabled style="opacity: 0.5; cursor: not-allowed; padding: 8px 16px; background: var(--bg-tertiary); color: var(--text-secondary); border: none; border-radius: 4px;"' : 'style="padding: 8px 16px; background: var(--accent-color); color: white; border: none; border-radius: 4px; cursor: pointer;"'}>&larr; Previous</button>`;
                contentHTML += `<span style="font-weight: bold; color: ${paginationText};">Page ${pageIndex + 1} of ${totalPages}</span>`;
                contentHTML += `<button id="nextPageBtn" onclick="navigateLessonPage(${pageIndex + 1})" ${pageIndex === totalPages - 1 ? 'disabled style="opacity: 0.5; cursor: not-allowed; padding: 8px 16px; background: var(--bg-tertiary); color: var(--text-secondary); border: none; border-radius: 4px;"' : 'style="padding: 8px 16px; background: var(--accent-color); color: white; border: none; border-radius: 4px; cursor: pointer;"'}>Next &rarr;</button>`;
                contentHTML += `</div>`;
            }
            
            contentHTML += '<div class="lesson-content" style="max-width: 800px; margin: 0 auto;">';
            
            currentPage.forEach(({chunk, chunkIdx}) => {
                const chunkType = chunk.type;
                
                // Debug: log chunk types to see what we're rendering
                if (chunkIdx === 0 || chunkType === 'side_by_side' || chunkType === 'paragraph') {
                    console.log(`Chunk ${chunkIdx}: type="${chunkType}"`, chunk);
                }
                
                if (chunkType === 'header') {
                    const level = chunk.level || 1;
                    const text = chunk.text || '';
                    const tag = `h${Math.min(level + 1, 6)}`;
                    contentHTML += `<${tag} style="color: #3498DB; margin-top: 20px; margin-bottom: 10px;">${escapeHtml(text)}</${tag}>`;
                } else if (chunkType === 'paragraph') {
                    const chunkText = chunk.text || '';
                    // Debug: log if this paragraph contains a sentinel
                    if (chunkText.includes('[[Diagram')) {
                        console.log(`Paragraph chunk ${chunkIdx} contains sentinel. Text:`, chunkText.substring(0, 200));
                    }
                    let processedText = replaceDiagramSentinels(chunkText, lesson.assets || [], lesson.lesson_id);
                    processedText = replaceUnderlineSentinels(processedText);
                    contentHTML += `<p style="margin-bottom: 15px; line-height: 1.6; color: #000;">${processedText}</p>`;
                } else if (chunkType === 'example') {
                    let processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    processedText = replaceUnderlineSentinels(processedText);
                    contentHTML += `<div style="background: #f0f8ff; border-left: 4px solid #3498DB; padding: 10px 15px; margin: 15px 0; font-style: italic; color: #000;">${processedText}</div>`;
                } else if (chunkType === 'example_correct') {
                    let processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    processedText = replaceUnderlineSentinels(processedText);
                    contentHTML += `<div style="background: #f0fff0; border-left: 4px solid #28a745; padding: 10px 15px; margin: 15px 0; font-style: italic; color: #000;">‚úì ${processedText}</div>`;
                } else if (chunkType === 'example_incorrect') {
                    let processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    processedText = replaceUnderlineSentinels(processedText);
                    contentHTML += `<div style="background: #fff0f0; border-left: 4px solid #dc3545; padding: 10px 15px; margin: 15px 0; font-style: italic; color: #000;">‚úó ${processedText}</div>`;
                } else if (chunkType === 'rule') {
                    let processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    processedText = replaceUnderlineSentinels(processedText);
                    contentHTML += `<div style="background: #fff9e6; border-left: 4px solid #ffc107; padding: 10px 15px; margin: 15px 0; font-weight: bold; color: #000;">Rule: ${processedText}</div>`;
                } else if (chunkType === 'definition') {
                    let processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    processedText = replaceUnderlineSentinels(processedText);
                    contentHTML += `<div style="margin: 15px 0;"><strong style="color: #3498DB;">${escapeHtml(chunk.term || '')}:</strong> <span style="color: #000;">${processedText}</span></div>`;
                } else if (chunkType === 'list' || chunkType === 'bullet_list') {
                    const items = chunk.items || [];
                    const listType = chunkType === 'bullet_list' ? 'ul' : 'ol';
                    contentHTML += `<${listType} style="margin: 15px 0; padding-left: 30px; color: #000;">`;
                    items.forEach(item => {
                        let processedItem = replaceDiagramSentinels(item, lesson.assets || [], lesson.lesson_id);
                        processedItem = replaceUnderlineSentinels(processedItem);
                        contentHTML += `<li style="margin-bottom: 8px;">${processedItem}</li>`;
                    });
                    contentHTML += `</${listType}>`;
                } else if (chunkType === 'question') {
                    // Get the question object if it exists
                    const questionObj = questionMap[chunkIdx];
                    const questionId = questionObj ? questionObj.id : `chunk_${chunkIdx}`;
                    
                    // Render question directly from chunk (questions are embedded in chunks)
                    contentHTML += `<div class="question-card" style="margin: 20px 0; padding: 15px; border: 2px solid #3498DB; border-radius: 8px; background: #f9f9f9;">`;
                    
                    // Handle both JSON blocks (from questionObj.text) and plain text (from chunk.prompt)
                    let processedPrompt = '';
                    if (questionObj && Array.isArray(questionObj.text)) {
                        // New format: array of blocks
                        processedPrompt = formatLessonPrompt(questionObj.text, lesson.assets || [], lesson.lesson_id);
                    } else if (chunk.prompt) {
                        // Old format: plain text from chunk
                        processedPrompt = replaceDiagramSentinels(chunk.prompt, lesson.assets || [], lesson.lesson_id);
                        processedPrompt = replaceUnderlineSentinels(processedPrompt);
                        processedPrompt = `<h4 style="color: #000; margin-bottom: 10px;">${processedPrompt}</h4>`;
                    } else {
                        processedPrompt = '<h4 style="color: #000; margin-bottom: 10px;">[No question text]</h4>';
                    }
                    contentHTML += processedPrompt;
                    
                    // Diagrams should ONLY appear if embedded in the prompt blocks themselves
                    // (via side-by-side blocks or sentinels). We do NOT show linked assets
                    // separately to avoid artifacts. If a question needs a diagram, it must
                    // be added to the prompt blocks using the admin editor.
                    
                    contentHTML += `<div class="options-container">`;
                    (chunk.choices || []).forEach((choice, idx) => {
                        contentHTML += `
                            <div class="option" onclick="selectOption('${questionId}', ${idx})">
                                <input type="radio" name="question_${questionId}" value="${idx}" id="opt_${questionId}_${idx}">
                                <label class="option-label" for="opt_${questionId}_${idx}" style="color: #000; cursor: pointer; display: block; padding: 8px; border-radius: 4px; transition: background 0.2s;">
                                    ${String.fromCharCode(65 + idx)}. ${escapeHtml(choice)}
                                </label>
                            </div>
                        `;
                    });
                    contentHTML += `</div>`;
                    
                    // Add explanation container (hidden initially, shown after selection)
                    const explanation = questionObj ? questionObj.explanation : null;
                    if (explanation) {
                        let processedExplanation = '';
                        if (Array.isArray(explanation)) {
                            // New format: array of blocks (use formatMathExplanation which handles both)
                            processedExplanation = formatMathExplanation(explanation, false);
                            // Also process sentinels
                            processedExplanation = replaceDiagramSentinels(processedExplanation, lesson.assets || [], lesson.lesson_id);
                        } else if (typeof explanation === 'string') {
                            // Old format: plain text
                            processedExplanation = replaceDiagramSentinels(explanation, lesson.assets || [], lesson.lesson_id);
                            processedExplanation = replaceUnderlineSentinels(processedExplanation);
                        }
                        const explanationBg = document.body.classList.contains('dark-mode') ? 'rgba(52, 152, 219, 0.15)' : '#f0f8ff';
                        const explanationColor = document.body.classList.contains('dark-mode') ? 'var(--text-primary)' : '#000';
                        contentHTML += `<div id="explanation_${questionId}" style="display: none; margin-top: 15px; padding: 12px; background: ${explanationBg}; border-left: 4px solid var(--accent-color); border-radius: 4px; color: ${explanationColor};">
                            <strong>Explanation:</strong> ${processedExplanation}
                        </div>`;
                    }
                    
                    contentHTML += `</div>`;
                } else if (chunkType === 'note') {
                    const processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    contentHTML += `<div style="background: #e3f2fd; border-left: 4px solid #2196F3; padding: 10px 15px; margin: 15px 0; color: #000;">üìù Note: ${processedText}</div>`;
                } else if (chunkType === 'warning') {
                    const processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    contentHTML += `<div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 10px 15px; margin: 15px 0; color: #000;">‚ö†Ô∏è Warning: ${processedText}</div>`;
                } else if (chunkType === 'summary') {
                    const processedText = replaceDiagramSentinels(chunk.text || '', lesson.assets || [], lesson.lesson_id);
                    contentHTML += `<div style="background: #f0f0f0; border: 2px solid #666; padding: 15px; margin: 20px 0; border-radius: 8px; color: #000;"><strong>Summary:</strong> ${processedText}</div>`;
                } else if (chunkType === 'side_by_side') {
                    // Side-by-side layout: supports multiple rows (explanation/diagram pairs)
                    console.log('Rendering side_by_side chunk:', chunk);
                    
                    // Support both new format (rows array) and legacy format (single explanation/diagram)
                    let rows = [];
                    if (chunk.rows && Array.isArray(chunk.rows)) {
                        // New format: multiple rows
                        rows = chunk.rows;
                    } else if (chunk.explanation || chunk.diagram_asset_id) {
                        // Legacy format: single row
                        rows = [{
                            explanation: chunk.explanation || '',
                            diagram_asset_id: chunk.diagram_asset_id || ''
                        }];
                    }
                    
                    // Render each row
                    rows.forEach((row, rowIndex) => {
                        const explanation = row.explanation || '';
                        const diagramAssetId = row.diagram_asset_id || '';
                        const rightText = row.right_text || '';
                        const rightTextFormatting = row.right_text_formatting !== false; // Default to true
                        
                        // Escape and process explanation text (handle underlines)
                        let processedExplanation = escapeHtml(explanation);
                        processedExplanation = replaceUnderlineSentinels(processedExplanation);
                        
                        // Determine right side content: diagram or text
                        let rightSideHtml = '';
                        
                        if (diagramAssetId) {
                            // Use diagram
                            if (lesson.assets) {
                                const diagramAsset = lesson.assets.find(asset => asset.asset_id === diagramAssetId);
                                if (diagramAsset) {
                                    let imageUrl = diagramAsset.s3_url || diagramAsset.url || '';
                                    if (imageUrl) {
                                        imageUrl = imageUrl.trim().replace(/[: ]+$/, '');
                                        if (!/\.(png|jpg|jpeg|gif|svg|webp)$/i.test(imageUrl)) {
                                            if (!imageUrl.includes('.')) {
                                                imageUrl += '.png';
                                            }
                                        }
                                        rightSideHtml = `<img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(diagramAssetId)}" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: block;" onerror="console.error('Failed to load diagram:', this.src); this.style.display='none';" />`;
                                    } else if (lesson.lesson_id) {
                                        // Fallback: construct URL
                                        const constructedUrl = `https://keuvi.s3.amazonaws.com/lessons/${lesson.lesson_id}/${diagramAssetId}.png`;
                                        rightSideHtml = `<img src="${escapeHtml(constructedUrl)}" alt="${escapeHtml(diagramAssetId)}" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: block;" onerror="console.error('Failed to load diagram:', this.src); this.style.display='none';" />`;
                                    }
                                } else if (lesson.lesson_id) {
                                    // Asset not found in list, try constructing URL
                                    const constructedUrl = `https://keuvi.s3.amazonaws.com/lessons/${lesson.lesson_id}/${diagramAssetId}.png`;
                                    rightSideHtml = `<img src="${escapeHtml(constructedUrl)}" alt="${escapeHtml(diagramAssetId)}" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: block;" onerror="console.error('Failed to load diagram:', this.src); this.style.display='none';" />`;
                                }
                            }
                            
                            if (!rightSideHtml) {
                                rightSideHtml = `<span style="color: #999; font-style: italic;">[Diagram ${escapeHtml(diagramAssetId)} not found]</span>`;
                            }
                        } else if (rightText) {
                            // Use formatted text
                            let processedRightText = escapeHtml(rightText);
                            if (rightTextFormatting) {
                                // Process bold: *text* -> <strong>text</strong>
                                processedRightText = processedRightText.replace(/\*([^*]+?)\*/g, '<strong>$1</strong>');
                                // Process italic: _text_ -> <em>text</em>
                                processedRightText = processedRightText.replace(/_([^_]+?)_/g, '<em>$1</em>');
                            }
                            rightSideHtml = `<div style="line-height: 1.6; color: #000;">${processedRightText}</div>`;
                        }
                        
                        // Create side-by-side layout using flexbox for this row
                        const marginTop = rowIndex > 0 ? '30px' : '20px';
                        contentHTML += `<div style="display: flex; flex-direction: row; gap: 20px; margin-top: ${marginTop}; margin-bottom: 20px; align-items: flex-start; flex-wrap: wrap;">
                            <div style="flex: 1 1 45%; min-width: 250px;">
                                <div style="line-height: 1.6; color: #000;">${processedExplanation}</div>
                            </div>
                            <div style="flex: 1 1 45%; min-width: 250px;">
                                ${rightSideHtml || '<span style="color: #999; font-style: italic;">[No content]</span>'}
                            </div>
                        </div>`;
                    });
                }
            });
            
            contentHTML += '</div>';
            
            document.getElementById('passageContent').innerHTML = contentHTML;
            
            // Show submit section for lessons (questions are inline but can be answered)
            document.getElementById('questionsContainer').innerHTML = '';
            
            // Check if there are questions on the CURRENT page (not just anywhere in the lesson)
            let hasQuestionsOnCurrentPage = false;
            if (lesson.questions && lesson.questions.length > 0 && pages && pages.length > 0 && pageIndex >= 0 && pageIndex < pages.length) {
                const currentPage = pages[pageIndex];
                const currentPageChunkIndices = new Set();
                currentPage.forEach(({chunkIdx}) => {
                    currentPageChunkIndices.add(chunkIdx);
                });
                
                // Check if any question's chunk_index is on the current page
                hasQuestionsOnCurrentPage = lesson.questions.some(q => 
                    q.chunk_index !== undefined && currentPageChunkIndices.has(q.chunk_index)
                );
            }
            
            if (hasQuestionsOnCurrentPage) {
                document.getElementById('submitSection').style.display = 'block';
            } else {
                document.getElementById('submitSection').style.display = 'none';
            }
            document.getElementById('resultsSection').style.display = 'none';
            
            // Update lesson's current page index
            lesson.currentPageIndex = pageIndex;
        }
        
        function navigateLessonPage(newPageIndex) {
            if (!currentLessonData) {
                console.error('No lesson data available');
                return;
            }
            
            const pages = currentLessonData.pages || [];
            if (newPageIndex < 0 || newPageIndex >= pages.length) {
                console.error('Invalid page index:', newPageIndex);
                return;
            }
            
            // Rebuild question maps (needed for rendering)
            const questionAssetsMap = {};
            const questionMap = {};
            if (currentLessonData.questions) {
                currentLessonData.questions.forEach(question => {
                    questionMap[question.chunk_index] = question;
                    if (question.assets && question.assets.length > 0) {
                        questionAssetsMap[question.chunk_index] = question.assets;
                    }
                });
            }
            
            // Render the new page
            renderLessonPage(currentLessonData, newPageIndex, questionAssetsMap, questionMap);
            
            // Scroll to top of content
            document.getElementById('passageContent').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        function displayLessonPreview(lesson, type) {
            // Hide all list sections, show detail view
            document.getElementById('passagesListSection').style.display = 'none';
            document.getElementById('lessonsListSection').style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // document.getElementById('writingSectionsListSection').style.display = 'none';
            document.getElementById('passageDetailSection').style.display = 'block';
            
            // Hide word of the day when viewing lesson previews
            const wordOfDay = document.getElementById('wordOfDay');
            if (wordOfDay) wordOfDay.style.display = 'none';
            
            // Get first few chunks for preview
            const previewChunks = lesson.chunks ? lesson.chunks.slice(0, 3) : [];
            let contentHTML = `<h2 style="color: #3498DB; margin-bottom: 15px;">${escapeHtml(lesson.title)} <span class="premium-badge">PREMIUM</span> <span class="premium-lock">üîí</span></h2>`;
            contentHTML += '<div class="lesson-content premium-preview-overlay" style="max-width: 800px; margin: 0 auto;">';
            
            previewChunks.forEach((chunk, chunkIdx) => {
                if (chunk.type === 'header') {
                    contentHTML += `<h${chunk.level || 1} style="color: #000; margin-top: 20px; margin-bottom: 10px;">${escapeHtml(chunk.text)}</h${chunk.level || 1}>`;
                } else if (chunk.type === 'paragraph') {
                    contentHTML += `<p style="margin-bottom: 15px; color: #000; line-height: 1.6;">${escapeHtml(chunk.text)}</p>`;
                }
            });
            
            contentHTML += '</div>';
            
            // Add upgrade prompt
            contentHTML += `
                <div class="premium-upgrade-prompt">
                    <h3>üîí Premium Content</h3>
                    <p>This lesson is part of our premium collection. Upgrade to unlock full access to all lessons, passages, and writing sections.</p>
                    ${authToken ? 
                        `<button class="btn" onclick="upgradeToPremium()">Upgrade to Premium - $5/month</button>` :
                        `<button class="btn" onclick="showRegisterModal()">Sign Up to Upgrade</button>`
                    }
                </div>
            `;
            
            document.getElementById('passageContent').innerHTML = contentHTML;
            document.getElementById('questionsContainer').innerHTML = '';
            document.getElementById('submitSection').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'none';
        }
        
        function displayPassagePreview(passage) {
            // Hide passages list, show passage detail
            document.getElementById('passagesListSection').style.display = 'none';
            document.getElementById('lessonsListSection').style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // document.getElementById('writingSectionsListSection').style.display = 'none';
            document.getElementById('passageDetailSection').style.display = 'block';
            
            // Show first ~500 characters with gradient fade
            const previewLength = 500;
            const previewContent = passage.content ? passage.content.substring(0, previewLength) + '...' : '';
            const formattedContent = formatPassageForSAT(previewContent);
            
            document.getElementById('passageContent').innerHTML = `
                <h2 style="color: #3498DB; margin-bottom: 15px;">${escapeHtml(passage.title)} <span class="premium-badge">PREMIUM</span> <span class="premium-lock">üîí</span></h2>
                <div class="passage-content-sat premium-preview-overlay">${formattedContent}</div>
            `;
            
            // Add upgrade prompt
            const upgradeHTML = `
                <div class="premium-upgrade-prompt">
                    <h3>üîí Premium Content</h3>
                    <p>This passage is part of our premium collection. Upgrade to unlock full access to all passages, lessons, and writing sections.</p>
                    ${authToken ? 
                        `<button class="btn" onclick="upgradeToPremium()">Upgrade to Premium - $5/month</button>` :
                        `<button class="btn" onclick="showRegisterModal()">Sign Up to Upgrade</button>`
                    }
                </div>
            `;
            document.getElementById('passageContent').innerHTML += upgradeHTML;
            
            // Hide questions and submit
            document.getElementById('questionsContainer').innerHTML = '';
            document.getElementById('submitSection').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'none';
        }
        
        function displayWritingSectionPreview(writingSection) {
            // Hide all list sections, show detail view
            document.getElementById('passagesListSection').style.display = 'none';
            document.getElementById('lessonsListSection').style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // document.getElementById('writingSectionsListSection').style.display = 'none';
            document.getElementById('mathSectionsListSection').style.display = 'none';
            document.getElementById('passageDetailSection').style.display = 'block';
            
            // Show first ~500 characters with gradient fade
            const previewLength = 500;
            const previewContent = writingSection.content ? writingSection.content.substring(0, previewLength) + '...' : '';
            const formattedContent = formatWritingSectionContent(previewContent, writingSection.selections || []);
            
            document.getElementById('passageContent').innerHTML = `
                <h2 style="color: #3498DB; margin-bottom: 15px;">${escapeHtml(writingSection.title)} <span class="premium-badge">PREMIUM</span> <span class="premium-lock">üîí</span></h2>
                <div class="premium-preview-overlay">${formattedContent}</div>
            `;
            
            // Add upgrade prompt
            const upgradeHTML = `
                <div class="premium-upgrade-prompt">
                    <h3>üîí Premium Content</h3>
                    <p>This writing section is part of our premium collection. Upgrade to unlock full access to all writing sections, passages, and lessons.</p>
                    ${authToken ? 
                        `<button class="btn" onclick="upgradeToPremium()">Upgrade to Premium - $5/month</button>` :
                        `<button class="btn" onclick="showRegisterModal()">Sign Up to Upgrade</button>`
                    }
                </div>
            `;
            document.getElementById('passageContent').innerHTML += upgradeHTML;
            
            // Hide questions and submit
            document.getElementById('questionsContainer').innerHTML = '';
            document.getElementById('submitSection').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'none';
        }
        
        let isOpeningPassage = false; // Flag to prevent hashchange loop
        let isOpeningMathSection = false; // Flag to prevent hashchange loop for math sections
        
        async function openPassage(passageId) {
            console.log('openPassage called with ID:', passageId);
            // Prevent re-triggering if already opening this passage
            if (isOpeningPassage && currentPassageId === passageId) {
                console.log('Already opening this passage, skipping');
                return;
            }
            
            try {
                console.log('Opening passage:', passageId);
                isOpeningPassage = true;
                currentPassageId = passageId;
                // Clear other detail view states
                currentLessonId = null;
                currentLessonData = null;
                currentMathSectionId = null;
                currentMathSectionData = null;
                currentWritingSectionId = null;
                currentWritingSectionData = null;
                userAnswers = {};
                
                // Update URL hash (replaceState doesn't trigger hashchange, which is what we want)
                window.history.replaceState(null, '', window.location.pathname + `#passage/${passageId}`);
                
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                // Fetch passage detail with content
                const passageResponse = await fetch(`${API_BASE}/passages/${passageId}`, {headers});
                if (passageResponse.status === 403) {
                    // Try to get passage data anyway for preview
                    const previewResponse = await fetch(`${API_BASE}/passages/${passageId}`, {});
                    if (previewResponse.ok) {
                        const passageData = await previewResponse.json();
                        displayPassagePreview(passageData);
                    } else {
                        // Show upgrade modal instead of alert
                        showUpgradeModal('passage');
                    }
                    isOpeningPassage = false;
                    return;
                }
                
                if (!passageResponse.ok) {
                    alert('Failed to load passage. Please try again.');
                    isOpeningPassage = false;
                    return;
                }
                
                const passageData = await passageResponse.json();
                currentPassageData = passageData;
                
                // Fetch questions (without answers)
                const questionsResponse = await fetch(`${API_BASE}/passages/${passageId}/questions`, {headers});
                if (!questionsResponse.ok) {
                    alert('Failed to load questions. Please try again.');
                    isOpeningPassage = false;
                    return;
                }
                
                const questionsData = await questionsResponse.json();
                
                // Display passage
                console.log('About to display passage:', passageData.title);
                displayPassage(passageData, questionsData);
                console.log('Passage displayed successfully');
                
            } catch (error) {
                console.error('Failed to open passage:', error);
                console.error('Error stack:', error.stack);
                alert('Network error. Please try again.');
            } finally {
                isOpeningPassage = false;
            }
        }
        
        // Make openPassage globally accessible
        window.openPassage = openPassage;
        
        function formatPassageForSAT(content) {
            // First, normalize content: convert literal \n strings to actual newlines
            if (typeof content === 'string') {
                // Handle literal \n strings (both \\n and \n)
                content = content.replace(/\\\\n/g, '\n');
                content = content.replace(/\\n/g, '\n');
            }
            
            // Split content into paragraphs (double newlines separate paragraphs)
            // Preserve original line breaks but wrap to 50 characters
            const allLines = [];
            const paragraphs = content.split(/\n\n+/);
            
            paragraphs.forEach((paragraph, paraIndex) => {
                // Split paragraph by single newlines to preserve line breaks
                const originalLines = paragraph.split(/\n/);
                
                originalLines.forEach(originalLine => {
                    const trimmed = originalLine.trim();
                    
                    if (!trimmed) {
                        // Empty line - preserve it as blank line
                        allLines.push('');
                        return;
                    }
                    
                    // Wrap this line to 50 characters
                    const words = trimmed.split(/\s+/);
                    let currentLine = '';
                    
                    words.forEach(word => {
                        const testLine = currentLine ? currentLine + ' ' + word : word;
                        if (testLine.length <= 50) {
                            currentLine = testLine;
                        } else {
                            // Save current line and start new one
                            if (currentLine) {
                                allLines.push(currentLine);
                            }
                            // If word itself is longer than 50 chars, split it
                            if (word.length > 50) {
                                let remaining = word;
                                while (remaining.length > 50) {
                                    allLines.push(remaining.substring(0, 50));
                                    remaining = remaining.substring(50);
                                }
                                currentLine = remaining;
                            } else {
                                currentLine = word;
                            }
                        }
                    });
                    
                    // Add remaining line
                    if (currentLine) {
                        allLines.push(currentLine);
                    }
                });
                
                // Add blank line between paragraphs (but not after last paragraph)
                if (paraIndex < paragraphs.length - 1) {
                    allLines.push('');
                }
            });
            
            // Calculate line numbers: skip blank lines in numbering
            let lineNumber = 0; // This counts only non-blank lines
            const linesWithNumbers = allLines.map(line => {
                const isBlank = !line || line.trim() === '';
                if (!isBlank) {
                    lineNumber++;
                }
                return {
                    text: line,
                    isBlank: isBlank,
                    lineNumber: isBlank ? null : lineNumber
                };
            });
            
            // Format lines with line numbers every 5 lines (5, 10, 15, 20, etc.)
            // But only show numbers on non-blank lines
            let formattedHTML = '<div class="passage-columns">';
            const linesPerColumn = Math.ceil(linesWithNumbers.length / 2);
            
            // Create two columns
            for (let col = 0; col < 2; col++) {
                formattedHTML += '<div class="passage-column">';
                const startLine = col * linesPerColumn;
                const endLine = Math.min(startLine + linesPerColumn, linesWithNumbers.length);
                
                for (let i = startLine; i < endLine; i++) {
                    const lineData = linesWithNumbers[i];
                    const line = lineData.text;
                    const lineNum = lineData.lineNumber;
                    
                    // Show line number every 5 lines (5, 10, 15, 20, etc.) but only on non-blank lines
                    const shouldShowNumber = lineNum !== null && lineNum % 5 === 0;
                    
                    if (shouldShowNumber) {
                        formattedHTML += `<div class="passage-line-numbered">`;
                        formattedHTML += `<span class="line-number">${lineNum}</span>`;
                        formattedHTML += `<span class="line-text">${escapeHtml(line || ' ')}</span>`;
                        formattedHTML += `</div>`;
                    } else {
                        // Still use numbered format for alignment, but with empty number
                        formattedHTML += `<div class="passage-line-numbered">`;
                        formattedHTML += `<span class="line-number"></span>`;
                        formattedHTML += `<span class="line-text">${escapeHtml(line || ' ')}</span>`;
                        formattedHTML += `</div>`;
                    }
                }
                
                formattedHTML += '</div>';
            }
            
            formattedHTML += '</div>';
            return formattedHTML;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        /**
         * Replace sentinel markers like [[Diagram asset_id]] with image tags
         * @param {string} text - The text containing sentinels
         * @param {Array} assets - Array of asset objects with asset_id and s3_url
         * @param {string} lessonId - Lesson ID for constructing URLs if needed
         * @returns {string} - HTML with sentinels replaced by images
         */
        function replaceUnderlineSentinels(text) {
            if (!text) return text;
            // Replace *text* with <u>text</u> for underlines
            // Use non-greedy matching to handle multiple underlines in the same text
            // Match *word* but not **bold** (which uses double asterisks)
            // Pattern: *text* where text doesn't contain asterisks
            return text.replace(/\*([^*]+?)\*/g, '<u>$1</u>');
        }
        
        function replaceBoldItalicSentinels(text) {
            if (!text) return text;
            // Replace **text** with <strong>text</strong> for bold
            // Replace _text_ with <em>text</em> for italic
            // Process bold first, then italic
            text = text.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
            text = text.replace(/_([^_]+?)_/g, '<em>$1</em>');
            return text;
        }
        
        function formatLessonPrompt(promptBlocks, lessonAssets, lessonId) {
            // Format lesson question prompt blocks (similar to formatMathPrompt)
            if (!promptBlocks || !Array.isArray(promptBlocks)) {
                return '';
            }
            
            const result = [];
            
            for (let i = 0; i < promptBlocks.length; i++) {
                const block = promptBlocks[i];
                let part = '';
                
                if (typeof block === 'string') {
                    part = block;
                } else if (block && typeof block === 'object') {
                    if (block.type === 'paragraph') {
                        let processedText = block.text || '';
                        processedText = replaceDiagramSentinels(processedText, lessonAssets || [], lessonId);
                        processedText = replaceUnderlineSentinels(processedText);
                        processedText = replaceBoldItalicSentinels(processedText);
                        part = `<p style="margin-bottom: 15px; line-height: 1.6; color: #000;">${processedText}</p>`;
                    } else if (block.type === 'side_by_side') {
                        // Handle side-by-side blocks
                        let rows = [];
                        if (block.rows && Array.isArray(block.rows)) {
                            rows = block.rows;
                        } else if (block.explanation !== undefined || block.diagram_asset_id !== undefined) {
                            rows = [{
                                explanation: block.explanation || '',
                                diagram_asset_id: block.diagram_asset_id || ''
                            }];
                        }
                        
                        const rowsHtml = rows.map((row, rowIndex) => {
                            let processedExplanation = row.explanation || '';
                            processedExplanation = replaceUnderlineSentinels(processedExplanation);
                            processedExplanation = replaceBoldItalicSentinels(processedExplanation);
                            
                            let rightSideHtml = '';
                            if (row.diagram_asset_id) {
                                const asset = lessonAssets.find(a => a.asset_id === row.diagram_asset_id);
                                let imageUrl = '';
                                
                                if (asset && asset.s3_url) {
                                    imageUrl = asset.s3_url;
                                } else if (row.diagram_asset_id && lessonId) {
                                    imageUrl = `https://keuvi.s3.amazonaws.com/lessons/${lessonId}/${row.diagram_asset_id}.png`;
                                }
                                
                                if (imageUrl) {
                                    rightSideHtml = `<img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(row.diagram_asset_id)}" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px;" onerror="this.style.display='none'; console.error('Failed to load diagram:', '${row.diagram_asset_id}');">`;
                                } else {
                                    rightSideHtml = `<span style="color: #999; font-style: italic;">[Diagram ${escapeHtml(row.diagram_asset_id)} not found]</span>`;
                                }
                            } else if (row.right_text) {
                                let processedText = row.right_text || '';
                                processedText = replaceUnderlineSentinels(processedText);
                                processedText = replaceBoldItalicSentinels(processedText);
                                rightSideHtml = `<div style="line-height: 1.6; color: #000;">${processedText}</div>`;
                            } else {
                                rightSideHtml = '<span style="color: #999; font-style: italic;">[No content]</span>';
                            }
                            
                            const marginTop = rowIndex > 0 ? '30px' : '20px';
                            return `<div style="display: flex; flex-direction: row; gap: 20px; margin-top: ${marginTop}; margin-bottom: 20px; align-items: flex-start; flex-wrap: wrap;">
                                <div style="flex: 1 1 45%; min-width: 250px;">
                                    <div style="line-height: 1.6; color: #000;">${processedExplanation}</div>
                                </div>
                                <div style="flex: 1 1 45%; min-width: 250px;">
                                    ${rightSideHtml}
                                </div>
                            </div>`;
                        }).join('');
                        
                        part = rowsHtml;
                    } else if (block.text) {
                        // Fallback
                        part = block.text;
                    }
                }
                
                if (part && part.trim().length > 0) {
                    if (block && block.type === 'side_by_side') {
                        if (result.length > 0) {
                            result.push('<div style="margin-top: 20px;"></div>' + part);
                        } else {
                            result.push(part);
                        }
                    } else {
                        result.push(part);
                    }
                }
            }
            
            return result.join('');
        }
        
        function formatMathPrompt(promptBlocks, mathAssets, mathSectionId) {
            // Format math question prompt blocks (similar to formatMathExplanation)
            if (!promptBlocks || !Array.isArray(promptBlocks)) {
                return '';
            }
            
            const result = [];
            
            for (let i = 0; i < promptBlocks.length; i++) {
                const block = promptBlocks[i];
                let part = '';
                
                if (typeof block === 'string') {
                    part = block;
                } else if (block && typeof block === 'object') {
                    if (block.type === 'paragraph') {
                        let processedText = block.text || '';
                        processedText = replaceDiagramSentinels(processedText, mathAssets, mathSectionId);
                        processedText = replaceUnderlineSentinels(processedText);
                        processedText = replaceBoldItalicSentinels(processedText);
                        part = `<p style="margin-bottom: 15px; line-height: 1.6; color: #000;">${processedText}</p>`;
                    } else if (block.type === 'side_by_side') {
                        // Handle side-by-side blocks
                        let rows = [];
                        if (block.rows && Array.isArray(block.rows)) {
                            rows = block.rows;
                        } else if (block.explanation !== undefined || block.diagram_asset_id !== undefined) {
                            rows = [{
                                explanation: block.explanation || '',
                                diagram_asset_id: block.diagram_asset_id || ''
                            }];
                        }
                        
                        const rowsHtml = rows.map((row, rowIndex) => {
                            let processedExplanation = row.explanation || '';
                            processedExplanation = replaceUnderlineSentinels(processedExplanation);
                            processedExplanation = replaceBoldItalicSentinels(processedExplanation);
                            
                            let rightSideHtml = '';
                            if (row.diagram_asset_id) {
                                const asset = mathAssets.find(a => a.asset_id === row.diagram_asset_id);
                                let imageUrl = '';
                                
                                if (asset && asset.s3_url) {
                                    imageUrl = asset.s3_url;
                                } else if (row.diagram_asset_id && mathSectionId) {
                                    imageUrl = `https://keuvi.s3.amazonaws.com/math-sections/${mathSectionId}/${row.diagram_asset_id}.png`;
                                }
                                
                                if (imageUrl) {
                                    rightSideHtml = `<img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(row.diagram_asset_id)}" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px;" onerror="this.style.display='none'; console.error('Failed to load diagram:', '${row.diagram_asset_id}');">`;
                                } else {
                                    rightSideHtml = `<span style="color: #999; font-style: italic;">[Diagram ${escapeHtml(row.diagram_asset_id)} not found]</span>`;
                                }
                            } else if (row.right_text) {
                                let processedText = row.right_text || '';
                                processedText = replaceUnderlineSentinels(processedText);
                                processedText = replaceBoldItalicSentinels(processedText);
                                rightSideHtml = `<div style="line-height: 1.6; color: #000;">${processedText}</div>`;
                            } else {
                                rightSideHtml = '<span style="color: #999; font-style: italic;">[No content]</span>';
                            }
                            
                            const marginTop = rowIndex > 0 ? '30px' : '20px';
                            return `<div style="display: flex; flex-direction: row; gap: 20px; margin-top: ${marginTop}; margin-bottom: 20px; align-items: flex-start; flex-wrap: wrap;">
                                <div style="flex: 1 1 45%; min-width: 250px;">
                                    <div style="line-height: 1.6; color: #000;">${processedExplanation}</div>
                                </div>
                                <div style="flex: 1 1 45%; min-width: 250px;">
                                    ${rightSideHtml}
                                </div>
                            </div>`;
                        }).join('');
                        
                        part = rowsHtml;
                    } else if (block.text) {
                        // Fallback
                        part = block.text;
                    }
                }
                
                if (part && part.trim().length > 0) {
                    if (block && block.type === 'side_by_side') {
                        if (result.length > 0) {
                            result.push('<div style="margin-top: 20px;"></div>' + part);
                        } else {
                            result.push(part);
                        }
                    } else {
                        result.push(part);
                    }
                }
            }
            
            return result.join('');
        }
        
        function formatMathExplanation(explanation, isMathSection = false) {
            // Handle null/undefined
            if (!explanation) {
                return '';
            }
            
            // If it's a JSON string, parse it first
            if (typeof explanation === 'string') {
                try {
                    // Try to parse as JSON
                    const parsed = JSON.parse(explanation);
                    explanation = parsed;
                } catch (e) {
                    // Not JSON, return as-is
                    return explanation;
                }
            }
            
            // Math questions have explanation as an array of objects
            // Always check if it's an array first (math sections use arrays)
            if (Array.isArray(explanation)) {
                const result = [];
                
                for (let i = 0; i < explanation.length; i++) {
                    const block = explanation[i];
                    let part = '';
                    
                    if (typeof block === 'string') {
                        part = block;
                    } else if (block && typeof block === 'object') {
                        if (block.type === 'paragraph' || block.type === 'note' || block.type === 'example') {
                            part = block.text || '';
                        } else if (block.type === 'equation') {
                            // Convert LaTeX to plain text for display
                            if (block.latex) {
                                let equationText = block.latex;
                                // Remove LaTeX commands and convert to readable text
                                // Common LaTeX to text conversions
                                equationText = equationText.replace(/\\angle\s*/g, '‚à†');
                                equationText = equationText.replace(/\\degree/g, '¬∞');
                                equationText = equationText.replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '($1)/($2)');
                                equationText = equationText.replace(/\\sqrt\{([^}]+)\}/g, '‚àö($1)');
                                equationText = equationText.replace(/\\times/g, '√ó');
                                equationText = equationText.replace(/\\div/g, '√∑');
                                equationText = equationText.replace(/\\pm/g, '¬±');
                                equationText = equationText.replace(/\\leq/g, '‚â§');
                                equationText = equationText.replace(/\\geq/g, '‚â•');
                                equationText = equationText.replace(/\\neq/g, '‚â†');
                                equationText = equationText.replace(/\\approx/g, '‚âà');
                                equationText = equationText.replace(/\\pi/g, 'œÄ');
                                equationText = equationText.replace(/\\theta/g, 'Œ∏');
                                equationText = equationText.replace(/\\text\{([^}]+)\}/g, '$1');
                                equationText = equationText.replace(/\\alpha/g, 'Œ±');
                                equationText = equationText.replace(/\\beta/g, 'Œ≤');
                                equationText = equationText.replace(/\\gamma/g, 'Œ≥');
                                equationText = equationText.replace(/\\Delta/g, 'Œî');
                                equationText = equationText.replace(/\\sum/g, 'Œ£');
                                equationText = equationText.replace(/\\int/g, '‚à´');
                                // Remove remaining LaTeX braces
                                equationText = equationText.replace(/\{([^}]+)\}/g, '$1');
                                // Remove backslashes before single characters (common LaTeX commands)
                                equationText = equationText.replace(/\\([a-zA-Z])/g, '$1');
                                // Clean up extra spaces
                                equationText = equationText.replace(/\s+/g, ' ').trim();
                                part = equationText;
                            }
                        } else if (block.type === 'side_by_side') {
                            // Handle side-by-side blocks - render as HTML
                            let rows = [];
                            if (block.rows && Array.isArray(block.rows)) {
                                rows = block.rows;
                            } else if (block.explanation !== undefined || block.diagram_asset_id !== undefined) {
                                // Legacy format: convert to rows array
                                rows = [{
                                    explanation: block.explanation || '',
                                    diagram_asset_id: block.diagram_asset_id || ''
                                }];
                            }
                            
                            // Render each row
                            const rowsHtml = rows.map((row, rowIndex) => {
                                let processedExplanation = row.explanation || '';
                                // Process sentinels in explanation
                                processedExplanation = replaceUnderlineSentinels(processedExplanation);
                                processedExplanation = replaceBoldItalicSentinels(processedExplanation);
                                
                                let rightSideHtml = '';
                                if (row.diagram_asset_id) {
                                    // Get math section assets from currentMathSectionData
                                    const mathAssets = currentMathSectionData?.assets || [];
                                    const mathSectionId = currentMathSectionData?.section_id || currentMathSectionData?.id || '';
                                    
                                    // Find the asset in the assets array
                                    const asset = mathAssets.find(a => a.asset_id === row.diagram_asset_id);
                                    let imageUrl = '';
                                    
                                    if (asset && asset.s3_url) {
                                        imageUrl = asset.s3_url;
                                    } else if (row.diagram_asset_id && mathSectionId) {
                                        // Fallback: construct URL
                                        imageUrl = `https://keuvi.s3.amazonaws.com/math-sections/${mathSectionId}/${row.diagram_asset_id}.png`;
                                    }
                                    
                                    if (imageUrl) {
                                        rightSideHtml = `<img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(row.diagram_asset_id)}" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px;" onerror="this.style.display='none'; console.error('Failed to load diagram:', '${row.diagram_asset_id}');">`;
                                    } else {
                                        rightSideHtml = `<span style="color: #999; font-style: italic;">[Diagram ${escapeHtml(row.diagram_asset_id)} not found]</span>`;
                                    }
                                } else if (row.right_text) {
                                    let processedText = row.right_text || '';
                                    processedText = replaceUnderlineSentinels(processedText);
                                    processedText = replaceBoldItalicSentinels(processedText);
                                    rightSideHtml = `<div style="line-height: 1.6; color: #000;">${processedText}</div>`;
                                } else {
                                    rightSideHtml = '<span style="color: #999; font-style: italic;">[No content]</span>';
                                }
                                
                                const marginTop = rowIndex > 0 ? '30px' : '20px';
                                return `<div style="display: flex; flex-direction: row; gap: 20px; margin-top: ${marginTop}; margin-bottom: 20px; align-items: flex-start; flex-wrap: wrap;">
                                    <div style="flex: 1 1 45%; min-width: 250px;">
                                        <div style="line-height: 1.6; color: #000;">${processedExplanation}</div>
                                    </div>
                                    <div style="flex: 1 1 45%; min-width: 250px;">
                                        ${rightSideHtml}
                                    </div>
                                </div>`;
                            }).join('');
                            
                            part = rowsHtml;
                        } else if (block.text) {
                            // Fallback: try to get text property if it exists
                            part = block.text;
                        }
                    }
                    
                    // Only add non-empty parts
                    if (part && part.trim().length > 0) {
                        // If this block is an equation and not the first item, add line break before it
                        if (block && block.type === 'equation' && result.length > 0) {
                            result.push('<br><br>' + part); // Add double line break for equations
                        } else if (block && block.type === 'side_by_side') {
                            // Side-by-side blocks are already HTML, just add spacing
                            if (result.length > 0) {
                                result.push('<div style="margin-top: 20px;"></div>' + part);
                            } else {
                                result.push(part);
                            }
                        } else if (result.length > 0) {
                            // Add space between paragraphs
                            result.push(' ' + part);
                        } else {
                            result.push(part);
                        }
                    }
                }
                
                // Join without additional spaces (we already added them above)
                return result.length > 0 ? result.join('') : '';
            }
            
            // If it's an object but not an array, try to extract text
            if (explanation && typeof explanation === 'object') {
                // Try common properties
                if (explanation.text) {
                    return String(explanation.text);
                }
                if (explanation.content) {
                    return String(explanation.content);
                }
                // If it has a type and text, treat it as a single block
                if (explanation.type === 'paragraph' || explanation.type === 'note' || explanation.type === 'example') {
                    return String(explanation.text || '');
                }
                if (explanation.type === 'equation') {
                    // Convert LaTeX to plain text for display
                    if (explanation.latex) {
                        let equationText = explanation.latex;
                        // Remove LaTeX commands and convert to readable text
                        equationText = equationText.replace(/\\angle\s*/g, '‚à†');
                        equationText = equationText.replace(/\\degree/g, '¬∞');
                        equationText = equationText.replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '($1)/($2)');
                        equationText = equationText.replace(/\\sqrt\{([^}]+)\}/g, '‚àö($1)');
                        equationText = equationText.replace(/\\times/g, '√ó');
                        equationText = equationText.replace(/\\div/g, '√∑');
                        equationText = equationText.replace(/\\pm/g, '¬±');
                        equationText = equationText.replace(/\\leq/g, '‚â§');
                        equationText = equationText.replace(/\\geq/g, '‚â•');
                        equationText = equationText.replace(/\\neq/g, '‚â†');
                        equationText = equationText.replace(/\\approx/g, '‚âà');
                        equationText = equationText.replace(/\\pi/g, 'œÄ');
                        equationText = equationText.replace(/\\theta/g, 'Œ∏');
                        equationText = equationText.replace(/\\alpha/g, 'Œ±');
                        equationText = equationText.replace(/\\beta/g, 'Œ≤');
                        equationText = equationText.replace(/\\gamma/g, 'Œ≥');
                        equationText = equationText.replace(/\\Delta/g, 'Œî');
                        equationText = equationText.replace(/\\sum/g, 'Œ£');
                        equationText = equationText.replace(/\\int/g, '‚à´');
                        // Remove remaining LaTeX braces
                        equationText = equationText.replace(/\{([^}]+)\}/g, '$1');
                        // Remove backslashes before single characters
                        equationText = equationText.replace(/\\([a-zA-Z])/g, '$1');
                        // Clean up extra spaces
                        equationText = equationText.replace(/\s+/g, ' ').trim();
                        return equationText;
                    }
                    return '';
                }
            }
            
            // Final fallback - convert to string
            return String(explanation || '');
        }
        
        function replaceDiagramSentinels(text, assets, lessonId) {
            if (!text) {
                console.log('replaceDiagramSentinels: No text provided');
                return text;
            }
            if (!assets || !Array.isArray(assets) || assets.length === 0) {
                console.log('replaceDiagramSentinels: No assets provided', {assets, lessonId});
                return text;
            }
            
            // Only log if text actually contains the marker (reduce noise)
            if (!text.includes('[[Diagram') && !text.includes('[[diagram') && !text.includes('[[DIAGRAM')) {
                return text; // Early return if no sentinel
            }
            
            console.log('üîç replaceDiagramSentinels called with sentinel in text');
            
            // Check if text contains the sentinel pattern (case-insensitive check first)
            const hasDiagramMarker = text.includes('[[Diagram') || text.includes('[[diagram') || text.includes('[[DIAGRAM');
            
            if (hasDiagramMarker) {
                console.log('Text contains [[Diagram marker. Full text:', text);
                console.log('Text length:', text.length);
                // Show character codes around the marker to check for encoding issues
                const markerIndex = text.indexOf('[[Diagram');
                if (markerIndex >= 0) {
                    const snippet = text.substring(Math.max(0, markerIndex - 20), Math.min(text.length, markerIndex + 50));
                    console.log('Snippet around marker:', snippet);
                    console.log('Character codes:', Array.from(snippet).map(c => c.charCodeAt(0)));
                }
            }
            
            // Pattern to match [[Diagram asset_id]] - be more flexible
            // Match: [[Diagram asset_id]] with optional whitespace (use \s* instead of \s+)
            // Use non-greedy match and allow for various whitespace scenarios
            let sentinelPattern = /\[\[Diagram\s*([^\]]+?)\s*\]\]/gi;
            
            const matches = text.match(sentinelPattern);
            if (matches) {
                console.log('‚úÖ Found sentinel matches:', matches);
            } else if (hasDiagramMarker) {
                console.log('‚ùå Text contains [[Diagram but pattern did not match!');
                console.log('Full text for debugging:', JSON.stringify(text));
                
                // Try alternative patterns - use the most permissive one that works
                console.log('Trying alternative patterns...');
                
                // Pattern 1: Without requiring space after Diagram
                const altPattern1 = /\[\[Diagram([^\]]+)\]\]/gi;
                const altMatches1 = text.match(altPattern1);
                if (altMatches1) {
                    console.log('‚úÖ Alternative pattern 1 (no space required) matched:', altMatches1);
                    sentinelPattern = altPattern1;
                } else {
                    // Pattern 2: More permissive - any characters between Diagram and ]]
                    const altPattern2 = /\[\[Diagram\s*([^\]]+?)\s*\]\]/gi;
                    const altMatches2 = text.match(altPattern2);
                    if (altMatches2) {
                        console.log('‚úÖ Alternative pattern 2 (flexible whitespace) matched:', altMatches2);
                        sentinelPattern = altPattern2;
                    } else {
                        // Pattern 3: Very permissive - match anything between [[Diagram and ]]
                        const altPattern3 = /\[\[Diagram\s*([^\]]+)\]\]/gi;
                        const altMatches3 = text.match(altPattern3);
                        if (altMatches3) {
                            console.log('‚úÖ Alternative pattern 3 (very permissive) matched:', altMatches3);
                            sentinelPattern = altPattern3;
                        }
                    }
                }
            }
            
            return text.replace(sentinelPattern, (match, assetId) => {
                // Trim whitespace from asset_id
                assetId = assetId.trim();
                console.log(`Processing sentinel: "${match}" with asset_id: "${assetId}"`);
                
                // Find the asset by asset_id
                const asset = assets.find(a => a.asset_id === assetId);
                console.log(`Found asset for "${assetId}":`, asset);
                
                if (asset && asset.s3_url) {
                    // Use the S3 URL from the asset
                    let imageUrl = asset.s3_url;
                    
                    // Clean up malformed URLs
                    imageUrl = imageUrl.trim().replace(/[: ]+$/, '');
                    
                    // Fix malformed URLs - check if URL contains math-sections or lessons
                    if (imageUrl.endsWith('/') || imageUrl.match(/lessons\/[^/]+:$/) || imageUrl.match(/math-sections\/[^/]+:$/)) {
                        // Determine if this is a math section or lesson based on the asset's S3 URL
                        // Math sections now use lessons/ directly (same as lessons) to work with bucket policy
                        // Check for old math-sections/ paths for backwards compatibility
                        const isOldMathSectionPath = imageUrl.includes('math-sections/') && !imageUrl.includes('lessons/');
                        if (isOldMathSectionPath) {
                            // Old path - update to new format
                            imageUrl = `https://keuvi.s3.amazonaws.com/lessons/${lessonId || 'unknown'}/${assetId}.png`;
                        } else {
                            // Use lessons/ prefix (works for both lessons and math sections)
                            imageUrl = `https://keuvi.s3.amazonaws.com/lessons/${lessonId || 'unknown'}/${assetId}.png`;
                        }
                    }
                    
                    // Ensure URL has proper extension
                    if (!/\.(png|jpg|jpeg|gif|svg|webp)$/i.test(imageUrl)) {
                        if (!imageUrl.includes('.')) {
                            imageUrl += '.png';
                        }
                    }
                    
                    console.log(`Using image URL: ${imageUrl}`);
                    // Return image tag - centered horizontally for paragraph chunks
                    return `<img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(assetId)}" style="max-width: 100%; height: auto; margin: 15px auto; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: block;" onerror="console.error('Failed to load diagram:', this.src); this.style.display='none';" />`;
                } else if (assetId && lessonId) {
                    // If asset not found but we have asset_id and lesson_id, construct URL
                    // Both lessons and math sections now use lessons/ prefix
                    const constructedUrl = `https://keuvi.s3.amazonaws.com/lessons/${lessonId}/${assetId}.png`;
                    console.log(`Constructing fallback URL: ${constructedUrl}`);
                    return `<img src="${escapeHtml(constructedUrl)}" alt="${escapeHtml(assetId)}" style="max-width: 100%; height: auto; margin: 15px auto; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: block;" onerror="console.error('Failed to load diagram:', this.src); this.style.display='none';" />`;
                } else {
                    // Asset not found, return placeholder
                    console.warn(`Diagram sentinel [[Diagram ${assetId}]] found but asset not found. Assets:`, assets);
                    return `<span style="color: #999; font-style: italic;">[Diagram ${escapeHtml(assetId)} not found]</span>`;
                }
            });
        }
        
        function formatWritingSectionContent(content, selections) {
            // First, normalize the content - remove all line breaks and normalize whitespace
            // Convert literal \n strings to actual newlines if needed
            if (typeof content === 'string') {
                content = content.replace(/\\\\n/g, '\n');
                content = content.replace(/\\n/g, '\n');
            }
            
            // Store original for position calculations
            const originalContent = content;
            
            // Normalize whitespace: convert all line breaks to spaces, collapse multiple spaces
            // But we need to map positions from original to normalized
            let normalizedContent = originalContent.replace(/\r\n/g, ' '); // Windows line breaks
            normalizedContent = normalizedContent.replace(/\n/g, ' '); // Unix line breaks
            normalizedContent = normalizedContent.replace(/\r/g, ' '); // Old Mac line breaks
            normalizedContent = normalizedContent.replace(/\s+/g, ' '); // Collapse multiple spaces/tabs/etc to single space
            normalizedContent = normalizedContent.trim();
            
            // Build a mapping from original positions to normalized positions
            // This is complex, so instead let's rebuild selections based on normalized content
            const sortedSelections = [...selections].sort((a, b) => a.start_char - b.start_char);
            
            // Recalculate selection positions in normalized content
            const normalizedSelections = sortedSelections.map(sel => {
                const selectedText = originalContent.substring(sel.start_char, sel.end_char).trim();
                // Find this text in the normalized content
                const pos = normalizedContent.indexOf(selectedText);
                if (pos !== -1) {
                    return {
                        ...sel,
                        start_char: pos,
                        end_char: pos + selectedText.length,
                        selected_text: selectedText
                    };
                }
                // Try case-insensitive
                const normalizedLower = normalizedContent.toLowerCase();
                const selectedLower = selectedText.toLowerCase();
                const posLower = normalizedLower.indexOf(selectedLower);
                if (posLower !== -1) {
                    const actualText = normalizedContent.substring(posLower, posLower + selectedText.length);
                    return {
                        ...sel,
                        start_char: posLower,
                        end_char: posLower + actualText.length,
                        selected_text: actualText
                    };
                }
                return sel; // Keep original if can't find
            });
            
            // Now use normalized content and adjusted selections
            content = normalizedContent;
            
            // Build the formatted content with selections
            let formattedHTML = '<div class="passage-content-sat" style="line-height: 1.8; font-size: 16px; max-width: 800px;">';
            let lastIndex = 0;
            let htmlParts = [];
            
            // Process each selection and insert underlined text
            normalizedSelections.forEach(selection => {
                // Add text before selection
                if (selection.start_char > lastIndex) {
                    const beforeText = content.substring(lastIndex, selection.start_char);
                    htmlParts.push(escapeHtml(beforeText));
                }
                
                // Add underlined selection with number
                const selectedText = content.substring(selection.start_char, selection.end_char);
                htmlParts.push(`<span style="text-decoration: underline; font-weight: 500; color: #000; background-color: #fffacd; padding: 2px 4px;">
                    [${selection.number}] <u>${escapeHtml(selectedText)}</u>
                </span>`);
                
                lastIndex = selection.end_char;
            });
            
            // Add remaining text after last selection
            if (lastIndex < content.length) {
                const afterText = content.substring(lastIndex);
                htmlParts.push(escapeHtml(afterText));
            }
            
            // Combine all parts
            let fullText = htmlParts.join('');
            
            // Wrap in paragraph tags for natural text flow
            formattedHTML += '<p style="margin-bottom: 12px; text-align: left; white-space: normal;">' + fullText + '</p>';
            
            formattedHTML += '</div>';
            return formattedHTML;
        }
        
        async function openWritingSection(writingSectionId) {
            try {
                currentWritingSectionId = writingSectionId;
                currentPassageId = null; // Clear passage data
                currentPassageData = null;
                currentLessonId = null;
                currentLessonData = null;
                userAnswers = {};
                
                // Update URL hash
                window.history.replaceState(null, '', window.location.pathname + `#writing-section/${writingSectionId}`);
                
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                // Fetch writing section detail
                const sectionResponse = await fetch(`${API_BASE}/writing-sections/${writingSectionId}`, {headers});
                if (sectionResponse.status === 403) {
                    // Try to get section data anyway for preview
                    const previewResponse = await fetch(`${API_BASE}/writing-sections/${writingSectionId}`, {});
                    if (previewResponse.ok) {
                        const sectionData = await previewResponse.json();
                        displayWritingSectionPreview(sectionData);
                    } else {
                        // Show upgrade modal instead of alert
                        showUpgradeModal('writing section');
                    }
                    return;
                }
                
                if (!sectionResponse.ok) {
                    alert('Failed to load writing section. Please try again.');
                    return;
                }
                
                const sectionData = await sectionResponse.json();
                currentWritingSectionData = sectionData;
                
                // Check if writing section is premium and user doesn't have access
                if (sectionData.tier === 'premium' && (!currentUser || (!currentUser.is_premium && !currentUser.has_active_subscription))) {
                    displayWritingSectionPreview(sectionData);
                    return;
                }
                
                // Fetch questions (without answers)
                const questionsResponse = await fetch(`${API_BASE}/writing-sections/${writingSectionId}/questions`, {headers});
                if (!questionsResponse.ok) {
                    alert('Failed to load questions. Please try again.');
                    return;
                }
                
                const questionsData = await questionsResponse.json();
                
                // Display writing section
                displayWritingSection(sectionData, questionsData);
                
            } catch (error) {
                console.error('Failed to open writing section:', error);
                alert('Network error. Please try again.');
            }
        }
        
        async function openMathSection(mathSectionId) {
            // Prevent re-triggering if already opening this section
            if (isOpeningMathSection && currentMathSectionId === mathSectionId) {
                console.log('Already opening this math section, skipping');
                return;
            }
            
            try {
                isOpeningMathSection = true;
                currentMathSectionId = mathSectionId;
                currentPassageId = null;
                currentPassageData = null;
                currentLessonId = null;
                currentLessonData = null;
                currentWritingSectionId = null;
                userAnswers = {};
                
                // Update URL hash
                window.history.replaceState(null, '', window.location.pathname + `#math-section/${mathSectionId}`);
                
                const headers = {};
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                // Fetch math section detail
                const sectionResponse = await fetch(`${API_BASE}/math-sections/${mathSectionId}`, {headers});
                if (sectionResponse.status === 403) {
                    // Try to get section data anyway for preview
                    const previewResponse = await fetch(`${API_BASE}/math-sections/${mathSectionId}`, {});
                    if (previewResponse.ok) {
                        const sectionData = await previewResponse.json();
                        displayMathSectionPreview(sectionData);
                        isOpeningMathSection = false;
                        return;
                    }
                }
                
                if (!sectionResponse.ok) {
                    alert('Failed to fetch math section. Please try again.');
                    isOpeningMathSection = false;
                    return;
                }
                
                const sectionData = await sectionResponse.json();
                
                // Check if premium and user doesn't have access
                if (sectionData.tier === 'premium' && (!currentUser || (!currentUser.is_premium && !currentUser.has_active_subscription))) {
                    displayMathSectionPreview(sectionData);
                    isOpeningMathSection = false;
                    return;
                }
                
                // Fetch questions
                const questionsResponse = await fetch(`${API_BASE}/math-sections/${mathSectionId}/questions/`, {headers});
                if (!questionsResponse.ok) {
                    alert('Failed to fetch questions. Please try again.');
                    isOpeningMathSection = false;
                    return;
                }
                const questionsData = await questionsResponse.json();
                
                // Store math section data for sentinel replacement
                // Merge questions into sectionData so displayResults can find them
                currentMathSectionData = {
                    ...sectionData,
                    questions: questionsData.results || questionsData.questions || [],
                    results: questionsData.results || questionsData.questions || []
                };
                
                // Display math section
                displayMathSection(sectionData, questionsData);
                
            } catch (error) {
                console.error('Failed to open math section:', error);
                alert('Network error. Please try again.');
            } finally {
                // Always clear the flag
                isOpeningMathSection = false;
            }
        }
        
        async function displayWritingSection(writingSection, questions) {
            // Hide all category content containers (which contain the list sections)
            document.querySelectorAll('.category-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Hide all list sections individually as well
            const passagesListSection = document.getElementById('passagesListSection');
            const readingLessonsListSection = document.getElementById('readingLessonsListSection');
            const writingSectionsListSection = document.getElementById('writingSectionsListSection');
            const writingLessonsListSection = document.getElementById('writingLessonsListSection');
            const mathSectionsListSection = document.getElementById('mathSectionsListSection');
            const mathLessonsListSection = document.getElementById('mathLessonsListSection');
            const passageDetailSection = document.getElementById('passageDetailSection');
            
            if (passagesListSection) passagesListSection.style.display = 'none';
            if (readingLessonsListSection) readingLessonsListSection.style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // if (writingSectionsListSection) writingSectionsListSection.style.display = 'none';
            if (writingLessonsListSection) writingLessonsListSection.style.display = 'none';
            if (mathSectionsListSection) mathSectionsListSection.style.display = 'none';
            if (mathLessonsListSection) mathLessonsListSection.style.display = 'none';
            if (passageDetailSection) passageDetailSection.style.display = 'block';
            
            // Hide word of the day, show explanation container
            const wordOfDay = document.getElementById('wordOfDay');
            const questionExplanation = document.getElementById('questionExplanation');
            if (wordOfDay) wordOfDay.style.display = 'none';
            if (questionExplanation) {
                questionExplanation.style.display = 'block';
                questionExplanation.classList.remove('hidden');
            }
            
            // Show attempt history button if user is logged in
            const attemptHistoryContainer = document.getElementById('attemptHistoryButtonContainer');
            if (authToken && writingSection.id) {
                try {
                    const attemptsResponse = await fetch(`${API_BASE}/progress/writing-sections/${writingSection.id}/attempts`, {
                        headers: {'Authorization': `Bearer ${authToken}`}
                    });
                    if (attemptsResponse.ok) {
                        const attempts = await attemptsResponse.json();
                        if (attempts.length > 0) {
                            attemptHistoryContainer.innerHTML = `
                                <button class="btn btn-secondary" onclick="showWritingSectionAttemptHistory('${writingSection.id}')" style="font-size: 12px; padding: 6px 12px;">
                                    üìä View Attempt History (${attempts.length})
                                </button>
                            `;
                        } else {
                            attemptHistoryContainer.innerHTML = '';
                        }
                    } else {
                        attemptHistoryContainer.innerHTML = '';
                    }
                } catch (error) {
                    console.error('Failed to load attempt history:', error);
                    attemptHistoryContainer.innerHTML = '';
                }
            } else {
                attemptHistoryContainer.innerHTML = '';
            }
            
            // Format content with underlined selections
            const formattedContent = formatWritingSectionContent(writingSection.content, writingSection.selections || []);
            
            document.getElementById('passageContent').innerHTML = `
                <h2 style="color: #3498DB; margin-bottom: 15px;">${escapeHtml(writingSection.title)}</h2>
                ${formattedContent}
            `;
            
            // Display questions in two columns (similar to passages)
            const questionsContainer = document.getElementById('questionsContainer');
            questionsContainer.innerHTML = '<div class="questions-columns"><div class="question-column-left"></div><div class="question-column-right"></div></div>';
            
            const leftColumn = questionsContainer.querySelector('.question-column-left');
            const rightColumn = questionsContainer.querySelector('.question-column-right');
            
            // Store questions in map for explanation access
            currentQuestionsMap = {};
            (questions.questions || []).forEach(question => {
                currentQuestionsMap[question.id] = question;
            });
            
            (questions.questions || []).forEach((question, index) => {
                const questionNumber = question.order !== undefined ? question.order : (index + 1);
                const questionCard = document.createElement('div');
                questionCard.className = 'question-card';
                
                // Show selection number if question is linked to a selection
                let selectionInfo = '';
                if (question.selection_number) {
                    selectionInfo = `<p style="color: #666; font-size: 13px; margin-bottom: 8px;">Refer to selection [${question.selection_number}]</p>`;
                }
                
                // Process question prompt - handle both JSON blocks and plain text
                let questionPrompt = '';
                if (Array.isArray(question.text)) {
                    // New format: array of blocks
                    questionPrompt = formatLessonPrompt(question.text, currentLessonData?.assets || [], currentLessonData?.lesson_id || '');
                } else if (typeof question.text === 'string' && question.text) {
                    // Old format: plain text (backwards compatibility)
                    questionPrompt = `<p style="margin-bottom: 15px; font-size: 16px; color: #000;">${escapeHtml(question.text)}</p>`;
                } else {
                    questionPrompt = `<p style="margin-bottom: 15px; font-size: 16px; color: #000;">[No question text]</p>`;
                }
                
                questionCard.innerHTML = `
                    <h4>Question ${questionNumber}</h4>
                    ${selectionInfo}
                    <div style="margin-bottom: 15px; font-size: 16px; color: #000;">${questionPrompt}</div>
                    <div class="options-container">
                        ${question.options && question.options.length > 0 ? question.options.map((option, optIndex) => `
                            <div class="option" onclick="selectOption('${question.id}', ${optIndex})">
                                <input type="radio" name="question_${question.id}" value="${optIndex}" id="opt_${question.id}_${optIndex}">
                                <label class="option-label" for="opt_${question.id}_${optIndex}">
                                    ${String.fromCharCode(65 + optIndex)}. ${escapeHtml(option.text || option)}
                                </label>
                            </div>
                        `).join('') : '<p style="color: red;">No options available for this question</p>'}
                    </div>
                `;
                
                // Alternate between left and right columns
                if (index % 2 === 0) {
                    leftColumn.appendChild(questionCard);
                } else {
                    rightColumn.appendChild(questionCard);
                }
            });
            
            // For now, hide submit section for writing sections (no backend endpoint yet)
            // Show submit section
            const submitSection = document.getElementById('submitSection');
            const resultsSection = document.getElementById('resultsSection');
            if (submitSection) submitSection.style.display = 'block';
            if (resultsSection) resultsSection.style.display = 'none';
        }
        
        async function displayPassage(passage, questions) {
            // Hide all category content containers (which contain the list sections)
            document.querySelectorAll('.category-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Hide all list sections individually as well
            const passagesListSection = document.getElementById('passagesListSection');
            const readingLessonsListSection = document.getElementById('readingLessonsListSection');
            const writingSectionsListSection = document.getElementById('writingSectionsListSection');
            const writingLessonsListSection = document.getElementById('writingLessonsListSection');
            const mathSectionsListSection = document.getElementById('mathSectionsListSection');
            const mathLessonsListSection = document.getElementById('mathLessonsListSection');
            const passageDetailSection = document.getElementById('passageDetailSection');
            
            if (passagesListSection) passagesListSection.style.display = 'none';
            if (readingLessonsListSection) readingLessonsListSection.style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // if (writingSectionsListSection) writingSectionsListSection.style.display = 'none';
            if (writingLessonsListSection) writingLessonsListSection.style.display = 'none';
            if (mathSectionsListSection) mathSectionsListSection.style.display = 'none';
            if (mathLessonsListSection) mathLessonsListSection.style.display = 'none';
            if (passageDetailSection) passageDetailSection.style.display = 'block';
            
            // Hide word of the day for reading passages (too busy)
            // Show word of the day only for writing/math sections, not reading passages
            const wordOfDay = document.getElementById('wordOfDay');
            const questionExplanation = document.getElementById('questionExplanation');
            if (wordOfDay) wordOfDay.style.display = 'none'; // Hide for reading passages
            if (questionExplanation) {
                questionExplanation.style.display = 'block';
                questionExplanation.classList.remove('hidden');
            }
            
            // Show attempt history button if user is logged in
            const attemptHistoryContainer = document.getElementById('attemptHistoryButtonContainer');
            if (authToken && passage.id) {
                try {
                    const attemptsResponse = await fetch(`${API_BASE}/progress/passages/${passage.id}/attempts`, {
                        headers: {'Authorization': `Bearer ${authToken}`}
                    });
                    if (attemptsResponse.ok) {
                        const attempts = await attemptsResponse.json();
                        if (attempts.length > 0) {
                            attemptHistoryContainer.innerHTML = `
                                <button class="btn btn-secondary" onclick="showAttemptHistory('${passage.id}')" style="font-size: 12px; padding: 6px 12px;">
                                    üìä View Attempt History (${attempts.length})
                                </button>
                            `;
                        } else {
                            attemptHistoryContainer.innerHTML = '';
                        }
                    } else {
                        attemptHistoryContainer.innerHTML = '';
                    }
                } catch (error) {
                    console.error('Failed to load attempt count:', error);
                    attemptHistoryContainer.innerHTML = '';
                }
            } else {
                attemptHistoryContainer.innerHTML = '';
            }
            
            // Format passage in SAT style (50 chars per line, two columns, line numbers every 5)
            const formattedContent = formatPassageForSAT(passage.content);
            
            const passageContent = document.getElementById('passageContent');
            if (!passageContent) {
                console.error('passageContent element not found!');
                return;
            }
            passageContent.innerHTML = `
                <h2 style="color: #3498DB; margin-bottom: 15px;">${passage.title}</h2>
                <div class="passage-content-sat">${formattedContent}</div>
            `;
            
            // Display questions in two columns
            const questionsContainer = document.getElementById('questionsContainer');
            if (!questionsContainer) {
                console.error('questionsContainer element not found!');
                return;
            }
            questionsContainer.innerHTML = '<div class="questions-columns"><div class="question-column-left"></div><div class="question-column-right"></div></div>';
            
            const leftColumn = questionsContainer.querySelector('.question-column-left');
            const rightColumn = questionsContainer.querySelector('.question-column-right');
            
            if (!leftColumn || !rightColumn) {
                console.error('Question columns not found!');
                return;
            }
            
            // Debug: log questions to see what we're getting
            console.log('Questions received:', questions.questions);
            
            // Store questions in map for explanation access
            currentQuestionsMap = {};
            questions.questions.forEach(question => {
                currentQuestionsMap[question.id] = question;
            });
            
            questions.questions.forEach((question, index) => {
                // Use question.order if available, otherwise use index + 1
                const questionNumber = question.order !== undefined ? question.order : (index + 1);
                const questionCard = document.createElement('div');
                questionCard.className = 'question-card';
                questionCard.innerHTML = `
                    <h4>Question ${questionNumber}</h4>
                    <p style="margin-bottom: 15px; font-size: 16px; color: #000;">${question.text}</p>
                    <div class="options-container">
                        ${question.options && question.options.length > 0 ? question.options.map((option, optIndex) => `
                            <div class="option" onclick="selectOption('${question.id}', ${optIndex})">
                                <input type="radio" name="question_${question.id}" value="${optIndex}" id="opt_${question.id}_${optIndex}">
                                <label class="option-label" for="opt_${question.id}_${optIndex}">
                                    ${String.fromCharCode(65 + optIndex)}. ${option}
                                </label>
                            </div>
                        `).join('') : '<p style="color: red;">No options available for this question</p>'}
                    </div>
                `;
                
                // Alternate between left and right columns
                if (index % 2 === 0) {
                    leftColumn.appendChild(questionCard);
                } else {
                    rightColumn.appendChild(questionCard);
                }
            });
            
            // Show submit button, hide results
            const submitSection = document.getElementById('submitSection');
            const resultsSection = document.getElementById('resultsSection');
            if (submitSection) submitSection.style.display = 'block';
            if (resultsSection) resultsSection.style.display = 'none';
        }
        
        async function displayMathSection(mathSection, questions) {
            // Hide all category content containers (which contain the list sections)
            document.querySelectorAll('.category-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Hide all list sections individually as well
            const passagesListSection = document.getElementById('passagesListSection');
            const readingLessonsListSection = document.getElementById('readingLessonsListSection');
            const writingSectionsListSection = document.getElementById('writingSectionsListSection');
            const writingLessonsListSection = document.getElementById('writingLessonsListSection');
            const mathSectionsListSection = document.getElementById('mathSectionsListSection');
            const mathLessonsListSection = document.getElementById('mathLessonsListSection');
            const passageDetailSection = document.getElementById('passageDetailSection');
            
            if (passagesListSection) passagesListSection.style.display = 'none';
            if (readingLessonsListSection) readingLessonsListSection.style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // if (writingSectionsListSection) writingSectionsListSection.style.display = 'none';
            if (writingLessonsListSection) writingLessonsListSection.style.display = 'none';
            if (mathSectionsListSection) mathSectionsListSection.style.display = 'none';
            if (mathLessonsListSection) mathLessonsListSection.style.display = 'none';
            if (passageDetailSection) passageDetailSection.style.display = 'block';
            
            // Hide word of the day, show explanation container
            const wordOfDay = document.getElementById('wordOfDay');
            const questionExplanation = document.getElementById('questionExplanation');
            if (wordOfDay) wordOfDay.style.display = 'none';
            if (questionExplanation) {
                questionExplanation.style.display = 'block';
                questionExplanation.classList.remove('hidden');
            }
            
            // Show attempt history button if user is logged in
            const attemptHistoryContainer = document.getElementById('attemptHistoryButtonContainer');
            if (authToken && mathSection.id) {
                try {
                    const attemptsResponse = await fetch(`${API_BASE}/progress/math-sections/${mathSection.id}/attempts`, {
                        headers: {'Authorization': `Bearer ${authToken}`}
                    });
                    if (attemptsResponse.ok) {
                        const attempts = await attemptsResponse.json();
                        if (attempts.length > 0) {
                            attemptHistoryContainer.innerHTML = `
                                <button class="btn btn-secondary" onclick="showMathSectionAttemptHistory('${mathSection.id}')" style="font-size: 12px; padding: 6px 12px;">
                                    üìä View Attempt History (${attempts.length})
                                </button>
                            `;
                        } else {
                            attemptHistoryContainer.innerHTML = '';
                        }
                    }
                } catch (error) {
                    console.error('Failed to load attempt history:', error);
                }
            } else {
                attemptHistoryContainer.innerHTML = '';
            }
            
            // Display math section content
            const passageContent = document.getElementById('passageContent');
            if (!passageContent) {
                console.error('passageContent element not found!');
                return;
            }
            passageContent.innerHTML = `
                <h2 style="color: #3498DB; margin-bottom: 15px;">${escapeHtml(mathSection.title)}</h2>
            `;
            
            // Display questions in two columns
            const questionsContainer = document.getElementById('questionsContainer');
            if (!questionsContainer) {
                console.error('questionsContainer element not found!');
                return;
            }
            questionsContainer.innerHTML = '<div class="questions-columns"><div class="question-column-left"></div><div class="question-column-right"></div></div>';
            
            const leftColumn = questionsContainer.querySelector('.question-column-left');
            const rightColumn = questionsContainer.querySelector('.question-column-right');
            
            if (!leftColumn || !rightColumn) {
                console.error('Question columns not found!');
                return;
            }
            
            const questionsList = questions.results || questions.questions || [];
            
            // Store questions in map for explanation access
            currentQuestionsMap = {};
            questionsList.forEach(question => {
                currentQuestionsMap[question.id] = question;
            });
            
            questionsList.forEach((question, index) => {
                const questionNumber = question.order !== undefined ? question.order : (index + 1);
                const questionCard = document.createElement('div');
                questionCard.className = 'question-card';
                
                // Process question prompt - handle both JSON blocks and plain text (for backwards compatibility)
                let questionPrompt = '';
                const mathAssets = (mathSection && mathSection.assets) || (currentMathSectionData && currentMathSectionData.assets) || [];
                const mathSectionId = (mathSection && (mathSection.section_id || mathSection.id)) || (currentMathSectionData && (currentMathSectionData.section_id || currentMathSectionData.id)) || 'unknown';
                
                if (Array.isArray(question.prompt)) {
                    // New format: array of blocks
                    questionPrompt = formatMathPrompt(question.prompt, mathAssets, mathSectionId);
                } else if (typeof question.prompt === 'string' && question.prompt) {
                    // Old format: plain text (backwards compatibility)
                    questionPrompt = replaceDiagramSentinels(question.prompt, mathAssets, mathSectionId);
                    questionPrompt = replaceUnderlineSentinels(questionPrompt);
                    questionPrompt = `<p style="margin-bottom: 15px; font-size: 16px; color: #000;">${questionPrompt}</p>`;
                } else {
                    // Fallback
                    questionPrompt = `<p style="margin-bottom: 15px; font-size: 16px; color: #000;">${escapeHtml(question.text || '')}</p>`;
                }
                
                questionCard.innerHTML = `
                    <h4>Question ${questionNumber}</h4>
                    <div style="margin-bottom: 15px; font-size: 16px; color: #000;">${questionPrompt}</div>
                    <div class="options-container">
                        ${question.choices && question.choices.length > 0 ? question.choices.map((choice, optIndex) => `
                            <div class="option" onclick="selectOption('${question.id}', ${optIndex})">
                                <input type="radio" name="question_${question.id}" value="${optIndex}" id="opt_${question.id}_${optIndex}">
                                <label class="option-label" for="opt_${question.id}_${optIndex}">
                                    ${String.fromCharCode(65 + optIndex)}. ${escapeHtml(choice.text || choice)}
                                </label>
                            </div>
                        `).join('') : '<p style="color: red;">No options available for this question</p>'}
                    </div>
                `;
                
                // Alternate between left and right columns
                if (index % 2 === 0) {
                    leftColumn.appendChild(questionCard);
                } else {
                    rightColumn.appendChild(questionCard);
                }
            });
            
            // Show submit section
            const submitSection = document.getElementById('submitSection');
            const resultsSection = document.getElementById('resultsSection');
            if (submitSection) submitSection.style.display = 'block';
            if (resultsSection) resultsSection.style.display = 'none';
        }
        
        function displayMathSectionPreview(mathSection) {
            // Hide all list sections, show detail view
            document.getElementById('passagesListSection').style.display = 'none';
            document.getElementById('lessonsListSection').style.display = 'none';
            // COMMENTED OUT: Writing sections removed, only showing lessons
            // document.getElementById('writingSectionsListSection').style.display = 'none';
            document.getElementById('mathSectionsListSection').style.display = 'none';
            document.getElementById('passageDetailSection').style.display = 'block';
            
            let contentHTML = `<h2 style="color: #3498DB; margin-bottom: 15px;">${escapeHtml(mathSection.title)} <span class="premium-badge">PREMIUM</span> <span class="premium-lock">üîí</span></h2>`;
            contentHTML += '<div class="lesson-content premium-preview-overlay" style="max-width: 800px; margin: 0 auto;">';
            contentHTML += '<p style="margin-bottom: 15px; color: #000; line-height: 1.6;">This is a premium math section. Upgrade to access the full content with detailed explanations and diagrams.</p>';
            contentHTML += '</div>';
            
            // Add upgrade prompt
            contentHTML += `
                <div style="text-align: center; margin-top: 30px; padding: 30px; background: #f9f9f9; border-radius: 8px;">
                    <h3 style="color: #3498DB; margin-bottom: 15px;">Upgrade to Premium</h3>
                    <p style="color: #666; margin-bottom: 20px;">Get access to all premium math sections with detailed explanations and diagrams.</p>
                    <button class="btn btn-primary" onclick="showUpgradeModal()" style="font-size: 16px; padding: 12px 30px;">
                        Upgrade Now ($5/month)
                    </button>
                </div>
            `;
            
            document.getElementById('passageContent').innerHTML = contentHTML;
            document.getElementById('questionsContainer').innerHTML = '';
            document.getElementById('submitSection').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('attemptHistoryButtonContainer').innerHTML = '';
        }
        
        function selectOption(questionId, optionIndex) {
            userAnswers[questionId] = optionIndex;
            
            // Update visual selection
            const questionCard = document.querySelector(`input[name="question_${questionId}"]`)?.closest('.question-card');
            if (questionCard) {
                // Find the question to check correct answer
                const question = currentLessonData?.questions?.find(q => String(q.id) === String(questionId));
                const correctAnswerIndex = question?.correct_answer_index;
                const isCorrect = optionIndex === correctAnswerIndex;
                
                // Update all options with correct/incorrect styling
                questionCard.querySelectorAll('.option').forEach((opt, idx) => {
                    opt.classList.remove('selected', 'correct', 'incorrect');
                    if (idx === optionIndex) {
                        opt.classList.add('selected');
                        if (currentLessonId && currentLessonData && correctAnswerIndex !== undefined) {
                            opt.classList.add(isCorrect ? 'correct' : 'incorrect');
                        }
                    } else if (currentLessonId && currentLessonData && idx === correctAnswerIndex) {
                        // Mark correct answer even if not selected
                        opt.classList.add('correct');
                    }
                });
                
                const selectedOption = questionCard.querySelector(`#opt_${questionId}_${optionIndex}`);
                if (selectedOption) {
                    selectedOption.checked = true;
                }
            }
            
            // For lessons: show explanation inline with correct/incorrect feedback
            // For passages/sections: don't show explanation until after submit
            if (currentLessonId && currentLessonData) {
                const explanationDiv = document.getElementById(`explanation_${questionId}`);
                if (explanationDiv) {
                    // Find the question to check if answer is correct
                    const question = currentLessonData.questions?.find(q => String(q.id) === String(questionId));
                    if (question) {
                        const isCorrect = optionIndex === question.correct_answer_index;
                        const correctAnswerIndex = question.correct_answer_index;
                        
                        // Get the question card to find the choices
                        const questionCard = document.querySelector(`input[name="question_${questionId}"]`)?.closest('.question-card');
                        const choices = questionCard?.querySelectorAll('.option-label') || [];
                        const correctChoiceText = choices[correctAnswerIndex]?.textContent?.trim() || `Option ${String.fromCharCode(65 + correctAnswerIndex)}`;
                        
                        // Update explanation div to show feedback
                        const correctColor = '#28a745';
                        const incorrectColor = '#dc3545';
                        const feedbackColor = isCorrect ? correctColor : incorrectColor;
                        const feedbackIcon = isCorrect ? '‚úì' : '‚úó';
                        const feedbackText = isCorrect ? 'Correct!' : 'Incorrect';
                        
                        // Get existing explanation content (everything after "Explanation:")
                        const existingContent = explanationDiv.innerHTML;
                        const explanationMatch = existingContent.match(/<strong>Explanation:<\/strong>(.*)/s);
                        const explanationContent = explanationMatch ? explanationMatch[1] : '';
                        
                        // Update with feedback
                        explanationDiv.innerHTML = `
                            <div style="margin-bottom: 10px; padding: 8px; border-radius: 4px; background: ${isCorrect ? '#d4edda' : '#f8d7da'}; border-left: 3px solid ${feedbackColor};">
                                <strong style="color: ${feedbackColor}; font-size: 16px;">${feedbackIcon} ${feedbackText}</strong>
                                ${!isCorrect ? `<div style="margin-top: 6px; color: #333; font-size: 14px;">Correct answer: <strong>${correctChoiceText}</strong></div>` : ''}
                            </div>
                            <div>
                                <strong>Explanation:</strong>${explanationContent}
                            </div>
                        `;
                    }
                    explanationDiv.style.display = 'block';
                }
            }
            // Removed: Sidebar explanation for passages/sections - explanations now only show after submit
        }
        
        async function submitAnswers() {
            // Check if we're on a passage, writing section, math section, or lesson
            if (!currentPassageId && !currentWritingSectionId && !currentMathSectionId && !currentLessonId) return;
            
            // Handle lessons separately (client-side only for now)
            if (currentLessonId && currentLessonData) {
                displayLessonResults(currentLessonData);
                return;
            }
            
            // Determine what type of section we're on
            const isWritingSection = !!currentWritingSectionId;
            const isMathSection = !!currentMathSectionId;
            const currentId = isWritingSection ? currentWritingSectionId : 
                            isMathSection ? currentMathSectionId : 
                            currentPassageId;
            const currentData = isWritingSection ? currentWritingSectionData : 
                              isMathSection ? currentMathSectionData : 
                              currentPassageData;
            
            if (!currentId || !currentData) return;
            
            // Check if all questions are answered
            // For math sections, questions might be in a different structure
            const questionsList = currentData.questions || (currentData.results || []);
            const totalQuestions = Array.isArray(questionsList) ? questionsList.length : 0;
            if (Object.keys(userAnswers).length < totalQuestions) {
                if (!confirm(`You have only answered ${Object.keys(userAnswers).length} out of ${totalQuestions} questions. Submit anyway?`)) {
                    return;
                }
            }
            
            try {
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                // Convert answers to API format
                const answers = Object.entries(userAnswers).map(([questionId, selectedIndex]) => ({
                    question_id: questionId,
                    selected_option_index: selectedIndex
                }));
                
                // Submit answers - use appropriate endpoint
                const submitEndpoint = isWritingSection
                    ? `${API_BASE}/progress/writing-sections/${currentId}/submit`
                    : isMathSection
                    ? `${API_BASE}/progress/math-sections/${currentId}/submit`
                    : `${API_BASE}/progress/passages/${currentId}/submit`;
                
                const submitResponse = await fetch(submitEndpoint, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        answers: answers,
                        time_spent_seconds: 0 // Could track this if needed
                    })
                });
                
                if (!submitResponse.ok) {
                    const error = await submitResponse.json();
                    alert(error.error?.message || 'Failed to submit answers. Please try again.');
                    return;
                }
                
                // Get submit response data (includes correct_count and total_questions)
                const submitData = await submitResponse.json();
                
                // Get review data for detailed answer breakdown
                const reviewEndpoint = isWritingSection
                    ? `${API_BASE}/progress/writing-sections/${currentId}/review`
                    : isMathSection
                    ? `${API_BASE}/progress/math-sections/${currentId}/review`
                    : `${API_BASE}/progress/passages/${currentId}/review`;
                
                const reviewResponse = await fetch(reviewEndpoint, {
                    headers: authToken ? {'Authorization': `Bearer ${authToken}`} : {}
                });
                
                if (reviewResponse.ok) {
                    const reviewData = await reviewResponse.json();
                    // Use correct_count and total_questions from submit response (more reliable)
                    reviewData.correct_count = submitData.correct_count || reviewData.correct_count || 0;
                    const questionsListForTotal = currentData.questions || (currentData.results || []);
                    reviewData.total_questions = submitData.total_questions || reviewData.total_questions || (Array.isArray(questionsListForTotal) ? questionsListForTotal.length : 0);
                    displayResults(reviewData, isWritingSection, isMathSection);
                } else {
                    // Fallback: use submit response data directly
                    if (submitData.correct_count !== undefined && submitData.total_questions !== undefined) {
                        displayResults({
                            correct_count: submitData.correct_count,
                            total_questions: submitData.total_questions,
                            answers: submitData.answers || []
                        }, isWritingSection, isMathSection);
                    } else {
                        // Final fallback: show results from data
                        if (isWritingSection) {
                            displayResultsFromWritingSection(currentData);
                        } else {
                            displayResultsFromPassage(currentData);
                        }
                    }
                }
                
            } catch (error) {
                console.error('Failed to submit answers:', error);
                alert('Network error. Please try again.');
            }
        }
        
        let lastAttemptData = null; // Store attempt data for anonymous users to save on registration
        
        function displayResults(reviewData, isWritingSection = false, isMathSection = false) {
            const resultsSection = document.getElementById('resultsSection');
            resultsSection.style.display = 'block';
            document.getElementById('submitSection').style.display = 'none';
            
            const currentId = isMathSection ? currentMathSectionId : 
                            isWritingSection ? currentWritingSectionId : 
                            currentPassageId;
            const currentData = isMathSection ? currentMathSectionData : 
                              isWritingSection ? currentWritingSectionData : 
                              currentPassageData;
            
            const correctCount = reviewData.correct_count || 0;
            // For math sections, questions might be in results array
            const questionsList = currentData ? (currentData.questions || currentData.results || []) : [];
            const totalQuestions = reviewData.total_questions || (Array.isArray(questionsList) ? questionsList.length : 0);
            const percentage = Math.round((correctCount / totalQuestions) * 100);
            
            // Store attempt data for anonymous users (to save on registration)
            if (!authToken && reviewData.attempt_id) {
                lastAttemptData = {
                    [isMathSection ? 'math_section_id' : (isWritingSection ? 'writing_section_id' : 'passage_id')]: currentId,
                    attempt_id: reviewData.attempt_id,
                    answers: reviewData.answers || [],
                    score: reviewData.score,
                    correct_count: correctCount,
                    total_questions: totalQuestions,
                    is_writing_section: isWritingSection,
                    is_math_section: isMathSection
                };
            }
            
            let resultsHTML = `
                <div class="results-summary">
                    <h3>Your Results</h3>
                    <div class="score">${correctCount} / ${totalQuestions} (${percentage}%)</div>
                </div>
            `;
            
            // Show attempt history button for logged-in users
            if (authToken && currentId) {
                if (isMathSection) {
                    resultsHTML += `
                        <div style="margin: 20px 0; text-align: center;">
                            <button class="btn btn-secondary" onclick="setTimeout(() => showMathSectionAttemptHistory('${currentId}'), 500)" style="font-size: 14px; padding: 10px 20px;">
                                üìä View All Attempts for This Math Section
                            </button>
                        </div>
                    `;
                } else if (isWritingSection) {
                    resultsHTML += `
                        <div style="margin: 20px 0; text-align: center;">
                            <button class="btn btn-secondary" onclick="setTimeout(() => showWritingSectionAttemptHistory('${currentId}'), 500)" style="font-size: 14px; padding: 10px 20px;">
                                üìä View All Attempts for This Writing Section
                            </button>
                        </div>
                    `;
                } else {
                    resultsHTML += `
                        <div style="margin: 20px 0; text-align: center;">
                            <button class="btn btn-secondary" onclick="setTimeout(() => showAttemptHistory('${currentId}'), 500)" style="font-size: 14px; padding: 10px 20px;">
                                üìä View All Attempts for This Passage
                            </button>
                        </div>
                    `;
                }
            }
            
            // Show registration prompt for anonymous users
            if (!authToken) {
                resultsHTML += `
                    <div style="background: #e3f2fd; border: 2px solid #3498DB; border-radius: 8px; padding: 20px; margin: 20px 0; text-align: center;">
                        <h4 style="color: #3498DB; margin-bottom: 10px;">üí° Want to track your progress?</h4>
                        <p style="color: #333; margin-bottom: 15px;">Register now to save this attempt and track your improvement over time!</p>
                        <button class="btn btn-primary" onclick="showRegisterModalAndSaveAttempt()" style="font-size: 16px; padding: 12px 24px;">
                            Register & Save This Attempt
                        </button>
                        <p style="color: #666; font-size: 12px; margin-top: 10px;">Free to register ‚Ä¢ No credit card required</p>
                    </div>
                `;
            }
            
            // Show each question with correct/incorrect status
            // For math sections, get questions from currentQuestionsMap (they're stored there)
            let questions = [];
            if (isMathSection) {
                // Try multiple sources for questions
                // 1. currentQuestionsMap (populated when section was displayed)
                questions = Object.values(currentQuestionsMap);
                
                // 2. If empty, try currentData
                if (questions.length === 0 && currentData) {
                    questions = currentData.questions || currentData.results || [];
                }
                
                // Sort by order if available
                questions.sort((a, b) => {
                    const orderA = a.order !== undefined ? a.order : 999;
                    const orderB = b.order !== undefined ? b.order : 999;
                    return orderA - orderB;
                });
            } else {
                // For passages and writing sections, get from currentData
                questions = currentData ? (currentData.questions || currentData.results || []) : [];
            }
            
            console.log('Displaying results - questions found:', questions.length, 'isMathSection:', isMathSection, 'currentQuestionsMap size:', Object.keys(currentQuestionsMap).length, 'currentData has questions:', currentData ? !!(currentData.questions || currentData.results) : false);
            
            if (questions.length === 0) {
                console.error('No questions found for results display!', {
                    isMathSection,
                    currentData: currentData ? Object.keys(currentData) : null,
                    currentQuestionsMapSize: Object.keys(currentQuestionsMap).length
                });
                resultsSection.innerHTML = resultsHTML + '<p style="color: red; padding: 20px;">Error: Could not load questions for results display.</p>';
                return;
            }
            
            questions.forEach((question, index) => {
                // Ensure question ID is a string for comparison
                const questionIdStr = String(question.id);
                const userAnswer = userAnswers[questionIdStr] !== undefined ? userAnswers[questionIdStr] : userAnswers[question.id];
                const reviewAnswer = reviewData.answers && reviewData.answers.find(a => String(a.question_id) === questionIdStr);
                const isCorrect = reviewAnswer ? reviewAnswer.is_correct : (userAnswer === question.correct_answer_index);
                
                // Get options - handle both array of strings and array of objects
                const options = question.options || question.choices || [];
                const userOption = options[userAnswer];
                const correctOption = options[question.correct_answer_index];
                
                // Get question text - math sections use 'prompt', others use 'text'
                const questionText = question.prompt || question.text || '';
                
                // Use question.order if available, otherwise use index + 1
                const questionNumber = question.order !== undefined ? question.order : (index + 1);
                
                // Format explanation - math sections use arrays, others use strings
                let explanationText = '';
                if ((reviewAnswer && reviewAnswer.explanation) || question.explanation) {
                    const rawExplanation = (reviewAnswer && reviewAnswer.explanation) || question.explanation;
                    console.log('Raw explanation before formatting:', rawExplanation, 'type:', typeof rawExplanation, 'isArray:', Array.isArray(rawExplanation));
                    
                    explanationText = formatMathExplanation(rawExplanation, isMathSection);
                    console.log('After formatMathExplanation:', explanationText, 'type:', typeof explanationText);
                    
                    // CRITICAL: Ensure it's a string - if formatMathExplanation failed, convert it
                    if (typeof explanationText !== 'string') {
                        console.error('formatMathExplanation did not return a string!', explanationText);
                        // If it's still an array/object, try to format it manually
                        if (Array.isArray(explanationText) || (explanationText && typeof explanationText === 'object')) {
                            explanationText = formatMathExplanation(explanationText, isMathSection);
                        }
                        // Final fallback - convert to string
                        if (typeof explanationText !== 'string') {
                            explanationText = JSON.stringify(explanationText);
                        }
                    }
                    
                    // Apply sentinel replacement for math sections
                    if (isMathSection && currentMathSectionData && typeof explanationText === 'string') {
                        explanationText = replaceDiagramSentinels(explanationText, currentMathSectionData.assets || [], currentMathSectionData.section_id || currentMathSectionData.id);
                    }
                    // Replace underline sentinels
                    if (typeof explanationText === 'string') {
                        explanationText = replaceUnderlineSentinels(explanationText);
                    }
                    
                    console.log('Final explanationText:', explanationText, 'type:', typeof explanationText);
                }
                
                resultsHTML += `
                    <div class="question-card">
                        <h4>Question ${questionNumber} ${isCorrect ? '‚úì' : '‚úó'}</h4>
                        <p style="margin-bottom: 15px; font-size: 16px; color: #000;">${questionText}</p>
                        <div class="options-container">
                            ${options.map((option, optIndex) => {
                                let optionClass = 'option';
                                if (optIndex === question.correct_answer_index) {
                                    optionClass += ' correct';
                                } else if (optIndex === userAnswer && !isCorrect) {
                                    optionClass += ' incorrect';
                                }
                                
                                // Handle both object format (from passage detail) and string format (from questions endpoint)
                                const optionText = typeof option === 'string' ? option : option.text;
                                
                                return `
                                    <div class="${optionClass}">
                                        <input type="radio" disabled ${optIndex === userAnswer ? 'checked' : ''}>
                                        <label class="option-label">
                                            ${String.fromCharCode(65 + optIndex)}. ${optionText}
                                            ${optIndex === question.correct_answer_index ? ' (Correct)' : ''}
                                            ${optIndex === userAnswer && !isCorrect ? ' (Your Answer)' : ''}
                                        </label>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        ${explanationText ? `
                            <div class="explanation" style="white-space: pre-wrap; margin-top: 12px; padding: 12px 16px; background: var(--bg-secondary); border-left: 3px solid var(--accent-color); border-radius: 4px;">
                                <strong style="color: var(--accent-color); display: block; margin-bottom: 8px;">Explanation:</strong>
                                <div style="line-height: 1.6; color: var(--text-primary);">${explanationText}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            resultsSection.innerHTML = resultsHTML;
            
            // Scroll to results
            resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        function displayLessonResults(lessonData) {
            // Display results for lesson questions (client-side only)
            const resultsSection = document.getElementById('resultsSection');
            resultsSection.style.display = 'block';
            document.getElementById('submitSection').style.display = 'none';
            
            if (!lessonData.questions || lessonData.questions.length === 0) {
                resultsSection.innerHTML = '<p>No questions in this lesson.</p>';
                return;
            }
            
            // Get current page index and find questions on current page only
            const currentPageIndex = lessonData.currentPageIndex || 0;
            const pages = lessonData.pages || [];
            
            // Get chunk indices from current page
            const currentPageChunkIndices = new Set();
            if (currentPageIndex >= 0 && currentPageIndex < pages.length) {
                const currentPage = pages[currentPageIndex];
                currentPage.forEach(({chunkIdx}) => {
                    currentPageChunkIndices.add(chunkIdx);
                });
            }
            
            // Filter questions to only those on current page (match by chunk_index)
            const currentPageQuestions = lessonData.questions.filter(q => {
                // Check if question's chunk_index is in the current page
                return q.chunk_index !== undefined && currentPageChunkIndices.has(q.chunk_index);
            });
            
            if (currentPageQuestions.length === 0) {
                resultsSection.innerHTML = '<p style="padding: 20px; color: #666;">No questions on this page. Navigate to a page with questions to submit answers.</p>';
                return;
            }
            
            let correctCount = 0;
            const totalQuestions = currentPageQuestions.length;
            
            // Calculate correct answers for current page questions only
            currentPageQuestions.forEach(question => {
                const userAnswer = userAnswers[question.id];
                if (userAnswer === question.correct_answer_index) {
                    correctCount++;
                }
            });
            
            const percentage = Math.round((correctCount / totalQuestions) * 100);
            
            let resultsHTML = `
                <div class="results-summary">
                    <h3>Your Results (Page ${currentPageIndex + 1})</h3>
                    <div class="score">${correctCount} / ${totalQuestions} (${percentage}%)</div>
                </div>
            `;
            
            // Show each question from current page with correct answer and explanation
            currentPageQuestions.forEach((question, index) => {
                const userAnswer = userAnswers[question.id];
                const isCorrect = userAnswer === question.correct_answer_index;
                const questionNumber = question.order !== undefined ? question.order : (index + 1);
                
                // Get options from question object
                const options = question.options || [];
                
                // Process question prompt - handle both JSON blocks and plain text
                let questionPrompt = '';
                if (Array.isArray(question.text)) {
                    // New format: array of blocks
                    questionPrompt = formatLessonPrompt(question.text, currentLessonData?.assets || [], currentLessonData?.lesson_id || '');
                } else if (typeof question.text === 'string' && question.text) {
                    // Old format: plain text (backwards compatibility)
                    questionPrompt = `<p style="margin-bottom: 15px; font-size: 16px; color: #000;">${escapeHtml(question.text)}</p>`;
                } else {
                    questionPrompt = `<p style="margin-bottom: 15px; font-size: 16px; color: #000;">[No question text]</p>`;
                }
                
                resultsHTML += `
                    <div class="question-card">
                        <h4>Question ${questionNumber} ${isCorrect ? '‚úì' : '‚úó'}</h4>
                        <div style="margin-bottom: 15px; font-size: 16px; color: #000;">${questionPrompt}</div>
                        <div class="options-container">
                            ${options.map((option, optIndex) => {
                                let optionClass = 'option';
                                if (optIndex === question.correct_answer_index) {
                                    optionClass += ' correct';
                                } else if (optIndex === userAnswer && !isCorrect) {
                                    optionClass += ' incorrect';
                                }
                                
                                const optionText = typeof option === 'string' ? option : (option.text || option);
                                
                                return `
                                    <div class="${optionClass}">
                                        <input type="radio" disabled ${optIndex === userAnswer ? 'checked' : ''}>
                                        <label class="option-label">
                                            ${String.fromCharCode(65 + optIndex)}. ${escapeHtml(optionText)}
                                            ${optIndex === question.correct_answer_index ? ' (Correct)' : ''}
                                            ${optIndex === userAnswer && !isCorrect ? ' (Your Answer)' : ''}
                                        </label>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        ${question.explanation ? `
                            <div class="explanation" style="margin-top: 15px; padding: 12px; border-left: 4px solid var(--accent-color); border-radius: 4px;">
                                <strong>Explanation:</strong> ${replaceUnderlineSentinels(replaceDiagramSentinels(question.explanation, lessonData.assets || [], lessonData.lesson_id))}
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            resultsSection.innerHTML = resultsHTML;
            
            // Scroll to results
            resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        function displayResultsFromPassage(passageData) {
            // Fallback if review endpoint fails - use passage data directly
            const resultsSection = document.getElementById('resultsSection');
            resultsSection.style.display = 'block';
            document.getElementById('submitSection').style.display = 'none';
            
            let correctCount = 0;
            passageData.questions.forEach(q => {
                if (userAnswers[q.id] === q.correct_answer_index) {
                    correctCount++;
                }
            });
            
            const totalQuestions = passageData.questions.length;
            const percentage = Math.round((correctCount / totalQuestions) * 100);
            
            let resultsHTML = `
                <div class="results-summary">
                    <h3>Your Results</h3>
                    <div class="score">${correctCount} / ${totalQuestions} (${percentage}%)</div>
                </div>
            `;
            
            passageData.questions.forEach((question, index) => {
                const userAnswer = userAnswers[question.id];
                const isCorrect = userAnswer === question.correct_answer_index;
                
                // Use question.order if available, otherwise use index + 1
                const questionNumber = question.order !== undefined ? question.order : (index + 1);
                
                resultsHTML += `
                    <div class="question-card">
                        <h4>Question ${questionNumber} ${isCorrect ? '‚úì' : '‚úó'}</h4>
                        <p style="margin-bottom: 15px; font-size: 16px; color: #000;">${question.text}</p>
                        <div class="options-container">
                            ${question.options.map((option, optIndex) => {
                                let optionClass = 'option';
                                if (optIndex === question.correct_answer_index) {
                                    optionClass += ' correct';
                                } else if (optIndex === userAnswer && !isCorrect) {
                                    optionClass += ' incorrect';
                                }
                                
                                // Handle both object format (from passage detail) and string format (from questions endpoint)
                                const optionText = typeof option === 'string' ? option : option.text;
                                
                                return `
                                    <div class="${optionClass}">
                                        <input type="radio" disabled ${optIndex === userAnswer ? 'checked' : ''}>
                                        <label class="option-label">
                                            ${String.fromCharCode(65 + optIndex)}. ${optionText}
                                            ${optIndex === question.correct_answer_index ? ' (Correct)' : ''}
                                            ${optIndex === userAnswer && !isCorrect ? ' (Your Answer)' : ''}
                                        </label>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        ${question.explanation ? `
                            <div class="explanation">
                                <strong>Explanation:</strong> ${replaceUnderlineSentinels(replaceDiagramSentinels(question.explanation, lessonData.assets || [], lessonData.lesson_id))}
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            resultsSection.innerHTML = resultsHTML;
            resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        function backToPassagesList() {
            // Show category content for current category
            document.querySelectorAll('.category-content').forEach(content => {
                if (content.id === `category-${currentCategory}`) {
                    content.style.display = 'block';
                } else {
                    content.style.display = 'none';
                }
            });
            
            // Explicitly show list sections for current category
            if (currentCategory === 'reading') {
                const readingLessonsListSection = document.getElementById('readingLessonsListSection');
                const passagesListSection = document.getElementById('passagesListSection');
                if (readingLessonsListSection) readingLessonsListSection.style.display = 'block';
                if (passagesListSection) passagesListSection.style.display = 'block';
            } else if (currentCategory === 'writing') {
                const writingLessonsListSection = document.getElementById('writingLessonsListSection');
                // COMMENTED OUT: Writing sections removed, only showing lessons
                // const writingSectionsListSection = document.getElementById('writingSectionsListSection');
                if (writingLessonsListSection) writingLessonsListSection.style.display = 'block';
                // if (writingSectionsListSection) writingSectionsListSection.style.display = 'block';
            } else if (currentCategory === 'math') {
                const mathLessonsListSection = document.getElementById('mathLessonsListSection');
                const mathSectionsListSection = document.getElementById('mathSectionsListSection');
                if (mathLessonsListSection) mathLessonsListSection.style.display = 'block';
                if (mathSectionsListSection) mathSectionsListSection.style.display = 'block';
            }
            
            // Hide detail section
            const passageDetailSection = document.getElementById('passageDetailSection');
            if (passageDetailSection) passageDetailSection.style.display = 'none';
            currentPassageId = null;
            currentPassageData = null;
            currentLessonId = null;
            currentLessonData = null;
            currentWritingSectionId = null;
            currentWritingSectionData = null;
            currentMathSectionId = null;
            currentMathSectionData = null;
            userAnswers = {};
            lastAttemptData = null;
            currentQuestionsMap = {}; // Clear questions map
            
            // Show word of the day, hide explanation container
            const wordOfDay = document.getElementById('wordOfDay');
            const questionExplanation = document.getElementById('questionExplanation');
            if (wordOfDay) wordOfDay.style.display = 'block';
            if (questionExplanation) {
                questionExplanation.style.display = 'none';
                questionExplanation.classList.add('hidden');
                const content = document.getElementById('questionExplanationContent');
                if (content) content.innerHTML = '';
            }
            
            // Update URL hash
            window.history.replaceState(null, '', window.location.pathname + '#passages');
        }
        
        function showRegisterModalAndSaveAttempt() {
            // Store that we should save the attempt after registration
            showRegisterModal();
        }
        
        async function saveAnonymousAttempt(attemptData) {
            // This will be called after user registers to save their anonymous attempt
            // For now, we'll just show a message - the attempt was already submitted
            // In the future, we could create a new attempt record with the user's ID
            console.log('Saving anonymous attempt after registration:', attemptData);
            // Note: The attempt was already created on the server, we just need to associate it with the user
            // This would require a backend endpoint to update the attempt's user field
            // For now, we'll just show a success message
            if (currentPassageId) {
                // Reload passages to show attempt count
                loadPassages();
            }
        }
        
        async function showAttemptHistory(passageId) {
            if (!authToken) {
                alert('Please log in to view your attempt history.');
                return;
            }
            
            try {
                const url = `${API_BASE}/progress/passages/${passageId}/attempts`;
                console.log('Fetching attempt history from:', url);
                
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    let errorMessage = 'Please try again.';
                    try {
                        const errorData = await response.json();
                        console.error('Error response:', errorData);
                        errorMessage = errorData.error?.message || errorMessage;
                    } catch (e) {
                        console.error('Failed to parse error response:', e);
                        errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    alert(`Failed to load attempt history. ${errorMessage}`);
                    return;
                }
                
                const attempts = await response.json();
                
                if (attempts.length === 0) {
                    alert('No attempts found for this passage. Try refreshing the page.');
                    return;
                }
                
                // Show attempts in a modal
                let attemptsHTML = '<div style="max-height: 70vh; overflow-y: auto;">';
                attemptsHTML += `<h3 style="margin-bottom: 20px; color: #3498DB;">Attempt History</h3>`;
                
                attempts.forEach((attempt, index) => {
                    const date = new Date(attempt.completed_at);
                    const dateStr = date.toLocaleString();
                    const percentage = Math.round((attempt.correct_count / attempt.total_questions) * 100);
                    
                    attemptsHTML += `
                        <div style="border: 1px solid #d0d0d0; border-radius: 8px; padding: 15px; margin-bottom: 15px; background: white;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <strong style="color: #000;">Attempt #${attempts.length - index}</strong>
                                <span style="color: #666; font-size: 12px;">${dateStr}</span>
                            </div>
                            <div style="color: #000; margin-bottom: 8px;">
                                Score: <strong style="color: #3498DB;">${attempt.correct_count} / ${attempt.total_questions} (${percentage}%)</strong>
                            </div>
                            ${attempt.time_spent_seconds ? `<div style="color: #666; font-size: 12px;">Time: ${Math.floor(attempt.time_spent_seconds / 60)}m ${attempt.time_spent_seconds % 60}s</div>` : ''}
                            <button class="btn btn-secondary" onclick="viewAttemptDetails('${attempt.id}', '${passageId}', false)" style="margin-top: 10px; font-size: 12px; padding: 6px 12px;">
                                View Details
                            </button>
                        </div>
                    `;
                });
                
                attemptsHTML += '</div>';
                
                // Create and show modal
                const modal = document.createElement('div');
                modal.className = 'modal active';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px;">
                        <h2>Attempt History</h2>
                        ${attemptsHTML}
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()" style="margin-top: 20px; width: 100%;">Close</button>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Close on outside click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
            } catch (error) {
                console.error('Failed to load attempt history:', error);
                alert('Network error. Please try again.');
            }
        }
        
        async function showWritingSectionAttemptHistory(writingSectionId) {
            if (!authToken) {
                alert('Please log in to view your attempt history.');
                return;
            }
            
            try {
                const url = `${API_BASE}/progress/writing-sections/${writingSectionId}/attempts`;
                console.log('Fetching writing section attempt history from:', url);
                
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    let errorMessage = 'Please try again.';
                    try {
                        const errorData = await response.json();
                        console.error('Error response:', errorData);
                        errorMessage = errorData.error?.message || errorMessage;
                    } catch (e) {
                        console.error('Failed to parse error response:', e);
                        errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    alert(`Failed to load attempt history. ${errorMessage}`);
                    return;
                }
                
                const attempts = await response.json();
                
                if (attempts.length === 0) {
                    alert('No attempts found for this writing section. Try refreshing the page.');
                    return;
                }
                
                // Show attempts in a modal
                let attemptsHTML = '<div style="max-height: 70vh; overflow-y: auto;">';
                attemptsHTML += `<h3 style="margin-bottom: 20px; color: #3498DB;">Attempt History</h3>`;
                
                attempts.forEach((attempt, index) => {
                    const date = new Date(attempt.completed_at);
                    const dateStr = date.toLocaleString();
                    const percentage = Math.round((attempt.correct_count / attempt.total_questions) * 100);
                    
                    attemptsHTML += `
                        <div style="border: 1px solid #d0d0d0; border-radius: 8px; padding: 15px; margin-bottom: 15px; background: white;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <strong style="color: #000;">Attempt #${attempts.length - index}</strong>
                                <span style="color: #666; font-size: 12px;">${dateStr}</span>
                            </div>
                            <div style="color: #000; margin-bottom: 8px;">
                                Score: <strong style="color: #3498DB;">${attempt.correct_count} / ${attempt.total_questions} (${percentage}%)</strong>
                            </div>
                            ${attempt.time_spent_seconds ? `<div style="color: #666; font-size: 12px;">Time: ${Math.floor(attempt.time_spent_seconds / 60)}m ${attempt.time_spent_seconds % 60}s</div>` : ''}
                            <button class="btn btn-secondary" onclick="viewAttemptDetails('${attempt.id}', '${writingSectionId}', true)" style="margin-top: 10px; font-size: 12px; padding: 6px 12px;">
                                View Details
                            </button>
                        </div>
                    `;
                });
                
                attemptsHTML += '</div>';
                
                // Create and show modal
                const modal = document.createElement('div');
                modal.className = 'modal active';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px;">
                        <h2>Attempt History</h2>
                        ${attemptsHTML}
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()" style="margin-top: 20px; width: 100%;">Close</button>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Close on outside click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
            } catch (error) {
                console.error('Failed to load attempt history:', error);
                alert('Network error. Please try again.');
            }
        }
        
        async function viewAttemptDetails(attemptId, sectionId, isWritingSection = false, isMathSection = false) {
            // Load section and attempt data to show full details
            try {
                let endpoint, attemptsEndpoint;
                if (isMathSection) {
                    endpoint = `${API_BASE}/math-sections/${sectionId}`;
                    attemptsEndpoint = `${API_BASE}/progress/math-sections/${sectionId}/attempts`;
                } else if (isWritingSection) {
                    endpoint = `${API_BASE}/writing-sections/${sectionId}`;
                    attemptsEndpoint = `${API_BASE}/progress/writing-sections/${sectionId}/attempts`;
                } else {
                    endpoint = `${API_BASE}/passages/${sectionId}`;
                    attemptsEndpoint = `${API_BASE}/progress/passages/${sectionId}/attempts`;
                }
                
                const [sectionResponse, attemptsResponse] = await Promise.all([
                    fetch(endpoint, {
                        headers: authToken ? {'Authorization': `Bearer ${authToken}`} : {}
                    }),
                    fetch(attemptsEndpoint, {
                        headers: {'Authorization': `Bearer ${authToken}`}
                    })
                ]);
                
                if (!sectionResponse.ok || !attemptsResponse.ok) {
                    alert('Failed to load attempt details.');
                    return;
                }
                
                const sectionData = await sectionResponse.json();
                const attempts = await attemptsResponse.json();
                const attempt = attempts.find(a => a.id === attemptId);
                
                if (!attempt) {
                    alert('Attempt not found.');
                    return;
                }
                
                // Show attempt details in a modal
                const date = new Date(attempt.completed_at);
                const dateStr = date.toLocaleString();
                const percentage = Math.round((attempt.correct_count / attempt.total_questions) * 100);
                
                let detailsHTML = `
                    <div style="max-height: 80vh; overflow-y: auto;">
                        <h3 style="margin-bottom: 15px; color: #3498DB;">Attempt Details</h3>
                        <div style="background: #f9f9f9; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <div style="margin-bottom: 8px;"><strong>Date:</strong> ${dateStr}</div>
                            <div style="margin-bottom: 8px;"><strong>Score:</strong> ${attempt.correct_count} / ${attempt.total_questions} (${percentage}%)</div>
                            ${attempt.time_spent_seconds ? `<div><strong>Time:</strong> ${Math.floor(attempt.time_spent_seconds / 60)}m ${attempt.time_spent_seconds % 60}s</div>` : ''}
                        </div>
                        <h4 style="margin-bottom: 15px; color: #000;">Your Answers:</h4>
                `;
                
                // Match attempt answers with section questions
                // For math sections, questions might be in results array
                const questions = sectionData.questions || sectionData.results || [];
                questions.forEach((question, index) => {
                    const attemptAnswer = attempt.answers.find(a => a.question_id === question.id);
                    if (!attemptAnswer) return;
                    
                    const isCorrect = attemptAnswer.is_correct;
                    const questionNumber = question.order !== undefined ? question.order : (index + 1);
                    
                    // Get options - handle both array of strings and array of objects
                    const options = question.options || question.choices || [];
                    
                    // Get question text - math sections use 'prompt' (can be array or string), others use 'text'
                    let questionText = '';
                    const mathAssets = currentMathSectionData?.assets || [];
                    const mathSectionId = currentMathSectionData?.section_id || currentMathSectionData?.id || '';
                    
                    if (Array.isArray(question.prompt)) {
                        // New format: array of blocks
                        questionText = formatMathPrompt(question.prompt, mathAssets, mathSectionId);
                    } else if (typeof question.prompt === 'string' && question.prompt) {
                        // Old format: plain text (backwards compatibility)
                        questionText = replaceDiagramSentinels(question.prompt, mathAssets, mathSectionId);
                        questionText = replaceUnderlineSentinels(questionText);
                        questionText = `<p style="margin-bottom: 10px; font-size: 14px; color: #000;">${questionText}</p>`;
                    } else {
                        questionText = `<p style="margin-bottom: 10px; font-size: 14px; color: #000;">${escapeHtml(question.text || '')}</p>`;
                    }
                    
                    detailsHTML += `
                        <div class="question-card" style="margin-bottom: 15px;">
                            <h4>Question ${questionNumber} ${isCorrect ? '‚úì' : '‚úó'}</h4>
                            <div style="margin-bottom: 10px; font-size: 14px; color: #000;">${questionText}</div>
                            <div class="options-container">
                                ${options.map((option, optIndex) => {
                                    let optionClass = 'option';
                                    if (optIndex === question.correct_answer_index) {
                                        optionClass += ' correct';
                                    } else if (optIndex === attemptAnswer.selected_option_index && !isCorrect) {
                                        optionClass += ' incorrect';
                                    }
                                    
                                    const optionText = typeof option === 'string' ? option : option.text;
                                    
                                    return `
                                        <div class="${optionClass}" style="pointer-events: none;">
                                            <input type="radio" disabled ${optIndex === attemptAnswer.selected_option_index ? 'checked' : ''}>
                                            <label class="option-label">
                                                ${String.fromCharCode(65 + optIndex)}. ${optionText}
                                                ${optIndex === question.correct_answer_index ? ' (Correct)' : ''}
                                                ${optIndex === attemptAnswer.selected_option_index && !isCorrect ? ' (Your Answer)' : ''}
                                            </label>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                            ${attemptAnswer.explanation ? `
                                <div class="explanation" style="margin-top: 10px;">
                                    <strong>Explanation:</strong> ${formatMathExplanation(attemptAnswer.explanation, isMathSection)}
                                </div>
                            ` : ''}
                        </div>
                    `;
                });
                
                detailsHTML += '</div>';
                
                // Create and show modal
                const modal = document.createElement('div');
                modal.className = 'modal active';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 700px;">
                        ${detailsHTML}
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()" style="margin-top: 20px; width: 100%;">Close</button>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Close on outside click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
            } catch (error) {
                console.error('Failed to load attempt details:', error);
                alert('Network error. Please try again.');
            }
        }
        
        async function showMathSectionAttemptHistory(mathSectionId) {
            if (!authToken) {
                alert('Please log in to view your attempt history.');
                return;
            }
            
            try {
                const url = `${API_BASE}/progress/math-sections/${mathSectionId}/attempts`;
                console.log('Fetching math section attempt history from:', url);
                
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    let errorMessage = 'Please try again.';
                    try {
                        const errorData = await response.json();
                        console.error('Error response:', errorData);
                        errorMessage = errorData.error?.message || errorMessage;
                    } catch (e) {
                        console.error('Failed to parse error response:', e);
                        errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    alert(`Failed to load attempt history. ${errorMessage}`);
                    return;
                }
                
                const attempts = await response.json();
                
                if (attempts.length === 0) {
                    alert('No attempts found for this math section. Try refreshing the page.');
                    return;
                }
                
                // Show attempts in a modal
                let attemptsHTML = '<div style="max-height: 70vh; overflow-y: auto;">';
                attemptsHTML += `<h3 style="margin-bottom: 20px; color: #3498DB;">Attempt History</h3>`;
                
                attempts.forEach((attempt, index) => {
                    const date = new Date(attempt.completed_at);
                    const dateStr = date.toLocaleString();
                    const percentage = Math.round((attempt.correct_count / attempt.total_questions) * 100);
                    
                    attemptsHTML += `
                        <div style="border: 1px solid #d0d0d0; border-radius: 8px; padding: 15px; margin-bottom: 15px; background: white;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <strong style="color: #000;">Attempt #${attempts.length - index}</strong>
                                <span style="color: #666; font-size: 12px;">${dateStr}</span>
                            </div>
                            <div style="color: #000; margin-bottom: 8px;">
                                Score: <strong style="color: #3498DB;">${attempt.correct_count} / ${attempt.total_questions} (${percentage}%)</strong>
                            </div>
                            ${attempt.time_spent_seconds ? `<div style="color: #666; font-size: 12px;">Time: ${Math.floor(attempt.time_spent_seconds / 60)}m ${attempt.time_spent_seconds % 60}s</div>` : ''}
                            <button class="btn btn-secondary" onclick="viewAttemptDetails('${attempt.id}', '${mathSectionId}', true, true)" style="margin-top: 10px; font-size: 12px; padding: 6px 12px;">
                                View Details
                            </button>
                        </div>
                    `;
                });
                
                attemptsHTML += '</div>';
                
                // Create and show modal
                const modal = document.createElement('div');
                modal.className = 'modal active';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 600px;">
                        <h2>Attempt History</h2>
                        ${attemptsHTML}
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()" style="margin-top: 20px; width: 100%;">Close</button>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Close on outside click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
            } catch (error) {
                console.error('Failed to load attempt history:', error);
                alert('Network error. Please try again.');
            }
        }
        
        function showUpgradeModal(contentType = 'content') {
            // Create and show upgrade modal
            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <h2>üîí Premium Content</h2>
                    <p style="margin-bottom: 20px; color: #666;">
                        This ${contentType} is part of our premium collection. Upgrade to unlock full access to all ${contentType}s, passages, and writing sections.
                    </p>
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="margin-top: 0; color: white;">Premium Benefits</h3>
                        <ul style="text-align: left; margin: 0; padding-left: 20px;">
                            <li>Access to all premium passages</li>
                            <li>Access to all premium lessons</li>
                            <li>Access to all premium writing sections</li>
                            <li>Detailed explanations and analytics</li>
                        </ul>
                    </div>
                    ${authToken ? 
                        `<button class="btn btn-primary" onclick="upgradeToPremium(); this.closest('.modal').remove();" style="width: 100%; font-size: 16px; padding: 12px;">
                            Upgrade to Premium - $5/month
                        </button>` :
                        `<button class="btn btn-primary" onclick="showRegisterModal(); this.closest('.modal').remove();" style="width: 100%; font-size: 16px; padding: 12px; margin-bottom: 10px;">
                            Sign Up to Upgrade
                        </button>
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove();" style="width: 100%; font-size: 14px; padding: 10px;">
                            Maybe Later
                        </button>`
                    }
                </div>
            `;
            document.body.appendChild(modal);
            
            // Close on outside click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        async function upgradeToPremium() {
            if (!authToken) {
                showRegisterModal();
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/payments/checkout`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (response.ok && data.url) {
                    // Store that we're going to checkout so we can refresh on return
                    localStorage.setItem('pendingSubscription', 'true');
                    window.location.href = data.url;
                } else {
                    // Show more detailed error message
                    const errorMessage = data.error?.message || 'Failed to create checkout session. Please try again.';
                    console.error('Checkout error:', data);
                    alert(errorMessage);
                }
            } catch (error) {
                console.error('Failed to create checkout:', error);
                alert('Network error. Please try again.');
            }
        }
        
        async function refreshUserData() {
            /**Refresh user data from server to get latest premium status*/
            if (!authToken) {
                console.log('No auth token, cannot refresh user data');
                return Promise.resolve(false);
            }
            
            try {
                // First, try to sync subscription from Stripe (in case webhook didn't fire)
                try {
                    const syncResponse = await fetch(`${API_BASE}/payments/sync`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${authToken}`,
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (syncResponse.ok) {
                        const syncData = await syncResponse.json();
                        console.log('Subscription synced from Stripe:', syncData);
                    }
                } catch (syncError) {
                    console.log('Sync failed (may not have subscription yet):', syncError);
                }
                
                // Then refresh user data
                const response = await fetch(`${API_BASE}/auth/me`, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });
                
                if (response.ok) {
                    currentUser = await response.json();
                    console.log('User data refreshed:', currentUser);
                    updateUI();
                    return true;
                }
            } catch (error) {
                console.error('Failed to refresh user data:', error);
            }
            return false;
        }
        
        function updateUI() {
            console.log('updateUI called, currentUser:', currentUser, 'authToken:', authToken ? 'SET' : 'NOT SET');
            if (currentUser) {
                console.log('User is logged in, updating UI to show user info');
                const authSection = document.getElementById('authSection');
                const userInfo = document.getElementById('userInfo');
                if (authSection) authSection.classList.add('hidden');
                if (userInfo) {
                    userInfo.classList.remove('hidden');
                    const emailEl = document.getElementById('userEmail');
                    if (emailEl) emailEl.textContent = currentUser.email;
                    
                    // Check both is_premium flag and has_active_subscription
                    const isPremium = currentUser.is_premium || currentUser.has_active_subscription;
                    
                    if (isPremium) {
                        const statusEl = document.getElementById('subscriptionStatus');
                        if (statusEl) statusEl.textContent = 'Premium Active';
                        const btn = document.getElementById('subscriptionButton');
                        if (btn) {
                            btn.textContent = 'Manage Subscription';
                            btn.onclick = manageSubscription;
                            btn.classList.remove('btn-success');
                            btn.classList.add('btn-secondary');
                        }
                    } else {
                        const statusEl = document.getElementById('subscriptionStatus');
                        if (statusEl) statusEl.textContent = 'Free';
                        const btn = document.getElementById('subscriptionButton');
                        if (btn) {
                            btn.textContent = 'Upgrade to Premium ($5/month)';
                            btn.onclick = upgradeToPremium;
                            btn.classList.remove('btn-secondary');
                            btn.classList.add('btn-success');
                        }
                    }
                }
            } else {
                console.log('No user, showing login/register buttons');
                const authSection = document.getElementById('authSection');
                const userInfo = document.getElementById('userInfo');
                if (authSection) authSection.classList.remove('hidden');
                if (userInfo) userInfo.classList.add('hidden');
            }
        }
        
        async function manageSubscription() {
            if (!authToken) return;
            
            try {
                const response = await fetch(`${API_BASE}/payments/portal`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (response.ok && data.url) {
                    window.location.href = data.url;
                }
            } catch (error) {
                console.error('Failed to open portal:', error);
            }
        }
        
        function logout() {
            localStorage.removeItem('authToken');
            authToken = null;
            currentUser = null;
            updateUI();
            loadPassages();
        }
        
        function showLoginModal() {
            document.getElementById('loginModal').classList.add('active');
            document.getElementById('loginError').textContent = '';
        }
        
        function showRegisterModal() {
            document.getElementById('registerModal').classList.add('active');
            document.getElementById('registerError').textContent = '';
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }
        
        async function loadWordOfDay() {
            try {
                const response = await fetch(`${API_BASE}/word-of-the-day`);
                if (response.ok) {
                    const data = await response.json();
                    displayWordOfDay(data);
                } else {
                    document.getElementById('wordOfDay').innerHTML = `
                        <h3>Word of the Day</h3>
                        <div class="loading">Unable to load word of the day</div>
                    `;
                }
            } catch (error) {
                console.error('Failed to load word of day:', error);
                document.getElementById('wordOfDay').innerHTML = `
                    <h3>Word of the Day</h3>
                    <div class="loading">Unable to load word of the day</div>
                `;
            }
        }
        
        function displayWordOfDay(data) {
            const synonyms = data.synonyms || [];
            const synonymTags = synonyms.map(syn => 
                `<span class="synonym-tag">${syn}</span>`
            ).join('');
            
            document.getElementById('wordOfDay').innerHTML = `
                <h3>Word of the Day</h3>
                <div class="word">${data.word}</div>
                <div class="definition">${data.definition}</div>
                ${synonyms.length > 0 ? `
                    <div class="synonyms">
                        <div class="synonyms-label">Synonyms:</div>
                        <div class="synonym-tags">${synonymTags}</div>
                    </div>
                ` : ''}
                <div class="example">
                    <div class="example-label">Example:</div>
                    <div class="example-sentence">"${data.example_sentence}"</div>
                </div>
            `;
        }
        
        // Close modal on outside click
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            });
        });
    </script>
</body>
</html>



